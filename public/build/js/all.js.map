{"version":3,"sources":["datatables-datetime-moment.js","modernizr-custom.js","mdn-round.js","main.js","milestone-competency-radar-chart.js","evaluation-line-chart.js","bundle.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"all.js","sourcesContent":["/**\n * This plug-in for DataTables represents the ultimate option in extensibility\n * for sorting date / time strings correctly. It uses\n * [Moment.js](http://momentjs.com) to create automatic type detection and\n * sorting plug-ins for DataTables based on a given format. This way, DataTables\n * will automatically detect your temporal information and sort it correctly.\n *\n * For usage instructions, please see the DataTables blog\n * post that [introduces it](//datatables.net/blog/2014-12-18).\n *\n * @name Ultimate Date / Time sorting\n * @summary Sort date and time in any format using Moment.js\n * @author [Allan Jardine](//datatables.net)\n * @depends DataTables 1.10+, Moment.js 1.7+\n *\n * @example\n *    $.fn.dataTable.moment( 'HH:mm MMM D, YY' );\n *    $.fn.dataTable.moment( 'dddd, MMMM Do, YYYY' );\n *\n *    $('#example').DataTable();\n */\n\n(function (factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([\"jquery\", \"moment\", \"datatables\"], factory);\n\t} else {\n\t\tfactory(jQuery, moment);\n\t}\n}(function ($, moment) {\n\n$.fn.dataTable.moment = function ( format, locale ) {\n\tvar types = $.fn.dataTable.ext.type;\n\n\t// Add type detection\n\ttypes.detect.unshift( function ( d ) {\n\t\t// Strip HTML tags if possible\n\t\tif ( d && d.replace ) {\n\t\t\td = d.replace(/<.*?>/g, '');\n\t\t}\n\n\t\t// Null and empty values are acceptable\n\t\tif ( d === '' || d === null ) {\n\t\t\treturn 'moment-'+format;\n\t\t}\n\n\t\treturn moment( d, format, locale, true ).isValid() ?\n\t\t\t'moment-'+format :\n\t\t\tnull;\n\t} );\n\n\t// Add sorting method - use an integer for the sorting\n\ttypes.order[ 'moment-'+format+'-pre' ] = function ( d ) {\n\t\treturn d === '' || d === null ?\n\t\t\t-Infinity :\n\t\t\tparseInt( moment( d.replace ? d.replace(/<.*?>/g, '') : d, format, locale, true ).format( 'x' ), 10 );\n\t};\n};\n\n}));\n","/*! modernizr 3.2.0 (Custom Build) | MIT *\n * http://modernizr.com/download/?-canvas-flexbox-flexwrap-setclasses !*/\n!function(e,n,t){function r(e,n){return typeof e===n}function o(){var e,n,t,o,s,i,a;for(var l in C)if(C.hasOwnProperty(l)){if(e=[],n=C[l],n.name&&(e.push(n.name.toLowerCase()),n.options&&n.options.aliases&&n.options.aliases.length))for(t=0;t<n.options.aliases.length;t++)e.push(n.options.aliases[t].toLowerCase());for(o=r(n.fn,\"function\")?n.fn():n.fn,s=0;s<e.length;s++)i=e[s],a=i.split(\".\"),1===a.length?Modernizr[a[0]]=o:(!Modernizr[a[0]]||Modernizr[a[0]]instanceof Boolean||(Modernizr[a[0]]=new Boolean(Modernizr[a[0]])),Modernizr[a[0]][a[1]]=o),g.push((o?\"\":\"no-\")+a.join(\"-\"))}}function s(e){var n=w.className,t=Modernizr._config.classPrefix||\"\";if(_&&(n=n.baseVal),Modernizr._config.enableJSClass){var r=new RegExp(\"(^|\\\\s)\"+t+\"no-js(\\\\s|$)\");n=n.replace(r,\"$1\"+t+\"js$2\")}Modernizr._config.enableClasses&&(n+=\" \"+t+e.join(\" \"+t),_?w.className.baseVal=n:w.className=n)}function i(){return\"function\"!=typeof n.createElement?n.createElement(arguments[0]):_?n.createElementNS.call(n,\"http://www.w3.org/2000/svg\",arguments[0]):n.createElement.apply(n,arguments)}function a(e,n){return!!~(\"\"+e).indexOf(n)}function l(e){return e.replace(/([a-z])-([a-z])/g,function(e,n,t){return n+t.toUpperCase()}).replace(/^-/,\"\")}function f(e,n){return function(){return e.apply(n,arguments)}}function u(e,n,t){var o;for(var s in e)if(e[s]in n)return t===!1?e[s]:(o=n[e[s]],r(o,\"function\")?f(o,t||n):o);return!1}function d(e){return e.replace(/([A-Z])/g,function(e,n){return\"-\"+n.toLowerCase()}).replace(/^ms-/,\"-ms-\")}function p(){var e=n.body;return e||(e=i(_?\"svg\":\"body\"),e.fake=!0),e}function c(e,t,r,o){var s,a,l,f,u=\"modernizr\",d=i(\"div\"),c=p();if(parseInt(r,10))for(;r--;)l=i(\"div\"),l.id=o?o[r]:u+(r+1),d.appendChild(l);return s=i(\"style\"),s.type=\"text/css\",s.id=\"s\"+u,(c.fake?c:d).appendChild(s),c.appendChild(d),s.styleSheet?s.styleSheet.cssText=e:s.appendChild(n.createTextNode(e)),d.id=u,c.fake&&(c.style.background=\"\",c.style.overflow=\"hidden\",f=w.style.overflow,w.style.overflow=\"hidden\",w.appendChild(c)),a=t(d,e),c.fake?(c.parentNode.removeChild(c),w.style.overflow=f,w.offsetHeight):d.parentNode.removeChild(d),!!a}function m(n,r){var o=n.length;if(\"CSS\"in e&&\"supports\"in e.CSS){for(;o--;)if(e.CSS.supports(d(n[o]),r))return!0;return!1}if(\"CSSSupportsRule\"in e){for(var s=[];o--;)s.push(\"(\"+d(n[o])+\":\"+r+\")\");return s=s.join(\" or \"),c(\"@supports (\"+s+\") { #modernizr { position: absolute; } }\",function(e){return\"absolute\"==getComputedStyle(e,null).position})}return t}function v(e,n,o,s){function f(){d&&(delete T.style,delete T.modElem)}if(s=r(s,\"undefined\")?!1:s,!r(o,\"undefined\")){var u=m(e,o);if(!r(u,\"undefined\"))return u}for(var d,p,c,v,h,y=[\"modernizr\",\"tspan\"];!T.style;)d=!0,T.modElem=i(y.shift()),T.style=T.modElem.style;for(c=e.length,p=0;c>p;p++)if(v=e[p],h=T.style[v],a(v,\"-\")&&(v=l(v)),T.style[v]!==t){if(s||r(o,\"undefined\"))return f(),\"pfx\"==n?v:!0;try{T.style[v]=o}catch(g){}if(T.style[v]!=h)return f(),\"pfx\"==n?v:!0}return f(),!1}function h(e,n,t,o,s){var i=e.charAt(0).toUpperCase()+e.slice(1),a=(e+\" \"+b.join(i+\" \")+i).split(\" \");return r(n,\"string\")||r(n,\"undefined\")?v(a,n,o,s):(a=(e+\" \"+E.join(i+\" \")+i).split(\" \"),u(a,n,t))}function y(e,n,r){return h(e,t,t,n,r)}var g=[],C=[],x={_version:\"3.2.0\",_config:{classPrefix:\"\",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,n){var t=this;setTimeout(function(){n(t[e])},0)},addTest:function(e,n,t){C.push({name:e,fn:n,options:t})},addAsyncTest:function(e){C.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=x,Modernizr=new Modernizr;var w=n.documentElement,_=\"svg\"===w.nodeName.toLowerCase();Modernizr.addTest(\"canvas\",function(){var e=i(\"canvas\");return!(!e.getContext||!e.getContext(\"2d\"))});var S=\"Moz O ms Webkit\",b=x._config.usePrefixes?S.split(\" \"):[];x._cssomPrefixes=b;var E=x._config.usePrefixes?S.toLowerCase().split(\" \"):[];x._domPrefixes=E;var P={elem:i(\"modernizr\")};Modernizr._q.push(function(){delete P.elem});var T={style:P.elem.style};Modernizr._q.unshift(function(){delete T.style}),x.testAllProps=h,x.testAllProps=y,Modernizr.addTest(\"flexbox\",y(\"flexBasis\",\"1px\",!0)),Modernizr.addTest(\"flexwrap\",y(\"flexWrap\",\"wrap\",!0)),o(),s(g),delete x.addTest,delete x.addAsyncTest;for(var z=0;z<Modernizr._q.length;z++)Modernizr._q[z]();e.Modernizr=Modernizr}(window,document);\n","// Closure\n(function() {\n  /**\n   * Decimal adjustment of a number.\n   *\n   * @param {String}  type  The type of adjustment.\n   * @param {Number}  value The number.\n   * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).\n   * @returns {Number} The adjusted value.\n   */\n  function decimalAdjust(type, value, exp) {\n    // If the exp is undefined or zero...\n    if (typeof exp === 'undefined' || +exp === 0) {\n      return Math[type](value);\n    }\n    value = +value;\n    exp = +exp;\n    // If the value is not a number or the exp is not an integer...\n    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {\n      return NaN;\n    }\n    // Shift\n    value = value.toString().split('e');\n    value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));\n    // Shift back\n    value = value.toString().split('e');\n    return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));\n  }\n\n  // Decimal round\n  if (!Math.round10) {\n    Math.round10 = function(value, exp) {\n      return decimalAdjust('round', value, exp);\n    };\n  }\n  // Decimal floor\n  if (!Math.floor10) {\n    Math.floor10 = function(value, exp) {\n      return decimalAdjust('floor', value, exp);\n    };\n  }\n  // Decimal ceil\n  if (!Math.ceil10) {\n    Math.ceil10 = function(value, exp) {\n      return decimalAdjust('ceil', value, exp);\n    };\n  }\n})();\n","window.Chart1 = window.Chart;\n\n$.ajaxSetup({\n\theaders: {\n\t\t'X-CSRF-TOKEN': $(\"meta[name='csrf_token']\").attr(\"content\")\n\t}\n});\n\nmoment.updateLocale(\"en\", {\n\tcalendar: {\n\t\tlastDay : '[Yesterday at] LT',\n\t\tsameDay : '[Today at] LT',\n\t\tnextDay : '[Tomorrow at] LT',\n\t\tlastWeek : '[Last] dddd [at] LT',\n\t\tnextWeek : 'dddd [at] LT',\n\t\tsameElse: \"ll\"\n\t}\n});\n\nvar numSpecificReports = 0;\nfunction reportHtml(i) {\n\treturn '<div class=\"report-options collapse\">'+\n\t'<button type=\"button\" class=\"close remove-report-group\" aria-hidden=\"true\">&times;</button>'+\n\t'<h3>Report</h3>'+\n '<div class=\"form-group\">'+\n   '<label for=\"startDate'+i+'\">Start Date:</label>'+\n   '<input type=\"text\" class=\"form-control datepicker startDate\" id=\"startDate'+i+'\" name=\"startDate'+i+'\">'+\n '</div>'+\n '<div class=\"form-group\">'+\n   '<label for=\"endDate\">End Date:</label>'+\n   '<input type=\"text\" class=\"form-control datepicker endDate\" id=\"endDate'+i+'\" name=\"endDate'+i+'\">'+\n '</div>'+\n '<div class=\"form-group\" style=\"text-align: center;\">'+\n   '<button type=\"button\" class=\"btn lastThreeMonths\">Last Three Months</button> '+\n   '<button type=\"button\" class=\"btn lastSixMonths\">Last Six Months</button>'+\n '</div>'+\n '<div class=\"form-group\">'+\n   '<label for=\"trainingLevelInput'+i+'\">Training Level</label>'+\n   '<select class=\"form-control select2\" id=\"trainingLevelInput'+i+'\" name=\"trainingLevel'+i+'\" style=\"width: 100%\" required>'+\n\t '<option value=\"all\">All</option>'+\n\t '<option value=\"intern\">Intern</option>'+\n\t '<option value=\"ca-1\">CA-1</option>'+\n\t '<option value=\"ca-2\">CA-2</option>'+\n\t '<option value=\"ca-3\">CA-3</option>'+\n\t '<option value=\"fellow\">Fellow</option>'+\n   '</select>'+\n '</div>'+\n '<hr /><br />'+\n '</div>';\n}\n\nfunction addSendEmailModalBody(modal, replacements){\n\tmodal.find(\".ids-list-button\").click(function(){\n\t\t$(\".ids-container\").slideToggle();\n\t});\n\n\tmodal.find(\".body-rendered\").mouseenter(showEmailBody);\n\tmodal.find(\".body-rendered\").focusin(focusEmailBody);\n\n\tfunction showEmailBody(){\n\t\tmodal.find(\".body-rendered\").hide();\n\t\tmodal.find(\".body\").show();\n\t}\n\n\tfunction focusEmailBody(){\n\t\tshowEmailBody();\n\t\tmodal.find(\".body\").focus()\n\t}\n\n\tmodal.find(\".body\").mouseleave(function(){\n\t\tif(!$(this).is(document.activeElement))\n\t\t\tunfocusEmailBody();\n\t});\n\tmodal.find(\".body\").focusout(unfocusEmailBody);\n\n\tunfocusEmailBody();\n\n\tfunction unfocusEmailBody(){\n\t\tmodal.find(\".body\").hide();\n\t\tmarkupEmailBody();\n\t\tmodal.find(\".body-rendered\").show();\n\t}\n\n\n\tfunction markupEmailBody(){\n\t\tvar bodyText = marked(modal.find(\".body\").val());\n\n\t\tfor(var i = 0; i < replacements.length; i++){\n\t\t\tvar replacement = replacements[i];\n\t\t\tvar pattern = new RegExp(\"\\\\[\\\\[\" + replacement + \"\\\\]\\\\]\", \"g\");\n\t\t\tvar label = '<span class=\"label label-info\">' + replacement + '</span>';\n\t\t\tbodyText = bodyText.replace(pattern, label);\n\t\t}\n\n\t\tmodal.find(\".body-rendered\").html(bodyText);\n\t}\n}\n\nfunction openSendEmailModal(users, modal, subjectText, bodyText,\n\t\t\t\t\t\t\tsendSingleCallback, sendAllCallback,\n\t\t\t\t\t\t\tusersTitle, replacements){\n\tvar user;\n\tmodal.find(\".send\")\n\t\t.off(\"click\", sendSingleCallback)\n\t\t.off(\"click\", sendAllCallback);\n\n\tif(Array.isArray(users)){\n\t\tvar list = modal.find(\".ids-list\")[0];\n\t\tvar li, checkbox, label, labelText;\n\t\tvar numSentUsers = 0;\n\n\t\t$(list).empty();\n\t\tfor(var i = 0; i < users.length; i++){\n\t\t\tuser = users[i];\n\n\t\t\tli = document.createElement(\"li\");\n\t\t\tlabel = document.createElement(\"label\");\n\t\t\tcheckbox = document.createElement(\"input\");\n\t\t\tcheckbox.type = \"checkbox\";\n\t\t\tcheckbox.className = \"send-all-id\";\n\t\t\tcheckbox.value = user.id;\n\t\t\tif(!user.email)\n\t\t\t\tcheckbox.disabled = true;\n\t\t\telse if(user.send){\n\t\t\t\tcheckbox.checked = true;\n\t\t\t\tnumSentUsers++;\n\t\t\t}\n\t\t\tif(user.data){\n\t\t\t\tvar dataKeys = Object.keys(user.data);\n\t\t\t\tfor(var j = 0; j < dataKeys.length; j++){\n\t\t\t\t\tcheckbox.setAttribute(\"data-\" + dataKeys[j], user.data[dataKeys[j]]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlabel.appendChild(checkbox);\n\t\t\tlabelText = document.createTextNode(\" \" + user.full_name);\n\t\t\tlabel.appendChild(labelText);\n\t\t\tli.appendChild(label);\n\t\t\tlist.appendChild(li);\n\t\t}\n\n\t\tif(numSentUsers <= 6)\n\t\t\tmodal.find(\".ids-container\").show();\n\t\telse\n\t\t\tmodal.find(\".ids-container\").hide();\n\n\t\t$(\".send-all-id\").change(function(){\n\t\t\tvar numSentUsers = parseInt($(\".to\").val().split(\" \")[0], 10);\n\t\t\tif($(this).prop(\"checked\"))\n\t\t\t\tnumSentUsers++;\n\t\t\telse\n\t\t\t\tnumSentUsers--;\n\t\t\t$(\".to\").val(numSentUsers + \" \" + usersTitle);\n\t\t});\n\n\t\tmodal.find(\".to\").val(numSentUsers + \" \" + usersTitle);\n\t\tmodal.find(\".to-container\").addClass(\"input-group\");\n\t\tmodal.find(\".ids-list-button-container\").show();\n\t\tappendAlert(\"Please verify list of residents before sending\", modal.find(\".alert-container\"), \"warning\");\n\t\tmodal.find(\".send\").click(sendAllCallback);\n\t} else {\n\t\tuser = users;\n\t\tmodal.find(\".id\").val(user.id);\n\t\tmodal.find(\".to\").val(user.full_name + \" <\" + user.email + \">\");\n\t\tmodal.find(\".to-container\").removeClass(\"input-group\");\n\t\tmodal.find(\".ids-list-button-container\").hide();\n\t\tmodal.find(\".ids-list\").empty();\n\t\tmodal.find(\".ids-container\").hide();\n\t\tmodal.find(\".send\").click(sendSingleCallback);\n\t}\n\n\tmodal.find(\".subject\").val(subjectText);\n\tmodal.find(\".body\").val(bodyText);\n\n\tvar bodyHeight = 300;\n\tmodal.find(\".body-rendered\").height(bodyHeight);\n\taddSendEmailModalBody(modal, replacements);\n\tmodal.modal(\"show\");\n}\n\n\n$(\"#addNewSpecificReport\").click(function(){\n\tvar report = reportHtml(++numSpecificReports);\n\t$(report).appendTo(\".modal-specRpt\").velocity(\"slideDown\");\n\t$(\".datepicker\").datepicker({\n\t\tdateFormat: \"yy-mm-dd\"\n\t});\n});\n\n $(\".modal-specRpt\").on(\"click\", \".remove-report-group\", function(){\n\t$(this).parent().velocity(\"slideUp\", function(){\n\t\t$(this).remove();\n\t});\n });\n\nfunction checkReportQuery(){\n//Checks the report queries to make sure the entered date is of the correct format because not all browsers support the html5 datepicker being used.\n\tdateError = false;\n\t$(this).find(\"input\").each(function(){\n\t\tif($(this).attr(\"type\") == \"date\" || $(this).hasClass(\"datepicker\")){\n\t\t\tvar date = $(this).val();\n\t\t\tvar regex = /^\\d\\d\\d\\d-\\d\\d-\\d\\d$/;\n\t\t\tif(!new RegExp(regex).test(date)){\n\t\t\t\tdateError = true;\n\t\t\t}\n\t\t}\n\t});\n\n\tif(dateError){\n\t\talert(\"Please enter a valid date. If your browser does not support the date selector, date must be formatted YYYY-MM-DD\");\n\t}\n\n\treturn !dateError;\n}\n\nfunction lastSixMonths(){\n\tsetStartEndDates.call(this, 6);\n}\n\nfunction lastThreeMonths(){\n\tsetStartEndDates.call(this, 3);\n}\n\nfunction setStartEndDates(months){\n\tmonths = months != undefined ? months : 3;\n\tvar end = moment().subtract(1, \"month\").endOf(\"month\");\n\tvar start = moment(end).startOf(\"month\").subtract(months-1, \"month\");\n\t$(this).parents(\".report-options\").find(\".startDate\").val(start.format(\"YYYY-MM-DD\"));\n\t$(this).parents(\".report-options\").find(\".endDate\").val(end.format(\"YYYY-MM-DD\"));\n}\n\nfunction addDateSelectors(dateName, idPrefix, containerQuery, defaultMonth, lastDaySelectedByDefault){\n\t// This is a better input method, but I wanted a non-js fallback so that's the default\n\n\tvar html =\n\t'<input type=\"hidden\" id=\"' + idPrefix +  'date\" name=\"' + dateName + '\" />' +\n\t'<div class=\"row\">' +\n\t\t'<label><input type=\"checkbox\" id=\"' + idPrefix + 'date-unknown\" /> Unknown<label>' +\n\t'</div>' +\n\t'<div class=\"row\" id=\"' + idPrefix + 'parts-container\">' +\n\t\t'<div class=\"col-md-4\">' +\n\t\t\t'<label for=\"' + idPrefix +  'date-year\">Year</label>' +\n\t\t\t'<select class=\"form-control\" id=\"' + idPrefix +  'date-year\"></select>' +\n\t\t'</div>' +\n\t\t'<div class=\"col-md-4\">' +\n\t\t\t'<label for=\"' + idPrefix +  'date-month\">Month</label>' +\n\t\t\t'<select class=\"form-control\" id=\"' + idPrefix +  'date-month\"></select>' +\n\t\t'</div>' +\n\t\t'<div class=\"col-md-4\">' +\n\t\t\t'<label for=\"' + idPrefix +  'date-day\">Day</label>' +\n\t\t\t'<select class=\"form-control\" id=\"' + idPrefix +  'date-day\"></select>' +\n\t\t'</div>' +\n\t'</div>';\n\n\tvar container = $(containerQuery);\n\tcontainer.append(html);\n\tvar option;\n\n\tvar yearSelect = container.find(\"#\" + idPrefix +  \"date-year\")[0];\n\tvar year = moment().get(\"year\");\n\tfor(var i = 0; i < 100; i++, year--){\n\t\toption = document.createElement(\"option\");\n\t\toption.value = year;\n\t\toption.appendChild(document.createTextNode(year));\n\t\tyearSelect.appendChild(option);\n\t}\n\n\tvar monthSelect = container.find(\"#\" + idPrefix +  \"date-month\")[0];\n\tmoment.months().forEach(function(month, index){\n\t\toption = document.createElement(\"option\");\n\t\toption.value = index;\n\t\toption.appendChild(document.createTextNode(month));\n\t\tif(index == defaultMonth)\n\t\t\toption.selected = true;\n\t\tmonthSelect.appendChild(option);\n\t});\n\n\tvar daySelect = container.find(\"#\" + idPrefix +  \"date-day\")[0];\n\tfor(var day = 0; day <= 30; day++){\n\t\toption = document.createElement(\"option\");\n\t\toption.value = day;\n\t\toption.appendChild(document.createTextNode(day));\n\t\tif(day == 30 & lastDaySelectedByDefault)\n\t\t\toption.selected = true;\n\t\tdaySelect.appendChild(option);\n\t}\n\n\t$(\"#\" + idPrefix +  \"date-year\").change(function(){\n\t\tvar daySelect = $(\"#\" + idPrefix +  \"date-day\")[0];\n\t\twhile(daySelect.firstChild)\n\t\t\tdaySelect.removeChild(daySelect.firstChild);\n\n\t\tvar year = parseInt($(this).val(), 10);\n\t\tvar month = parseInt($(\"#\" + idPrefix +  \"date-month\").val(), 10);\n\t\tvar daysInMonth = moment().year(year).month(month).daysInMonth();\n\t\tfor(var day = 1; day <= daysInMonth; day++){\n\t\t\toption = document.createElement(\"option\");\n\t\t\toption.value = day;\n\t\t\toption.appendChild(document.createTextNode(day));\n\t\t\tif(day == daysInMonth && lastDaySelectedByDefault)\n\t\t\t\toption.selected = true;\n\t\t\tdaySelect.appendChild(option);\n\t\t}\n\t});\n\n\t$(\"#\" + idPrefix +  \"date-month\").change(function(){\n\t\tvar date = moment($(\"#\" + idPrefix + \"date\").val());\n\t\tvar daySelect = $(\"#\" + idPrefix +  \"date-day\")[0];\n\t\twhile(daySelect.firstChild)\n\t\t\tdaySelect.removeChild(daySelect.firstChild);\n\n\t\tvar month = parseInt($(this).val(), 10);\n\t\tvar year = parseInt($(\"#\" + idPrefix +  \"date-year\").val(), 10);\n\t\tvar daysInMonth = moment().year(year).month(month).daysInMonth();\n\t\tfor(var day = 1; day <= daysInMonth; day++){\n\t\t\toption = document.createElement(\"option\");\n\t\t\toption.value = day;\n\t\t\toption.appendChild(document.createTextNode(day));\n\t\t\tif(day == daysInMonth && lastDaySelectedByDefault)\n\t\t\t\toption.selected = true;\n\t\t\tdaySelect.appendChild(option);\n\t\t}\n\t});\n\n\tfunction updateDate(){\n\t\tif($(\"#\" + idPrefix + \"date-unknown\").prop(\"checked\")){\n\t\t\t$(\"#\" + idPrefix +  \"date\").val(\"\");\n\t\t\treturn;\n\t\t}\n\n\t\tvar year = parseInt($(\"#\" + idPrefix +  \"date-year\").val(), 10);\n\t\tvar month = parseInt($(\"#\" + idPrefix +  \"date-month\").val(), 10);\n\t\tvar day = parseInt($(\"#\" + idPrefix +  \"date-day\").val(), 10);\n\t\tvar date = moment().year(year).month(month).date(day);\n\t\tif(date.isValid())\n\t\t\t$(\"#\" + idPrefix +  \"date\").val(date.format(\"YYYY-MM-DD\"));\n\t}\n\n\t$(\"#\" + idPrefix +  \"date-year, #\" + idPrefix +  \"date-month, #\" + idPrefix +  \"date-day\").change(updateDate);\n\n\tfunction unknownDate(){\n\t\t$(\"#\" + idPrefix +  \"date-year, #\" + idPrefix +  \"date-month, #\" + idPrefix +  \"date-day\")\n\t\t\t.prop(\"disabled\", $(this).prop(\"checked\"));\n\t\tupdateDate();\n\n\t\t$(this).prop(\"checked\")\n\t\t\t? $(\"#\" + idPrefix + \"parts-container\").velocity(\"slideUp\")\n\t\t\t: $(\"#\" + idPrefix + \"parts-container\").velocity(\"slideDown\");\n\t}\n\n\t$(\"#\" + idPrefix + \"date-unknown\").change(unknownDate);\n}\n\n$(document).ready(function(){\n\t$.fn.dataTable.moment( \"DD-MMM-YYYY h:mm A\" );\n\n\t$(\".report\").submit(checkReportQuery);\n\t$(\".report\").on(\"click\", \".lastSixMonths\", lastSixMonths);\n\t$(\".report\").on(\"click\", \".lastThreeMonths\", lastThreeMonths);\n\t$(\".datepicker\").datepicker({\n\t\tdateFormat: \"yy-mm-dd\"\n\t});\n\n\t$(\"#addNewSpecificReport\").click();\n\n\t$.extend(true, $.fn.dataTable.defaults, {\n\t\tlanguage: {\n\t\t\temptyTable: \"No entries available\",\n\t\t\tzeroRecords: \"No matching entries, please revise your search\",\n\t\t\tpaginate: {\n\t\t\t\tprevious: \"&lt;\",\n\t\t\t\tnext: \"&gt;\"\n\t\t\t}\n\t\t},\n\t\tstateSave: true,\n\t\tdeferRender: true,\n\t\tdom: \"lfprtip\"\n\t});\n\n\t$.fn.select2.defaults.set(\"theme\", \"bootstrap\");\n\n\t$(\".select2\").val(null).select2({\n\t\tplaceholder: \"Please select\"\n\t});\n\n\t$(\"body\").css(\"padding-top\", $(\"#main-navbar\").height()+5);\n\n\t$(\"#individual-milestones, #aggregate-milestones\").multiSelect({\n\t\tselectableOptgroup: true\n\t});\n\n});\n\n// https://davidwalsh.name/essential-javascript-functions\nfunction debounce(func, wait, immediate){\n\tvar timeout;\n\treturn function(){\n\t\tvar context = this, args = arguments;\n\t\tvar later = function(){\n\t\t\ttimeout = null;\n\t\t\tif(!immediate) func.apply(context, args);\n\t\t};\n\t\tvar callNow = immediate && !timeout;\n\t\tclearTimeout(timeout);\n\t\ttimeout = setTimeout(later, wait);\n\t\tif(callNow) func.apply(context, args);\n\t}\n}\n\nvar fixNavbarOffset = debounce(function(){\n\t$(\"body\").css(\"padding-top\", $(\"#main-navbar\").height()+5);\n}, 100);\n\n$(window).resize(fixNavbarOffset);\n\n$(\".table\").on(\"click\", \".view-evaluation\", function(){\n\tvar requestId = $(this).children(\"td\").eq(0).children(\"a\").html();\n\twindow.location.href = \"/evaluation/\"+requestId;\n});\n\n$(\".report-milestones-info\").popover({\n\tplacement: \"left\",\n\thtml: \"true\",\n\tcontent: \"<ul>\" +\n\t\t\t\"<li>Leave empty to include all milestones in training level in report</li>\" +\n\t\t\t\"<li>Click a milestone type heading to select all milestones of that type</li>\" +\n\t\t\"</ul>\"\n});\n\n$(\".toggle-descriptions\").click(function(){\n\tvar questionName = $(this).data(\"id\");\n\tvar headerHeight = $(\"#main-navbar\").height();\n\tvar padding = 5;\n\tvar scrollto = $(this).parents(\".question\").velocity(\"scroll\", {offset: -(headerHeight + padding)});\n\tvar isExpanded = $(\"#\" + questionName).hasClass(\"expanded-descriptions\");\n\tif(isExpanded){\n\t\t$(\".\" + questionName + \" .description\").velocity(\"slideUp\", function(){\n\t\t\t$(\"#\" + questionName).removeClass(\"expanded-descriptions\");\n\t\t});\n\t\t$(this).html('<span class=\"glyphicon glyphicon-zoom-in\"></span> Show descriptions');\n\t}\n\telse {\n\t\t$(\"#\" + questionName).addClass(\"expanded-descriptions\");\n\t\t$(\".\" + questionName + \" .description\").velocity(\"slideDown\");\n\t\t$(this).html('<span class=\"glyphicon glyphicon-zoom-out\"></span> Hide descriptions');\n\t}\n});\n\n$(\"table\").on(\"mouseenter\", \".table-date-cell\", function(){\n\tvar date = $(this).data(\"date-value\");\n\tif(date){\n\t\t$(this).data(\"original-value\", $(this).text());\n\t\t$(this).text(moment(date).format(\"ll\"));\n\t}\n});\n\n$(\"table\").on(\"mouseenter\", \".table-date-time-cell\", function(){\n\tvar date = $(this).data(\"date-value\");\n\tif(date){\n\t\t$(this).data(\"original-value\", $(this).text());\n\t\t$(this).text(moment(date).format(\"ll LT\"));\n\t}\n});\n\n$(\"table\").on(\"mouseleave\", \".table-date-cell, .table-date-time-cell\", function(){\n\tvar originalValue = $(this).data(\"originalValue\");\n\tif(originalValue)\n\t\t$(this).text(originalValue);\n});\n\nfunction confirmDeletion(event){\n\tevent.stopPropagation();\n\t$(\".confirm-delete\").removeClass(\"confirm-delete\")\n\t\t.html('<span class=\"glyphicon glyphicon-remove\"></span> Delete');\n\t$(this).addClass(\"confirm-delete\")\n\t\t.html('<span class=\"glyphicon glyphicon-remove\"></span> Confirm delete');\n}\n\n$(\".table-filter-select\").change(function(){\n\tvar filterType = $(this).val();\n\t$($(this).data(\"filterTable\")).DataTable({\n\t\tretrieve: true\n\t}).column($(this).data(\"filterColumn\")).search(filterType, false, false, false).draw();\n});\n\n$(\".refresh-table-glyph\").click(function(){\n\t$($(this).data(\"table\")).DataTable({\n\t\tretrieve: true\n\t}).ajax.reload();\n\t$(this).attr(\"title\", \"Refreshed!\").tooltip(\"fixTitle\").tooltip(\"show\");;\n});\n\n$(\".refresh-table-glyph\").on(\"hidden.bs.tooltip\", function(){\n\t$(this).attr(\"title\", \"Refresh\").tooltip(\"fixTitle\");\n});\n\n$(\"[data-toggle='tooltip']\").tooltip();\n\n$(document).on(\"click\", \".close-body-block-button\", function(){\n\t$(this).parents(\".body-block\").velocity(\"fadeOut\");\n});\n\n$(document).on(\"click\", \".hide-body-block-button\", function(){\n\t$(this).parents(\".body-block\").velocity(\"slideUp\");\n});\n","\n// MCW Colors\n// var averageSolidColor = \"rgba(0,67,100,1)\";\n// var averageFillColor = \"rgba(0,67,100,0.2)\";\n// var individualSolidColor = \"rgba(1,108,100,1)\";\n// var individualFillColor = \"rgba(1,108,100,0.2)\";\n\nvar averageSolidColor = \"rgba(227,227,0,1)\";\nvar averageFillColor = \"rgba(227,227,0,0.3)\";\nvar individualSolidColor = \"rgba(227,0,0,1)\";\nvar individualFillColor = \"rgba(227,0,0,0.3)\";\n\nvar options = {\n\tanimation: false,\n\tresponsive: true,\n\tangleLineWidth: 2,\n\ttooltipTemplate: \"<%if (label){%><%=label%>: <%}%><%= Math.round10(value, -2) %>\",\n\tmultiTooltipTemplate: \"<%= Math.round10(value, -2) %>\",\n\tlegendTemplate: \"<ul class=\\\"legend <%=name.toLowerCase()%>-legend\\\">\" +\n\t\t\"<% for (var i=0; i<datasets.length; i++){%>\" +\n\t\t\t\"<li><span class=\\\"glyphicon glyphicon-stop\\\" style=\\\"color:<%=datasets[i].strokeColor%>\\\"></span> \" +\n\t\t\t\"<%if(datasets[i].label){%><%=datasets[i].label%>\" +\n\t\t\"<%}%></li><%}%></ul>\",\n\tscaleShowLabels: true,\n\tscaleOverride: true,\n\tscaleLineWidth: 2,\n\tscaleSteps: 5,\n\tscaleStepWidth: 2,\n\tscaleStartValue: 0,\n\tscaleLabel: function(values){\n\t\treturn scaleLabels[values.value/2];\n\t}\n};\n\nfunction drawRadarGraphs(milestoneData, competencyData, title, index){\n\tindex = typeof index != \"undefined\" ? index : 0;\n\n\tvar div = document.getElementsByClassName(\"graphs\")[index];\n\tvar row = document.createElement(\"div\");\n\trow.className = \"graph-container\";\n\tvar h3 = document.createElement(\"h3\");\n\th3.appendChild(document.createTextNode(title));\n\trow.appendChild(h3);\n\n\tvar milestoneGraph = document.createElement(\"div\");\n\tmilestoneGraph.className = \"graph milestone-graph\";\n\tvar milestoneTitle = document.createElement(\"h4\");\n\tmilestoneTitle.appendChild(document.createTextNode(\"Milestones\"));\n\tmilestoneGraph.appendChild(milestoneTitle);\n\tvar milestoneCanvasDiv = document.createElement(\"div\");\n\tmilestoneCanvasDiv.className = \"graph-canvas-container\";\n\tvar milestoneCanvas = document.createElement(\"canvas\");\n\tmilestoneCanvas.width = 800;\n\tmilestoneCanvas.height = 400;\n\tmilestoneCanvasDiv.appendChild(milestoneCanvas);\n\tmilestoneGraph.appendChild(milestoneCanvasDiv);\n\trow.appendChild(milestoneGraph);\n\n\tvar competencyGraph = document.createElement(\"div\");\n\tcompetencyGraph.className = \"graph competency-graph\";\n\tvar competencyTitle = document.createElement(\"h4\");\n\tcompetencyTitle.appendChild(document.createTextNode(\"Competencies\"));\n\tcompetencyGraph.appendChild(competencyTitle);\n\tvar competencyCanvasDiv = document.createElement(\"div\");\n\tcompetencyCanvasDiv.className = \"graph-canvas-container\";\n\tvar competencyCanvas = document.createElement(\"canvas\");\n\tcompetencyCanvas.width = 800;\n\tcompetencyCanvas.height = 400;\n\tcompetencyCanvasDiv.appendChild(competencyCanvas);\n\tcompetencyGraph.appendChild(competencyCanvasDiv);\n\trow.appendChild(competencyGraph);\n\n\tdiv.appendChild(row);\n\n\tvar graphType = $(\"#graph-type\").val();\n\tvar vertical = $(\"#graph-layout\").bootstrapSwitch(\"state\");\n\tif(!vertical){\n\t\tmilestoneGraph.className += \" col-sm-6\";\n\t\tcompetencyGraph.className += \" col-sm-6\";\n\t}\n\n\tvar mCtx = milestoneCanvas.getContext(\"2d\");\n\tvar cCtx = competencyCanvas.getContext(\"2d\");\n\n\tif(graphType == \"radar\"){\n\t\tvar mGraph = new Chart1(mCtx).Radar(milestoneData, options);\n\t\tvar cGraph = new Chart1(cCtx).Radar(competencyData, options);\n\t}\n\telse if(graphType == \"bar\"){\n\t\tvar mGraph = new Chart1(mCtx).Bar(milestoneData, options);\n\t\tvar cGraph = new Chart1(cCtx).Bar(competencyData, options);\n\t}\n\telse if(graphType == \"line\"){\n\t\tvar mGraph = new Chart1(mCtx).Line(milestoneData, options);\n\t\tvar cGraph = new Chart1(cCtx).Line(competencyData, options);\n\t}\n\n\tvar legend = mGraph.generateLegend();\n\t$(row).append(legend);\n}\n\n$(\"#graph-type\").change(function(){\n\t$(\".graphs\").html(\"\");\n\tChart.helpers.each(Chart.instances,function(instance){\n\t\tinstance.destroy();\n\t});\n\tdrawAllRadarGraphs();\n});\n\n$(\"#new-graphs\").on(\"switchChange.bootstrapSwitch\", function(){\n\t$(\".graph-type-container\").toggle();\n\t$(\".graph-layout-container\").toggle();\n\t$(\".img-graphs\").toggle();\n\t$(\".graphs\").toggle();\n});\n\n$(\"#graph-layout\").on(\"switchChange.bootstrapSwitch\", function(){\n\t$(\".graph\").toggleClass(\"col-sm-6\");\n\tChart.helpers.each(Chart.instances,function(instance){\n\t\tinstance.resize(instance.render, true);\n\t});\n});\n\nfunction drawAverageRadarGraphs(){\n\treportData.forEach(function(report, index){\n\n\t\tprepareReport(report);\n\n\t\tvar milestoneData = {\n\t\t\tlabels: report.milestoneLabels,\n\t\t\tdatasets: [\n\t\t\t\treport.averageMilestoneDataset\n\t\t\t]\n\t\t};\n\n\t\tvar competencyData = {\n\t\t\tlabels: report.competencyLabels,\n\t\t\tdatasets: [\n\t\t\t\treport.averageCompetencyDataset\n\t\t\t]\n\t\t}\n\n\t\tdrawRadarGraphs(milestoneData, competencyData, \"Average\");\n\t});\n}\n\nfunction drawAllRadarGraphs(){\n\treportData.forEach(function(report, index){\n\n\t\tprepareReport(report);\n\n\t\treport.subjectIds.forEach(function(subjectId){\n\t\t\tvar milestoneData = {\n\t\t\t\tlabels: report.milestoneLabels,\n\t\t\t\tdatasets: [\n\t\t\t\t\treport.averageMilestoneDataset,\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"Individual Performance\",\n\t\t\t\t\t\tfillColor: individualFillColor,\n\t\t\t\t\t\tstrokeColor: individualSolidColor,\n\t\t\t\t\t\tpointColor: individualSolidColor,\n\t\t\t\t\t\tpointStrokeColor: \"#fff\",\n\t\t\t\t\t\tpointHighlightFill: \"#fff\",\n\t\t\t\t\t\tpointHighlightStroke: individualSolidColor,\n\t\t\t\t\t\tdata: _.values(report.subjectMilestone[subjectId])\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\n\t\t\tvar competencyData = {\n\t\t\t\tlabels: report.competencyLabels,\n\t\t\t\tdatasets: [\n\t\t\t\t\treport.averageCompetencyDataset,\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"Individual Performance\",\n\t\t\t\t\t\tfillColor: individualFillColor,\n\t\t\t\t\t\tstrokeColor: individualSolidColor,\n\t\t\t\t\t\tpointColor: individualSolidColor,\n\t\t\t\t\t\tpointStrokeColor: \"#fff\",\n\t\t\t\t\t\tpointHighlightFill: \"#fff\",\n\t\t\t\t\t\tpointHighlightStroke: individualSolidColor,\n\t\t\t\t\t\tdata: _.values(report.subjectCompetency[subjectId])\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\n\t\t\tdrawRadarGraphs(milestoneData, competencyData, report.subjects[subjectId], index);\n\t\t});\n\t});\n}\n\nfunction prepareReport(report){\n\t// Sort subject ids by subject name\n\treport.subjectIds = _.keys(report.subjects).sort(function(a, b){return report.subjects[a].localeCompare(report.subjects[b]);})\n\n\tif(report.trainingLevel == \"fellow\")\n\t\treport.scaleLabels = [\"\", \"Fellow Level 1\", \"Fellow Level 2\", \"Fellow Level 3\", \"Fellow Level 4\", \"Fellow Level 5\"];\n\telse\n\t\treport.scaleLabels = [\"\", \"CBY\", \"CA-1\", \"CA-2\", \"CA-3\", \"Attending\"];\n\n\toptions.scaleLabel = function(values){\n\t\treturn report.scaleLabels[values.value/2];\n\t};\n\n\treport.milestoneLabels = _.values(report.milestones);\n\treport.averageMilestones = _.values(report.averageMilestone);\n\treport.competencyLabels = _.values(report.competencies);\n\treport.averageCompetencies = _.values(report.averageCompetency);\n\n\tfor(var i = 0; i < report.milestoneLabels.length; i++){\n\t\treport.milestoneLabels[i] = report.milestoneLabels[i].replace(\"Anes Fellow \", \"\");\n\t\treport.milestoneLabels[i] = report.milestoneLabels[i].replace(\"and\", \"&\");\n\t}\n\n\treport.averageMilestoneDataset = {\n\t\tlabel: \"Average Performance\",\n\t\tfillColor: averageFillColor,\n\t\tstrokeColor: averageSolidColor,\n\t\tpointColor: averageSolidColor,\n\t\tpointStrokeColor: \"#fff\",\n\t\tpointHighlightFill: \"#fff\",\n\t\tpointHighlightStroke: averageSolidColor,\n\t\tdata: report.averageMilestones\n\t};\n\n\treport.averageCompetencyDataset = {\n\t\tlabel: \"Average Performance\",\n\t\tfillColor: averageFillColor,\n\t\tstrokeColor: averageSolidColor,\n\t\tpointColor: averageSolidColor,\n\t\tpointStrokeColor: \"#fff\",\n\t\tpointHighlightFill: \"#fff\",\n\t\tpointHighlightStroke: averageSolidColor,\n\t\tdata: report.averageCompetencies\n\t};\n}\n","var evalHistoryChart = [];\n\nvar solidColors = {\n\tRequested: \"rgba(227,227,0,1)\",\n\tCompleted: \"rgba(227,0,0,1)\"\n};\n\nvar fillColors = {\n\tRequested: \"rgba(227,227,0,0.3)\",\n\tCompleted: \"rgba(227,0,0,0.3)\"\n};\n\nvar options = {\n\tresponsive: true,\n\ttooltipTemplate: \"<%if (label){%><%=label%>: <%}%><%= value %>\",\n\tlegendTemplate: \"<ul class=\\\"legend <%=name.toLowerCase()%>-legend\\\">\" +\n\t\t\"<% for (var i=0; i<datasets.length; i++){%>\" +\n\t\t\t\"<li><span class=\\\"glyphicon glyphicon-stop\\\" style=\\\"color:<%=datasets[i].strokeColor%>\\\"></span> \" +\n\t\t\t\"<%if(datasets[i].label){%><%=datasets[i].label%>\" +\n\t\t\"<%}%></li><%}%></ul>\",\n};\n\nfunction drawLineChart(canvas, chartData, chartLabels){\n\tif(evalHistoryChart[canvas] != undefined)\n\t\tevalHistoryChart[canvas].destroy();\n\n\tvar ctx = $(canvas).get(0).getContext(\"2d\");\n\n\tvar datasets = [];\n\tfor(var i in chartData){\n\t\tdatasets.push({\n\t\t\tlabel: i,\n\t\t\tfillColor: fillColors[i],\n\t\t\tstrokeColor: solidColors[i],\n\t\t\tpointColor: solidColors[i],\n\t\t\tpointStrokeColor: \"#fff\",\n\t\t\tpointHighlightFill: \"#fff\",\n\t\t\tpointHighlightStroke: solidColors[i],\n\t\t\tdata: chartData[i]\n\t\t});\n\t}\n\n\tvar data = {\n\t\tlabels: chartLabels,\n\t\tdatasets: datasets\n\t}\n\tevalHistoryChart[canvas] = new Chart1(ctx).Line(data, options);\n\t$(canvas+\"-legend\").html(evalHistoryChart[canvas].generateLegend());\n}\n\nvar labelFormats = {\n\tyear: \"YYYY\",\n\tmonth: \"MMMM\",\n\tweek: \"[Week of] MMM D\",\n\tday: \"MMM D\"\n};\n\nfunction getChartEvalData(evals, startDate, endDate, increment, incrementNum){\n\tincrement = increment != undefined ? increment : \"month\";\n\tincrementNum = incrementNum != undefined ? incrementNum : 1;\n\tstartDate = startDate != undefined ? startDate : moment().subtract(1, \"year\").startOf(increment);\n\tendDate = endDate != undefined ? endDate : moment();\n\n\tvar labelFormat = \"MMM D\";\n\tif(labelFormats[increment] != undefined)\n\t\tlabelFormat = labelFormats[increment];\n\tvar labels = [];\n\tvar chartData = {\n\t\tRequested: [],\n\t\tCompleted: []\n\t};\n\n\tfor(var start = startDate; start < endDate; start.add(incrementNum, increment)){\n\t\tvar end = moment(start).add(incrementNum, increment);\n\t\tvar r = evals.reduce(function(num, e){\n\t\t\tif(e.request_date != undefined){\n\t\t\t\tvar rd = moment(e.request_date);\n\t\t\t\tif(rd >= start && rd < end)\n\t\t\t\t\treturn num + 1;\n\t\t\t}\n\t\t\treturn num;\n\t\t}, 0);\n\n\t\tvar c = evals.reduce(function(num, e){\n\t\t\tif(e.complete_date != undefined && e.status == \"complete\"){\n\t\t\t\tvar cd = moment(e.complete_date);\n\t\t\t\tif(cd >= start && cd < end)\n\t\t\t\t\treturn num + 1;\n\t\t\t}\n\t\t\treturn num;\n\t\t}, 0);\n\n\t\tlabels.push(start.format(labelFormat));\n\t\tchartData[\"Requested\"].push(r);\n\t\tchartData[\"Completed\"].push(c);\n\t}\n\n\treturn [chartData, labels];\n}\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"moment\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"moment\")) : factory(root[\"moment\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_32__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _caseLogDetailsSchema = __webpack_require__(1);\n\t\n\tObject.keys(_caseLogDetailsSchema).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _caseLogDetailsSchema[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _datatableUtils = __webpack_require__(57);\n\t\n\tObject.keys(_datatableUtils).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _datatableUtils[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _utils = __webpack_require__(59);\n\t\n\tObject.keys(_utils).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _utils[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.caseLogDetailsSchemaIsValid = caseLogDetailsSchemaIsValid;\n\texports.renderCaseLogDetailsSchema = renderCaseLogDetailsSchema;\n\texports.generateCaseLogDetailsReport = generateCaseLogDetailsReport;\n\texports.generateCaseLogDetailsReportCharts = generateCaseLogDetailsReportCharts;\n\texports.generateCaseLogLocationReportTable = generateCaseLogLocationReportTable;\n\t\n\tvar _chart = __webpack_require__(2);\n\t\n\tvar _chart2 = _interopRequireDefault(_chart);\n\t\n\tvar _jsonschema = __webpack_require__(46);\n\t\n\tvar _caseLogDetails = __webpack_require__(56);\n\t\n\tvar _caseLogDetails2 = _interopRequireDefault(_caseLogDetails);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar v = new _jsonschema.Validator();\n\tfunction caseLogDetailsSchemaIsValid(detailsSchema) {\n\t\treturn v.validate(detailsSchema, _caseLogDetails2.default).valid;\n\t}\n\t\n\tfunction renderCaseLogDetailsSchema(schema, responses) {\n\t\tvar container = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document.createElement('section');\n\t\n\t\tschema.forEach(function (section) {\n\t\t\tvar panel = document.createElement('section');\n\t\t\tvar panelBody = document.createElement('div');\n\t\n\t\t\tpanel.className = 'panel panel-default';\n\t\n\t\t\tif (section.title) {\n\t\t\t\tvar panelHeading = document.createElement('div');\n\t\t\t\tvar panelTitle = document.createElement('h4');\n\t\n\t\t\t\tpanelHeading.className = 'panel-heading';\n\t\t\t\tpanelTitle.className = 'panel-title';\n\t\t\t\tpanelTitle.appendChild(document.createTextNode(section.title));\n\t\t\t\tpanelHeading.appendChild(panelTitle);\n\t\t\t\tpanel.appendChild(panelHeading);\n\t\t\t}\n\t\n\t\t\tpanelBody.className = 'panel-body';\n\t\t\tpanel.appendChild(panelBody);\n\t\n\t\t\tsection.subsections.forEach(function (subsection) {\n\t\t\t\tvar subsectionContainer = document.createElement('section');\n\t\t\t\tvar row = document.createElement('div');\n\t\t\t\trow.className = 'row';\n\t\t\t\tif (subsection.title) {\n\t\t\t\t\tvar subsectionHeading = document.createElement('h5');\n\t\t\t\t\tsubsectionHeading.className = 'sub-header';\n\t\t\t\t\tsubsectionHeading.appendChild(document.createTextNode(subsection.title));\n\t\t\t\t\tsubsectionContainer.appendChild(subsectionHeading);\n\t\t\t\t}\n\t\n\t\t\t\tsubsection.inputs.forEach(function (input) {\n\t\t\t\t\trenderInput(input, subsection.name, row);\n\t\t\t\t});\n\t\n\t\t\t\tsubsectionContainer.appendChild(row);\n\t\t\t\tpanelBody.appendChild(subsectionContainer);\n\t\t\t});\n\t\n\t\t\tcontainer.appendChild(panel);\n\t\t});\n\t\n\t\treturn container;\n\t\n\t\tfunction renderInput(input, name, container) {\n\t\t\tswitch (input.type) {\n\t\t\t\tcase 'checkbox':\n\t\t\t\t\t{\n\t\t\t\t\t\tvar checkboxContainer = document.createElement('div');\n\t\t\t\t\t\tvar label = document.createElement('label');\n\t\t\t\t\t\tvar checkbox = document.createElement('input');\n\t\n\t\t\t\t\t\tcheckboxContainer.className = 'col-md-4 checkbox';\n\t\t\t\t\t\tcheckbox.type = 'checkbox';\n\t\t\t\t\t\tcheckbox.name = 'details[' + name + '][]';\n\t\t\t\t\t\tcheckbox.value = input.value || input.label;\n\t\t\t\t\t\tif (responses && responses[name] && responses[name].indexOf(checkbox.value) !== -1) checkbox.checked = true;\n\t\t\t\t\t\tif (responses) checkbox.readonly = true;\n\t\t\t\t\t\tlabel.appendChild(checkbox);\n\t\t\t\t\t\tlabel.appendChild(document.createTextNode(input.label));\n\t\t\t\t\t\tcheckboxContainer.appendChild(label);\n\t\n\t\t\t\t\t\tcontainer.appendChild(checkboxContainer);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction generateCaseLogDetailsReport(caseLogs) {\n\t\tif (!caseLogs || caseLogs.length === 0) return;\n\t\n\t\tvar report = {};\n\t\tcaseLogs.forEach(function (caseLog) {\n\t\t\tif (!report.hasOwnProperty(caseLog.details_schema.details_type)) report[caseLog.details_schema.details_type] = {\n\t\t\t\tnumCases: 0,\n\t\t\t\ttypes: {}\n\t\t\t};\n\t\t\tvar detailsReport = report[caseLog.details_schema.details_type];\n\t\t\tdetailsReport.numCases++;\n\t\n\t\t\tvar _loop = function _loop(typeName) {\n\t\t\t\tif (!detailsReport.types.hasOwnProperty(typeName)) detailsReport.types[typeName] = {\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tresponses: {},\n\t\t\t\t\tlocations: {}\n\t\t\t\t};\n\t\n\t\t\t\tdetailsReport.types[typeName].count++;\n\t\t\t\tcaseLog.details[typeName].forEach(function (response) {\n\t\t\t\t\tif (!detailsReport.types[typeName].responses.hasOwnProperty(response)) detailsReport.types[typeName].responses[response] = {\n\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\tlocations: {}\n\t\t\t\t\t};\n\t\t\t\t\tdetailsReport.types[typeName].responses[response].count++;\n\t\n\t\t\t\t\tif (!detailsReport.types[typeName].responses[response].locations.hasOwnProperty(caseLog.location.name)) detailsReport.types[typeName].responses[response].locations[caseLog.location.name] = {\n\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\tcaseLogs: []\n\t\t\t\t\t};\n\t\t\t\t\tdetailsReport.types[typeName].responses[response].locations[caseLog.location.name].count++;\n\t\t\t\t\tdetailsReport.types[typeName].responses[response].locations[caseLog.location.name].caseLogs.push(caseLog);\n\t\n\t\t\t\t\tif (!detailsReport.types[typeName].locations.hasOwnProperty(caseLog.location.name)) detailsReport.types[typeName].locations[caseLog.location.name] = {\n\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\tcaseLogs: []\n\t\t\t\t\t};\n\t\t\t\t\tdetailsReport.types[typeName].locations[caseLog.location.name].count++;\n\t\t\t\t\tdetailsReport.types[typeName].locations[caseLog.location.name].caseLogs.push(caseLog);\n\t\t\t\t});\n\t\t\t};\n\t\n\t\t\tfor (var typeName in caseLog.details) {\n\t\t\t\t_loop(typeName);\n\t\t\t}\n\t\t});\n\t\treturn report;\n\t}\n\t\n\tvar chartColors = ['#FF6384', '#4BC0C0', '#FFCE56', '#E7E9ED', '#36A2EB', '#7eda35', '#462aa3', '#dd2727', '#f09113', '#1a7829'];\n\t\n\tfunction generateCaseLogDetailsReportCharts(report, name, container) {\n\t\tvar charts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t\tif (!report || report.length === 0) return;\n\t\n\t\tvar reportGroupNames = Object.keys(report);\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\t\n\t\ttry {\n\t\t\tfor (var _iterator = container.querySelectorAll('row')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar section = _step.value;\n\t\n\t\t\t\tif (!section.hasAttribute('data-report-group-name') || !(reportGroupNames.indexOf(section.getAttribute('data-report-group-name')) !== -1)) container.removeChild(section);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfor (var chartName in charts) {\n\t\t\tif (!(reportGroupNames.indexOf(chartName) !== -1)) {\n\t\t\t\tcharts[chartName].destroy();\n\t\t\t\tdelete charts[chartName];\n\t\t\t}\n\t\t}\n\t\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\t\n\t\ttry {\n\t\t\tfor (var _iterator2 = reportGroupNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar reportGroupName = _step2.value;\n\t\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tdatasets: [{\n\t\t\t\t\t\tlabel: name,\n\t\t\t\t\t\tdata: [],\n\t\t\t\t\t\tbackgroundColor: []\n\t\t\t\t\t}],\n\t\t\t\t\tlabels: []\n\t\t\t\t};\n\t\n\t\t\t\tvar canvas = void 0,\n\t\t\t\t    numCasesTd = void 0,\n\t\t\t\t    tbody = void 0;\n\t\t\t\tvar reportGroupSection = container.querySelector('section[data-report-group-name=\"' + reportGroupName + '\"]');\n\t\t\t\tif (reportGroupSection) {\n\t\t\t\t\tnumCasesTd = reportGroupSection.querySelector('table.num-cases-table td');\n\t\t\t\t\ttbody = reportGroupSection.querySelector('table.stats-table tbody');\n\t\t\t\t} else {\n\t\t\t\t\treportGroupSection = document.createElement('section');\n\t\t\t\t\tvar reportGroupTitle = document.createElement('h2');\n\t\t\t\t\tvar canvasContainer = document.createElement('div');\n\t\t\t\t\tcanvas = document.createElement('canvas');\n\t\t\t\t\treportGroupSection.className = 'row';\n\t\t\t\t\treportGroupSection.setAttribute('data-report-group-name', reportGroupName);\n\t\t\t\t\treportGroupSection.appendChild(reportGroupTitle);\n\t\t\t\t\treportGroupTitle.appendChild(document.createTextNode(reportGroupName.toUpperCase()));\n\t\t\t\t\tcanvasContainer.className = 'col-md-8 case-log-report-chart-container';\n\t\t\t\t\tcontainer.appendChild(reportGroupSection);\n\t\t\t\t\treportGroupSection.appendChild(canvasContainer);\n\t\t\t\t\tcanvasContainer.appendChild(canvas);\n\t\n\t\t\t\t\tvar statsContainer = document.createElement('div');\n\t\t\t\t\tvar numTable = document.createElement('table');\n\t\t\t\t\tvar statsTable = document.createElement('table');\n\t\t\t\t\tvar thead = document.createElement('thead');\n\t\t\t\t\ttbody = document.createElement('tbody');\n\t\t\t\t\tvar tr = document.createElement('tr');\n\t\t\t\t\tvar th = document.createElement('th');\n\t\t\t\t\tnumCasesTd = document.createElement('td');\n\t\t\t\t\tstatsContainer.className = 'col-md-4 case-log-report-stats-container';\n\t\t\t\t\treportGroupSection.appendChild(statsContainer);\n\t\t\t\t\tnumTable.className = 'table num-cases-table';\n\t\t\t\t\tstatsContainer.appendChild(numTable);\n\t\t\t\t\tnumTable.appendChild(tr);\n\t\t\t\t\ttr.appendChild(th);\n\t\t\t\t\tth.appendChild(document.createTextNode('Number of cases'));\n\t\t\t\t\ttr.appendChild(numCasesTd);\n\t\n\t\t\t\t\ttr = document.createElement('tr');\n\t\t\t\t\tth = document.createElement('th');\n\t\t\t\t\tstatsTable.className = 'table table-striped table-bordered stats-table';\n\t\t\t\t\tstatsContainer.appendChild(statsTable);\n\t\t\t\t\tstatsTable.appendChild(thead);\n\t\t\t\t\tthead.appendChild(tr);\n\t\t\t\t\ttr.appendChild(th);\n\t\t\t\t\tstatsTable.appendChild(tbody);\n\t\t\t\t\tth.appendChild(document.createTextNode('Response'));\n\t\t\t\t\ttr.appendChild(th);\n\t\t\t\t\tth = document.createElement('th');\n\t\t\t\t\tth.appendChild(document.createTextNode('Times selected'));\n\t\t\t\t\ttr.appendChild(th);\n\t\t\t\t\tth = document.createElement('th');\n\t\t\t\t\tth.appendChild(document.createTextNode('Percentage'));\n\t\t\t\t\ttr.appendChild(th);\n\t\t\t\t}\n\t\n\t\t\t\twhile (tbody.firstChild) {\n\t\t\t\t\ttbody.removeChild(tbody.firstChild);\n\t\t\t\t}var numCases = report[reportGroupName].numCases;\n\t\t\t\twhile (numCasesTd.firstChild) {\n\t\t\t\t\tnumCasesTd.removeChild(numCasesTd.firstChild);\n\t\t\t\t}numCasesTd.appendChild(document.createTextNode(numCases));\n\t\t\t\tif (report[reportGroupName].types[name]) {\n\t\t\t\t\tvar responses = Object.keys(report[reportGroupName].types[name].responses).sort();\n\t\t\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\t\t\tvar _didIteratorError3 = false;\n\t\t\t\t\tvar _iteratorError3 = undefined;\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var _iterator3 = responses[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\t\t\tvar response = _step3.value;\n\t\n\t\t\t\t\t\t\tvar count = report[reportGroupName].types[name].responses[response].count;\n\t\t\t\t\t\t\tvar percentage = Math.round(count / numCases * 100);\n\t\t\t\t\t\t\tdata.datasets[0].data.push(count);\n\t\t\t\t\t\t\tdata.datasets[0].backgroundColor.push(chartColors[data.datasets[0].data.length - 1]);\n\t\t\t\t\t\t\tdata.labels.push(response);\n\t\n\t\t\t\t\t\t\tvar _tr = document.createElement('tr');\n\t\t\t\t\t\t\tvar _th = document.createElement('th');\n\t\t\t\t\t\t\tvar selectedTd = document.createElement('td');\n\t\t\t\t\t\t\tvar percentageTd = document.createElement('td');\n\t\n\t\t\t\t\t\t\t_th.appendChild(document.createTextNode(response));\n\t\t\t\t\t\t\tselectedTd.appendChild(document.createTextNode(count));\n\t\t\t\t\t\t\tpercentageTd.appendChild(document.createTextNode(percentage + '%'));\n\t\n\t\t\t\t\t\t\t_tr.appendChild(_th);\n\t\t\t\t\t\t\t_tr.appendChild(selectedTd);\n\t\t\t\t\t\t\t_tr.appendChild(percentageTd);\n\t\t\t\t\t\t\ttbody.appendChild(_tr);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t\t\t_iteratorError3 = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (charts[reportGroupName]) {\n\t\t\t\t\tcharts[reportGroupName].data.datasets = data.datasets;\n\t\t\t\t\tcharts[reportGroupName].data.labels = data.labels;\n\t\t\t\t\tcharts[reportGroupName].update();\n\t\t\t\t} else {\n\t\t\t\t\tcharts[reportGroupName] = new _chart2.default(canvas, {\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\ttype: 'polarArea',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tscale: {\n\t\t\t\t\t\t\t\tticks: {\n\t\t\t\t\t\t\t\t\tstepSize: 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn charts;\n\t}\n\t\n\tfunction generateCaseLogLocationReportTable(report, name, container) {\n\t\tif (!report || report.length === 0) return;\n\t\n\t\tvar reportGroupNames = Object.keys(report);\n\t\tvar _iteratorNormalCompletion4 = true;\n\t\tvar _didIteratorError4 = false;\n\t\tvar _iteratorError4 = undefined;\n\t\n\t\ttry {\n\t\t\tfor (var _iterator4 = reportGroupNames[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t\t\t\tvar reportGroupName = _step4.value;\n\t\n\t\t\t\tvar reportGroupSection = container.querySelector('section[data-report-group-name=\"' + reportGroupName + '\"]');\n\t\t\t\tvar tbody = reportGroupSection.querySelector('table.location-table tbody');\n\t\t\t\tif (!tbody) {\n\t\t\t\t\tvar statsContainer = reportGroupSection.querySelector('.case-log-report-stats-container');\n\t\t\t\t\tvar locationTable = document.createElement('table');\n\t\t\t\t\tvar thead = document.createElement('thead');\n\t\t\t\t\ttbody = document.createElement('tbody');\n\t\t\t\t\tvar tr = document.createElement('tr');\n\t\t\t\t\tvar th = document.createElement('th');\n\t\t\t\t\tlocationTable.className = 'table table-striped table-bordered location-table';\n\t\t\t\t\tstatsContainer.appendChild(locationTable);\n\t\t\t\t\tlocationTable.appendChild(thead);\n\t\t\t\t\tlocationTable.appendChild(tbody);\n\t\t\t\t\tthead.appendChild(tr);\n\t\t\t\t\ttr.appendChild(th);\n\t\t\t\t\tth.appendChild(document.createTextNode('Location'));\n\t\t\t\t\tth = document.createElement('th');\n\t\t\t\t\ttr.appendChild(th);\n\t\t\t\t\tth.appendChild(document.createTextNode('Times selected'));\n\t\t\t\t\tth = document.createElement('th');\n\t\t\t\t\ttr.appendChild(th);\n\t\t\t\t\tth.appendChild(document.createTextNode('Percentage'));\n\t\t\t\t}\n\t\n\t\t\t\twhile (tbody.firstChild) {\n\t\t\t\t\ttbody.removeChild(tbody.firstChild);\n\t\t\t\t}var numCases = report[reportGroupName].numCases;\n\t\t\t\tif (report[reportGroupName].types[name]) {\n\t\t\t\t\tvar locations = Object.keys(report[reportGroupName].types[name].locations).sort();\n\t\t\t\t\tvar _iteratorNormalCompletion5 = true;\n\t\t\t\t\tvar _didIteratorError5 = false;\n\t\t\t\t\tvar _iteratorError5 = undefined;\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var _iterator5 = locations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t\t\t\t\t\t\tvar location = _step5.value;\n\t\n\t\t\t\t\t\t\tvar count = report[reportGroupName].types[name].locations[location].count;\n\t\t\t\t\t\t\tvar percentage = Math.round(count / numCases * 100);\n\t\n\t\t\t\t\t\t\tvar _tr2 = document.createElement('tr');\n\t\t\t\t\t\t\tvar _th2 = document.createElement('th');\n\t\t\t\t\t\t\tvar selectedTd = document.createElement('td');\n\t\t\t\t\t\t\tvar percentageTd = document.createElement('td');\n\t\n\t\t\t\t\t\t\t_th2.appendChild(document.createTextNode(location));\n\t\t\t\t\t\t\tselectedTd.appendChild(document.createTextNode(count));\n\t\t\t\t\t\t\tpercentageTd.appendChild(document.createTextNode(percentage + '%'));\n\t\n\t\t\t\t\t\t\t_tr2.appendChild(_th2);\n\t\t\t\t\t\t\t_tr2.appendChild(selectedTd);\n\t\t\t\t\t\t\t_tr2.appendChild(percentageTd);\n\t\t\t\t\t\t\ttbody.appendChild(_tr2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_didIteratorError5 = true;\n\t\t\t\t\t\t_iteratorError5 = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t\t\t\t\t\t\t\t_iterator5.return();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_didIteratorError5) {\n\t\t\t\t\t\t\t\tthrow _iteratorError5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError4 = true;\n\t\t\t_iteratorError4 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t\t_iterator4.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError4) {\n\t\t\t\t\tthrow _iteratorError4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @namespace Chart\n\t */\n\tvar Chart = __webpack_require__(3)();\n\t\n\t__webpack_require__(4)(Chart);\n\t__webpack_require__(10)(Chart);\n\t__webpack_require__(11)(Chart);\n\t__webpack_require__(12)(Chart);\n\t__webpack_require__(13)(Chart);\n\t__webpack_require__(14)(Chart);\n\t__webpack_require__(15)(Chart);\n\t__webpack_require__(16)(Chart);\n\t__webpack_require__(17)(Chart);\n\t__webpack_require__(18)(Chart);\n\t__webpack_require__(19)(Chart);\n\t__webpack_require__(20)(Chart);\n\t__webpack_require__(21)(Chart);\n\t\n\t__webpack_require__(22)(Chart);\n\t__webpack_require__(23)(Chart);\n\t__webpack_require__(24)(Chart);\n\t__webpack_require__(25)(Chart);\n\t\n\t__webpack_require__(26)(Chart);\n\t__webpack_require__(27)(Chart);\n\t__webpack_require__(28)(Chart);\n\t__webpack_require__(29)(Chart);\n\t__webpack_require__(30)(Chart);\n\t__webpack_require__(31)(Chart);\n\t\n\t// Controllers must be loaded after elements\n\t// See Chart.core.datasetController.dataElementType\n\t__webpack_require__(33)(Chart);\n\t__webpack_require__(34)(Chart);\n\t__webpack_require__(35)(Chart);\n\t__webpack_require__(36)(Chart);\n\t__webpack_require__(37)(Chart);\n\t__webpack_require__(38)(Chart);\n\t\n\t__webpack_require__(39)(Chart);\n\t__webpack_require__(40)(Chart);\n\t__webpack_require__(41)(Chart);\n\t__webpack_require__(42)(Chart);\n\t__webpack_require__(43)(Chart);\n\t__webpack_require__(44)(Chart);\n\t__webpack_require__(45)(Chart);\n\t\n\twindow.Chart = module.exports = Chart;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function() {\n\t\n\t\t// Occupy the global variable of Chart, and create a simple base class\n\t\tvar Chart = function(context, config) {\n\t\t\tvar me = this;\n\t\t\tvar helpers = Chart.helpers;\n\t\t\tme.config = config || {\n\t\t\t\tdata: {\n\t\t\t\t\tdatasets: []\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t// Support a jQuery'd canvas element\n\t\t\tif (context.length && context[0].getContext) {\n\t\t\t\tcontext = context[0];\n\t\t\t}\n\t\n\t\t\t// Support a canvas domnode\n\t\t\tif (context.getContext) {\n\t\t\t\tcontext = context.getContext('2d');\n\t\t\t}\n\t\n\t\t\tme.ctx = context;\n\t\t\tme.canvas = context.canvas;\n\t\n\t\t\tcontext.canvas.style.display = context.canvas.style.display || 'block';\n\t\n\t\t\t// Figure out what the size of the chart will be.\n\t\t\t// If the canvas has a specified width and height, we use those else\n\t\t\t// we look to see if the canvas node has a CSS width and height.\n\t\t\t// If there is still no height, fill the parent container\n\t\t\tme.width = context.canvas.width || parseInt(helpers.getStyle(context.canvas, 'width'), 10) || helpers.getMaximumWidth(context.canvas);\n\t\t\tme.height = context.canvas.height || parseInt(helpers.getStyle(context.canvas, 'height'), 10) || helpers.getMaximumHeight(context.canvas);\n\t\n\t\t\tme.aspectRatio = me.width / me.height;\n\t\n\t\t\tif (isNaN(me.aspectRatio) || isFinite(me.aspectRatio) === false) {\n\t\t\t\t// If the canvas has no size, try and figure out what the aspect ratio will be.\n\t\t\t\t// Some charts prefer square canvases (pie, radar, etc). If that is specified, use that\n\t\t\t\t// else use the canvas default ratio of 2\n\t\t\t\tme.aspectRatio = config.aspectRatio !== undefined ? config.aspectRatio : 2;\n\t\t\t}\n\t\n\t\t\t// Store the original style of the element so we can set it back\n\t\t\tme.originalCanvasStyleWidth = context.canvas.style.width;\n\t\t\tme.originalCanvasStyleHeight = context.canvas.style.height;\n\t\n\t\t\t// High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.\n\t\t\thelpers.retinaScale(me);\n\t\t\tme.controller = new Chart.Controller(me);\n\t\n\t\t\t// Always bind this so that if the responsive state changes we still work\n\t\t\thelpers.addResizeListener(context.canvas.parentNode, function() {\n\t\t\t\tif (me.controller && me.controller.config.options.responsive) {\n\t\t\t\t\tme.controller.resize();\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\treturn me.controller ? me.controller : me;\n\t\n\t\t};\n\t\n\t\t// Globally expose the defaults to allow for user updating/changing\n\t\tChart.defaults = {\n\t\t\tglobal: {\n\t\t\t\tresponsive: true,\n\t\t\t\tresponsiveAnimationDuration: 0,\n\t\t\t\tmaintainAspectRatio: true,\n\t\t\t\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\t\t\t\thover: {\n\t\t\t\t\tonHover: null,\n\t\t\t\t\tmode: 'single',\n\t\t\t\t\tanimationDuration: 400\n\t\t\t\t},\n\t\t\t\tonClick: null,\n\t\t\t\tdefaultColor: 'rgba(0,0,0,0.1)',\n\t\t\t\tdefaultFontColor: '#666',\n\t\t\t\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\t\t\t\tdefaultFontSize: 12,\n\t\t\t\tdefaultFontStyle: 'normal',\n\t\t\t\tshowLines: true,\n\t\n\t\t\t\t// Element defaults defined in element extensions\n\t\t\t\telements: {},\n\t\n\t\t\t\t// Legend callback string\n\t\t\t\tlegendCallback: function(chart) {\n\t\t\t\t\tvar text = [];\n\t\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\t\t\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\t\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\t\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttext.push('</li>');\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</ul>');\n\t\n\t\t\t\t\treturn text.join('');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tChart.Chart = Chart;\n\t\n\t\treturn Chart;\n\t\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global window: false */\n\t/* global document: false */\n\t'use strict';\n\t\n\tvar color = __webpack_require__(5);\n\t\n\tmodule.exports = function(Chart) {\n\t\t// Global Chart helpers object for utility methods and classes\n\t\tvar helpers = Chart.helpers = {};\n\t\n\t\t// -- Basic js utility methods\n\t\thelpers.each = function(loopable, callback, self, reverse) {\n\t\t\t// Check to see if null or undefined firstly.\n\t\t\tvar i, len;\n\t\t\tif (helpers.isArray(loopable)) {\n\t\t\t\tlen = loopable.length;\n\t\t\t\tif (reverse) {\n\t\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (typeof loopable === 'object') {\n\t\t\t\tvar keys = Object.keys(loopable);\n\t\t\t\tlen = keys.length;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tcallback.call(self, loopable[keys[i]], keys[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\thelpers.clone = function(obj) {\n\t\t\tvar objClone = {};\n\t\t\thelpers.each(obj, function(value, key) {\n\t\t\t\tif (helpers.isArray(value)) {\n\t\t\t\t\tobjClone[key] = value.slice(0);\n\t\t\t\t} else if (typeof value === 'object' && value !== null) {\n\t\t\t\t\tobjClone[key] = helpers.clone(value);\n\t\t\t\t} else {\n\t\t\t\t\tobjClone[key] = value;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn objClone;\n\t\t};\n\t\thelpers.extend = function(base) {\n\t\t\tvar setFn = function(value, key) {\n\t\t\t\tbase[key] = value;\n\t\t\t};\n\t\t\tfor (var i = 1, ilen = arguments.length; i < ilen; i++) {\n\t\t\t\thelpers.each(arguments[i], setFn);\n\t\t\t}\n\t\t\treturn base;\n\t\t};\n\t\t// Need a special merge function to chart configs since they are now grouped\n\t\thelpers.configMerge = function(_base) {\n\t\t\tvar base = helpers.clone(_base);\n\t\t\thelpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\n\t\t\t\thelpers.each(extension, function(value, key) {\n\t\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t\t// Scale config merging is complex. Add out own function here for that\n\t\t\t\t\t\tbase[key] = helpers.scaleMerge(base.hasOwnProperty(key) ? base[key] : {}, value);\n\t\n\t\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t\t// Used in polar area & radar charts since there is only one scale\n\t\t\t\t\t\tbase[key] = helpers.configMerge(base.hasOwnProperty(key) ? base[key] : {}, Chart.scaleService.getScaleDefaults(value.type), value);\n\t\t\t\t\t} else if (base.hasOwnProperty(key) && helpers.isArray(base[key]) && helpers.isArray(value)) {\n\t\t\t\t\t\t// In this case we have an array of objects replacing another array. Rather than doing a strict replace,\n\t\t\t\t\t\t// merge. This allows easy scale option merging\n\t\t\t\t\t\tvar baseArray = base[key];\n\t\n\t\t\t\t\t\thelpers.each(value, function(valueObj, index) {\n\t\n\t\t\t\t\t\t\tif (index < baseArray.length) {\n\t\t\t\t\t\t\t\tif (typeof baseArray[index] === 'object' && baseArray[index] !== null && typeof valueObj === 'object' && valueObj !== null) {\n\t\t\t\t\t\t\t\t\t// Two objects are coming together. Do a merge of them.\n\t\t\t\t\t\t\t\t\tbaseArray[index] = helpers.configMerge(baseArray[index], valueObj);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Just overwrite in this case since there is nothing to merge\n\t\t\t\t\t\t\t\t\tbaseArray[index] = valueObj;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbaseArray.push(valueObj); // nothing to merge\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\n\t\t\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\t\t\tbase[key] = helpers.configMerge(base[key], value);\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// can just overwrite the value in this case\n\t\t\t\t\t\tbase[key] = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\n\t\t\treturn base;\n\t\t};\n\t\thelpers.scaleMerge = function(_base, extension) {\n\t\t\tvar base = helpers.clone(_base);\n\t\n\t\t\thelpers.each(extension, function(value, key) {\n\t\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t\t// These properties are arrays of items\n\t\t\t\t\tif (base.hasOwnProperty(key)) {\n\t\t\t\t\t\thelpers.each(value, function(valueObj, index) {\n\t\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\t\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\n\t\t\t\t\t\t\tif (index >= base[key].length || !base[key][index].type) {\n\t\t\t\t\t\t\t\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));\n\t\t\t\t\t\t\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {\n\t\t\t\t\t\t\t\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\n\t\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Type is the same\n\t\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase[key] = [];\n\t\t\t\t\t\thelpers.each(value, function(valueObj) {\n\t\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\t\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\n\t\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\t\tbase[key] = helpers.configMerge(base[key], value);\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// can just overwrite the value in this case\n\t\t\t\t\tbase[key] = value;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\treturn base;\n\t\t};\n\t\thelpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn defaultValue;\n\t\t\t}\n\t\n\t\t\tif (helpers.isArray(value)) {\n\t\t\t\treturn index < value.length ? value[index] : defaultValue;\n\t\t\t}\n\t\n\t\t\treturn value;\n\t\t};\n\t\thelpers.getValueOrDefault = function(value, defaultValue) {\n\t\t\treturn value === undefined ? defaultValue : value;\n\t\t};\n\t\thelpers.indexOf = Array.prototype.indexOf?\n\t\t\tfunction(array, item) {\n\t\t\t\treturn array.indexOf(item);\n\t\t\t}:\n\t\t\tfunction(array, item) {\n\t\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\t\tif (array[i] === item) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t};\n\t\thelpers.where = function(collection, filterCallback) {\n\t\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\t\treturn collection.filter(filterCallback);\n\t\t\t}\n\t\t\tvar filtered = [];\n\t\n\t\t\thelpers.each(collection, function(item) {\n\t\t\t\tif (filterCallback(item)) {\n\t\t\t\t\tfiltered.push(item);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\treturn filtered;\n\t\t};\n\t\thelpers.findIndex = Array.prototype.findIndex?\n\t\t\tfunction(array, callback, scope) {\n\t\t\t\treturn array.findIndex(callback, scope);\n\t\t\t} :\n\t\t\tfunction(array, callback, scope) {\n\t\t\t\tscope = scope === undefined? array : scope;\n\t\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t};\n\t\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t\t// Default to start of the array\n\t\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\t\tstartIndex = -1;\n\t\t\t}\n\t\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\t\treturn currentItem;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t\t// Default to end of the array\n\t\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\t\tstartIndex = arrayToSearch.length;\n\t\t\t}\n\t\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\t\treturn currentItem;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\thelpers.inherits = function(extensions) {\n\t\t\t// Basic javascript inheritance based on the model created in Backbone.js\n\t\t\tvar me = this;\n\t\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\t\treturn me.apply(this, arguments);\n\t\t\t};\n\t\n\t\t\tvar Surrogate = function() {\n\t\t\t\tthis.constructor = ChartElement;\n\t\t\t};\n\t\t\tSurrogate.prototype = me.prototype;\n\t\t\tChartElement.prototype = new Surrogate();\n\t\n\t\t\tChartElement.extend = helpers.inherits;\n\t\n\t\t\tif (extensions) {\n\t\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t\t}\n\t\n\t\t\tChartElement.__super__ = me.prototype;\n\t\n\t\t\treturn ChartElement;\n\t\t};\n\t\thelpers.noop = function() {};\n\t\thelpers.uid = (function() {\n\t\t\tvar id = 0;\n\t\t\treturn function() {\n\t\t\t\treturn id++;\n\t\t\t};\n\t\t}());\n\t\t// -- Math methods\n\t\thelpers.isNumber = function(n) {\n\t\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t\t};\n\t\thelpers.almostEquals = function(x, y, epsilon) {\n\t\t\treturn Math.abs(x - y) < epsilon;\n\t\t};\n\t\thelpers.max = function(array) {\n\t\t\treturn array.reduce(function(max, value) {\n\t\t\t\tif (!isNaN(value)) {\n\t\t\t\t\treturn Math.max(max, value);\n\t\t\t\t}\n\t\t\t\treturn max;\n\t\t\t}, Number.NEGATIVE_INFINITY);\n\t\t};\n\t\thelpers.min = function(array) {\n\t\t\treturn array.reduce(function(min, value) {\n\t\t\t\tif (!isNaN(value)) {\n\t\t\t\t\treturn Math.min(min, value);\n\t\t\t\t}\n\t\t\t\treturn min;\n\t\t\t}, Number.POSITIVE_INFINITY);\n\t\t};\n\t\thelpers.sign = Math.sign?\n\t\t\tfunction(x) {\n\t\t\t\treturn Math.sign(x);\n\t\t\t} :\n\t\t\tfunction(x) {\n\t\t\t\tx = +x; // convert to a number\n\t\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\treturn x > 0 ? 1 : -1;\n\t\t\t};\n\t\thelpers.log10 = Math.log10?\n\t\t\tfunction(x) {\n\t\t\t\treturn Math.log10(x);\n\t\t\t} :\n\t\t\tfunction(x) {\n\t\t\t\treturn Math.log(x) / Math.LN10;\n\t\t\t};\n\t\thelpers.toRadians = function(degrees) {\n\t\t\treturn degrees * (Math.PI / 180);\n\t\t};\n\t\thelpers.toDegrees = function(radians) {\n\t\t\treturn radians * (180 / Math.PI);\n\t\t};\n\t\t// Gets the angle from vertical upright to the point about a centre.\n\t\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,\n\t\t\t\tdistanceFromYCenter = anglePoint.y - centrePoint.y,\n\t\t\t\tradialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\t\n\t\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\t\n\t\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tangle: angle,\n\t\t\t\tdistance: radialDistanceFromCenter\n\t\t\t};\n\t\t};\n\t\thelpers.aliasPixel = function(pixelWidth) {\n\t\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t\t};\n\t\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\t\n\t\t\t// This function must also respect \"skipped\" points\n\t\n\t\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint,\n\t\t\t\tcurrent = middlePoint,\n\t\t\t\tnext = afterPoint.skip ? middlePoint : afterPoint;\n\t\n\t\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\t\n\t\t\tvar s01 = d01 / (d01 + d12);\n\t\t\tvar s12 = d12 / (d01 + d12);\n\t\n\t\t\t// If all points are the same, s01 & s02 will be inf\n\t\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\t\ts12 = isNaN(s12) ? 0 : s12;\n\t\n\t\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\t\tvar fb = t * s12;\n\t\n\t\t\treturn {\n\t\t\t\tprevious: {\n\t\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t\t},\n\t\t\t\tnext: {\n\t\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\t\thelpers.splineCurveMonotone = function(points) {\n\t\t\t// This function calculates Bézier control points in a similar way than |splineCurve|,\n\t\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t\t// between the dataset discrete points due to the interpolation.\n\t\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\t\n\t\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\t\treturn {\n\t\t\t\t\tmodel: point._model,\n\t\t\t\t\tdeltaK: 0,\n\t\t\t\t\tmK: 0\n\t\t\t\t};\n\t\t\t});\n\t\n\t\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\t\tvar pointsLen = pointsWithTangents.length;\n\t\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\t\tpointCurrent.deltaK = (pointAfter.model.y - pointCurrent.model.y) / (pointAfter.model.x - pointCurrent.model.x);\n\t\t\t\t}\n\t\n\t\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\t\tpointCurrent.mK = 0;\n\t\t\t\t} else {\n\t\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Adjust tangents to ensure monotonic properties\n\t\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t\t}\n\t\n\t\t\t// Compute control points\n\t\t\tvar deltaX;\n\t\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t\t}\n\t\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\thelpers.nextItem = function(collection, index, loop) {\n\t\t\tif (loop) {\n\t\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t\t}\n\t\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t\t};\n\t\thelpers.previousItem = function(collection, index, loop) {\n\t\t\tif (loop) {\n\t\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t\t}\n\t\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t\t};\n\t\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\t\thelpers.niceNum = function(range, round) {\n\t\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\t\tvar fraction = range / Math.pow(10, exponent);\n\t\t\tvar niceFraction;\n\t\n\t\t\tif (round) {\n\t\t\t\tif (fraction < 1.5) {\n\t\t\t\t\tniceFraction = 1;\n\t\t\t\t} else if (fraction < 3) {\n\t\t\t\t\tniceFraction = 2;\n\t\t\t\t} else if (fraction < 7) {\n\t\t\t\t\tniceFraction = 5;\n\t\t\t\t} else {\n\t\t\t\t\tniceFraction = 10;\n\t\t\t\t}\n\t\t\t} else if (fraction <= 1.0) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction <= 2) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction <= 5) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\n\t\t\treturn niceFraction * Math.pow(10, exponent);\n\t\t};\n\t\t// Easing functions adapted from Robert Penner's easing equations\n\t\t// http://www.robertpenner.com/easing/\n\t\tvar easingEffects = helpers.easingEffects = {\n\t\t\tlinear: function(t) {\n\t\t\t\treturn t;\n\t\t\t},\n\t\t\teaseInQuad: function(t) {\n\t\t\t\treturn t * t;\n\t\t\t},\n\t\t\teaseOutQuad: function(t) {\n\t\t\t\treturn -1 * t * (t - 2);\n\t\t\t},\n\t\t\teaseInOutQuad: function(t) {\n\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\treturn 1 / 2 * t * t;\n\t\t\t\t}\n\t\t\t\treturn -1 / 2 * ((--t) * (t - 2) - 1);\n\t\t\t},\n\t\t\teaseInCubic: function(t) {\n\t\t\t\treturn t * t * t;\n\t\t\t},\n\t\t\teaseOutCubic: function(t) {\n\t\t\t\treturn 1 * ((t = t / 1 - 1) * t * t + 1);\n\t\t\t},\n\t\t\teaseInOutCubic: function(t) {\n\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\treturn 1 / 2 * t * t * t;\n\t\t\t\t}\n\t\t\t\treturn 1 / 2 * ((t -= 2) * t * t + 2);\n\t\t\t},\n\t\t\teaseInQuart: function(t) {\n\t\t\t\treturn t * t * t * t;\n\t\t\t},\n\t\t\teaseOutQuart: function(t) {\n\t\t\t\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);\n\t\t\t},\n\t\t\teaseInOutQuart: function(t) {\n\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\treturn 1 / 2 * t * t * t * t;\n\t\t\t\t}\n\t\t\t\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);\n\t\t\t},\n\t\t\teaseInQuint: function(t) {\n\t\t\t\treturn 1 * (t /= 1) * t * t * t * t;\n\t\t\t},\n\t\t\teaseOutQuint: function(t) {\n\t\t\t\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\n\t\t\t},\n\t\t\teaseInOutQuint: function(t) {\n\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\treturn 1 / 2 * t * t * t * t * t;\n\t\t\t\t}\n\t\t\t\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);\n\t\t\t},\n\t\t\teaseInSine: function(t) {\n\t\t\t\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\n\t\t\t},\n\t\t\teaseOutSine: function(t) {\n\t\t\t\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));\n\t\t\t},\n\t\t\teaseInOutSine: function(t) {\n\t\t\t\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\n\t\t\t},\n\t\t\teaseInExpo: function(t) {\n\t\t\t\treturn (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\n\t\t\t},\n\t\t\teaseOutExpo: function(t) {\n\t\t\t\treturn (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\n\t\t\t},\n\t\t\teaseInOutExpo: function(t) {\n\t\t\t\tif (t === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (t === 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));\n\t\t\t\t}\n\t\t\t\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\n\t\t\t},\n\t\t\teaseInCirc: function(t) {\n\t\t\t\tif (t >= 1) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\n\t\t\t},\n\t\t\teaseOutCirc: function(t) {\n\t\t\t\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\n\t\t\t},\n\t\t\teaseInOutCirc: function(t) {\n\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);\n\t\t\t\t}\n\t\t\t\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t\t\t},\n\t\t\teaseInElastic: function(t) {\n\t\t\t\tvar s = 1.70158;\n\t\t\t\tvar p = 0;\n\t\t\t\tvar a = 1;\n\t\t\t\tif (t === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif ((t /= 1) === 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = 1 * 0.3;\n\t\t\t\t}\n\t\t\t\tif (a < Math.abs(1)) {\n\t\t\t\t\ta = 1;\n\t\t\t\t\ts = p / 4;\n\t\t\t\t} else {\n\t\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t\t}\n\t\t\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t\t},\n\t\t\teaseOutElastic: function(t) {\n\t\t\t\tvar s = 1.70158;\n\t\t\t\tvar p = 0;\n\t\t\t\tvar a = 1;\n\t\t\t\tif (t === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif ((t /= 1) === 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = 1 * 0.3;\n\t\t\t\t}\n\t\t\t\tif (a < Math.abs(1)) {\n\t\t\t\t\ta = 1;\n\t\t\t\t\ts = p / 4;\n\t\t\t\t} else {\n\t\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t\t}\n\t\t\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\n\t\t\t},\n\t\t\teaseInOutElastic: function(t) {\n\t\t\t\tvar s = 1.70158;\n\t\t\t\tvar p = 0;\n\t\t\t\tvar a = 1;\n\t\t\t\tif (t === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif ((t /= 1 / 2) === 2) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = 1 * (0.3 * 1.5);\n\t\t\t\t}\n\t\t\t\tif (a < Math.abs(1)) {\n\t\t\t\t\ta = 1;\n\t\t\t\t\ts = p / 4;\n\t\t\t\t} else {\n\t\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t\t}\n\t\t\t\tif (t < 1) {\n\t\t\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t\t\t}\n\t\t\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\t\t},\n\t\t\teaseInBack: function(t) {\n\t\t\t\tvar s = 1.70158;\n\t\t\t\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);\n\t\t\t},\n\t\t\teaseOutBack: function(t) {\n\t\t\t\tvar s = 1.70158;\n\t\t\t\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\n\t\t\t},\n\t\t\teaseInOutBack: function(t) {\n\t\t\t\tvar s = 1.70158;\n\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\treturn 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t\t\t}\n\t\t\t\treturn 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t\t\t},\n\t\t\teaseInBounce: function(t) {\n\t\t\t\treturn 1 - easingEffects.easeOutBounce(1 - t);\n\t\t\t},\n\t\t\teaseOutBounce: function(t) {\n\t\t\t\tif ((t /= 1) < (1 / 2.75)) {\n\t\t\t\t\treturn 1 * (7.5625 * t * t);\n\t\t\t\t} else if (t < (2 / 2.75)) {\n\t\t\t\t\treturn 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\n\t\t\t\t} else if (t < (2.5 / 2.75)) {\n\t\t\t\t\treturn 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\n\t\t\t\t}\n\t\t\t\treturn 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\n\t\t\t},\n\t\t\teaseInOutBounce: function(t) {\n\t\t\t\tif (t < 1 / 2) {\n\t\t\t\t\treturn easingEffects.easeInBounce(t * 2) * 0.5;\n\t\t\t\t}\n\t\t\t\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\n\t\t\t}\n\t\t};\n\t\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t\thelpers.requestAnimFrame = (function() {\n\t\t\treturn window.requestAnimationFrame ||\n\t\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\t\twindow.oRequestAnimationFrame ||\n\t\t\t\twindow.msRequestAnimationFrame ||\n\t\t\t\tfunction(callback) {\n\t\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t\t};\n\t\t}());\n\t\thelpers.cancelAnimFrame = (function() {\n\t\t\treturn window.cancelAnimationFrame ||\n\t\t\t\twindow.webkitCancelAnimationFrame ||\n\t\t\t\twindow.mozCancelAnimationFrame ||\n\t\t\t\twindow.oCancelAnimationFrame ||\n\t\t\t\twindow.msCancelAnimationFrame ||\n\t\t\t\tfunction(callback) {\n\t\t\t\t\treturn window.clearTimeout(callback, 1000 / 60);\n\t\t\t\t};\n\t\t}());\n\t\t// -- DOM methods\n\t\thelpers.getRelativePosition = function(evt, chart) {\n\t\t\tvar mouseX, mouseY;\n\t\t\tvar e = evt.originalEvent || evt,\n\t\t\t\tcanvas = evt.currentTarget || evt.srcElement,\n\t\t\t\tboundingRect = canvas.getBoundingClientRect();\n\t\n\t\t\tvar touches = e.touches;\n\t\t\tif (touches && touches.length > 0) {\n\t\t\t\tmouseX = touches[0].clientX;\n\t\t\t\tmouseY = touches[0].clientY;\n\t\n\t\t\t} else {\n\t\t\t\tmouseX = e.clientX;\n\t\t\t\tmouseY = e.clientY;\n\t\t\t}\n\t\n\t\t\t// Scale mouse coordinates into canvas coordinates\n\t\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\t\n\t\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\t\n\t\t\treturn {\n\t\t\t\tx: mouseX,\n\t\t\t\ty: mouseY\n\t\t\t};\n\t\n\t\t};\n\t\thelpers.addEvent = function(node, eventType, method) {\n\t\t\tif (node.addEventListener) {\n\t\t\t\tnode.addEventListener(eventType, method);\n\t\t\t} else if (node.attachEvent) {\n\t\t\t\tnode.attachEvent('on' + eventType, method);\n\t\t\t} else {\n\t\t\t\tnode['on' + eventType] = method;\n\t\t\t}\n\t\t};\n\t\thelpers.removeEvent = function(node, eventType, handler) {\n\t\t\tif (node.removeEventListener) {\n\t\t\t\tnode.removeEventListener(eventType, handler, false);\n\t\t\t} else if (node.detachEvent) {\n\t\t\t\tnode.detachEvent('on' + eventType, handler);\n\t\t\t} else {\n\t\t\t\tnode['on' + eventType] = helpers.noop;\n\t\t\t}\n\t\t};\n\t\thelpers.bindEvents = function(chartInstance, arrayOfEvents, handler) {\n\t\t\t// Create the events object if it's not already present\n\t\t\tvar events = chartInstance.events = chartInstance.events || {};\n\t\n\t\t\thelpers.each(arrayOfEvents, function(eventName) {\n\t\t\t\tevents[eventName] = function() {\n\t\t\t\t\thandler.apply(chartInstance, arguments);\n\t\t\t\t};\n\t\t\t\thelpers.addEvent(chartInstance.chart.canvas, eventName, events[eventName]);\n\t\t\t});\n\t\t};\n\t\thelpers.unbindEvents = function(chartInstance, arrayOfEvents) {\n\t\t\tvar canvas = chartInstance.chart.canvas;\n\t\t\thelpers.each(arrayOfEvents, function(handler, eventName) {\n\t\t\t\thelpers.removeEvent(canvas, eventName, handler);\n\t\t\t});\n\t\t};\n\t\n\t\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\t\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\t\tvar valueInPixels;\n\t\t\tif (typeof(styleValue) === 'string') {\n\t\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\t\n\t\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t\t// percentage * size in dimension\n\t\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalueInPixels = styleValue;\n\t\t\t}\n\t\n\t\t\treturn valueInPixels;\n\t\t}\n\t\n\t\t/**\n\t\t * Returns if the given value contains an effective constraint.\n\t\t * @private\n\t\t */\n\t\tfunction isConstrainedValue(value) {\n\t\t\treturn value !== undefined && value !== null && value !== 'none';\n\t\t}\n\t\n\t\t// Private helper to get a constraint dimension\n\t\t// @param domNode : the node to check the constraint on\n\t\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\t\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\t\tvar view = document.defaultView;\n\t\t\tvar parentNode = domNode.parentNode;\n\t\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\t\tvar infinity = Number.POSITIVE_INFINITY;\n\t\n\t\t\tif (hasCNode || hasCContainer) {\n\t\t\t\treturn Math.min(\n\t\t\t\t\thasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\t\thasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t\t}\n\t\n\t\t\treturn 'none';\n\t\t}\n\t\t// returns Number or undefined if no constraint\n\t\thelpers.getConstraintWidth = function(domNode) {\n\t\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t\t};\n\t\t// returns Number or undefined if no constraint\n\t\thelpers.getConstraintHeight = function(domNode) {\n\t\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t\t};\n\t\thelpers.getMaximumWidth = function(domNode) {\n\t\t\tvar container = domNode.parentNode;\n\t\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\t\treturn isNaN(cw)? w : Math.min(w, cw);\n\t\t};\n\t\thelpers.getMaximumHeight = function(domNode) {\n\t\t\tvar container = domNode.parentNode;\n\t\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\t\treturn isNaN(ch)? h : Math.min(h, ch);\n\t\t};\n\t\thelpers.getStyle = function(el, property) {\n\t\t\treturn el.currentStyle ?\n\t\t\t\tel.currentStyle[property] :\n\t\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t\t};\n\t\thelpers.retinaScale = function(chart) {\n\t\t\tvar ctx = chart.ctx;\n\t\t\tvar canvas = chart.canvas;\n\t\t\tvar width = canvas.width;\n\t\t\tvar height = canvas.height;\n\t\t\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\n\t\n\t\t\tif (pixelRatio !== 1) {\n\t\t\t\tcanvas.height = height * pixelRatio;\n\t\t\t\tcanvas.width = width * pixelRatio;\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\n\t\t\t\t// Store the device pixel ratio so that we can go backwards in `destroy`.\n\t\t\t\t// The devicePixelRatio changes with zoom, so there are no guarantees that it is the same\n\t\t\t\t// when destroy is called\n\t\t\t\tchart.originalDevicePixelRatio = chart.originalDevicePixelRatio || pixelRatio;\n\t\t\t}\n\t\n\t\t\tcanvas.style.width = width + 'px';\n\t\t\tcanvas.style.height = height + 'px';\n\t\t};\n\t\t// -- Canvas methods\n\t\thelpers.clear = function(chart) {\n\t\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t\t};\n\t\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t\t};\n\t\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\t\tcache = cache || {};\n\t\t\tvar data = cache.data = cache.data || {};\n\t\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\t\n\t\t\tif (cache.font !== font) {\n\t\t\t\tdata = cache.data = {};\n\t\t\t\tgc = cache.garbageCollect = [];\n\t\t\t\tcache.font = font;\n\t\t\t}\n\t\n\t\t\tctx.font = font;\n\t\t\tvar longest = 0;\n\t\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\t\thelpers.each(thing, function(nestedThing) {\n\t\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tvar gcLen = gc.length / 2;\n\t\t\tif (gcLen > arrayOfThings.length) {\n\t\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\t\tdelete data[gc[i]];\n\t\t\t\t}\n\t\t\t\tgc.splice(0, gcLen);\n\t\t\t}\n\t\t\treturn longest;\n\t\t};\n\t\thelpers.measureText = function(ctx, data, gc, longest, string) {\n\t\t\tvar textWidth = data[string];\n\t\t\tif (!textWidth) {\n\t\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\t\tgc.push(string);\n\t\t\t}\n\t\t\tif (textWidth > longest) {\n\t\t\t\tlongest = textWidth;\n\t\t\t}\n\t\t\treturn longest;\n\t\t};\n\t\thelpers.numberOfLabelLines = function(arrayOfThings) {\n\t\t\tvar numberOfLines = 1;\n\t\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn numberOfLines;\n\t\t};\n\t\thelpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.closePath();\n\t\t};\n\t\thelpers.color = function(c) {\n\t\t\tif (!color) {\n\t\t\t\tconsole.error('Color.js not found!');\n\t\t\t\treturn c;\n\t\t\t}\n\t\n\t\t\t/* global CanvasGradient */\n\t\t\tif (c instanceof CanvasGradient) {\n\t\t\t\treturn color(Chart.defaults.global.defaultColor);\n\t\t\t}\n\t\n\t\t\treturn color(c);\n\t\t};\n\t\thelpers.addResizeListener = function(node, callback) {\n\t\t\t// Hide an iframe before the node\n\t\t\tvar hiddenIframe = document.createElement('iframe');\n\t\t\tvar hiddenIframeClass = 'chartjs-hidden-iframe';\n\t\n\t\t\tif (hiddenIframe.classlist) {\n\t\t\t\t// can use classlist\n\t\t\t\thiddenIframe.classlist.add(hiddenIframeClass);\n\t\t\t} else {\n\t\t\t\thiddenIframe.setAttribute('class', hiddenIframeClass);\n\t\t\t}\n\t\n\t\t\t// Set the style\n\t\t\thiddenIframe.tabIndex = -1;\n\t\t\tvar style = hiddenIframe.style;\n\t\t\tstyle.width = '100%';\n\t\t\tstyle.display = 'block';\n\t\t\tstyle.border = 0;\n\t\t\tstyle.height = 0;\n\t\t\tstyle.margin = 0;\n\t\t\tstyle.position = 'absolute';\n\t\t\tstyle.left = 0;\n\t\t\tstyle.right = 0;\n\t\t\tstyle.top = 0;\n\t\t\tstyle.bottom = 0;\n\t\n\t\t\t// Insert the iframe so that contentWindow is available\n\t\t\tnode.insertBefore(hiddenIframe, node.firstChild);\n\t\n\t\t\t(hiddenIframe.contentWindow || hiddenIframe).onresize = function() {\n\t\t\t\tif (callback) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\thelpers.removeResizeListener = function(node) {\n\t\t\tvar hiddenIframe = node.querySelector('.chartjs-hidden-iframe');\n\t\n\t\t\t// Remove the resize detect iframe\n\t\t\tif (hiddenIframe) {\n\t\t\t\thiddenIframe.parentNode.removeChild(hiddenIframe);\n\t\t\t}\n\t\t};\n\t\thelpers.isArray = Array.isArray?\n\t\t\tfunction(obj) {\n\t\t\t\treturn Array.isArray(obj);\n\t\t\t} :\n\t\t\tfunction(obj) {\n\t\t\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t\t\t};\n\t\t// ! @see http://stackoverflow.com/a/14853974\n\t\thelpers.arrayEquals = function(a0, a1) {\n\t\t\tvar i, ilen, v0, v1;\n\t\n\t\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tfor (i = 0, ilen=a0.length; i < ilen; ++i) {\n\t\t\t\tv0 = a0[i];\n\t\t\t\tv1 = a1[i];\n\t\n\t\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (v0 !== v1) {\n\t\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\t};\n\t\thelpers.callCallback = function(fn, args, _tArg) {\n\t\t\tif (fn && typeof fn.call === 'function') {\n\t\t\t\tfn.apply(_tArg, args);\n\t\t\t}\n\t\t};\n\t\thelpers.getHoverColor = function(colorValue) {\n\t\t\t/* global CanvasPattern */\n\t\t\treturn (colorValue instanceof CanvasPattern) ?\n\t\t\t\tcolorValue :\n\t\t\t\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t\t};\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* MIT license */\r\n\tvar convert = __webpack_require__(6);\r\n\tvar string = __webpack_require__(8);\r\n\t\r\n\tvar Color = function (obj) {\r\n\t\tif (obj instanceof Color) {\r\n\t\t\treturn obj;\r\n\t\t}\r\n\t\tif (!(this instanceof Color)) {\r\n\t\t\treturn new Color(obj);\r\n\t\t}\r\n\t\r\n\t\tthis.values = {\r\n\t\t\trgb: [0, 0, 0],\r\n\t\t\thsl: [0, 0, 0],\r\n\t\t\thsv: [0, 0, 0],\r\n\t\t\thwb: [0, 0, 0],\r\n\t\t\tcmyk: [0, 0, 0, 0],\r\n\t\t\talpha: 1\r\n\t\t};\r\n\t\r\n\t\t// parse Color() argument\r\n\t\tvar vals;\r\n\t\tif (typeof obj === 'string') {\r\n\t\t\tvals = string.getRgba(obj);\r\n\t\t\tif (vals) {\r\n\t\t\t\tthis.setValues('rgb', vals);\r\n\t\t\t} else if (vals = string.getHsla(obj)) {\r\n\t\t\t\tthis.setValues('hsl', vals);\r\n\t\t\t} else if (vals = string.getHwb(obj)) {\r\n\t\t\t\tthis.setValues('hwb', vals);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Unable to parse color from string \"' + obj + '\"');\r\n\t\t\t}\r\n\t\t} else if (typeof obj === 'object') {\r\n\t\t\tvals = obj;\r\n\t\t\tif (vals.r !== undefined || vals.red !== undefined) {\r\n\t\t\t\tthis.setValues('rgb', vals);\r\n\t\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\r\n\t\t\t\tthis.setValues('hsl', vals);\r\n\t\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\r\n\t\t\t\tthis.setValues('hsv', vals);\r\n\t\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\r\n\t\t\t\tthis.setValues('hwb', vals);\r\n\t\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\r\n\t\t\t\tthis.setValues('cmyk', vals);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Unable to parse color from object ' + JSON.stringify(obj));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\tColor.prototype = {\r\n\t\trgb: function () {\r\n\t\t\treturn this.setSpace('rgb', arguments);\r\n\t\t},\r\n\t\thsl: function () {\r\n\t\t\treturn this.setSpace('hsl', arguments);\r\n\t\t},\r\n\t\thsv: function () {\r\n\t\t\treturn this.setSpace('hsv', arguments);\r\n\t\t},\r\n\t\thwb: function () {\r\n\t\t\treturn this.setSpace('hwb', arguments);\r\n\t\t},\r\n\t\tcmyk: function () {\r\n\t\t\treturn this.setSpace('cmyk', arguments);\r\n\t\t},\r\n\t\r\n\t\trgbArray: function () {\r\n\t\t\treturn this.values.rgb;\r\n\t\t},\r\n\t\thslArray: function () {\r\n\t\t\treturn this.values.hsl;\r\n\t\t},\r\n\t\thsvArray: function () {\r\n\t\t\treturn this.values.hsv;\r\n\t\t},\r\n\t\thwbArray: function () {\r\n\t\t\tvar values = this.values;\r\n\t\t\tif (values.alpha !== 1) {\r\n\t\t\t\treturn values.hwb.concat([values.alpha]);\r\n\t\t\t}\r\n\t\t\treturn values.hwb;\r\n\t\t},\r\n\t\tcmykArray: function () {\r\n\t\t\treturn this.values.cmyk;\r\n\t\t},\r\n\t\trgbaArray: function () {\r\n\t\t\tvar values = this.values;\r\n\t\t\treturn values.rgb.concat([values.alpha]);\r\n\t\t},\r\n\t\thslaArray: function () {\r\n\t\t\tvar values = this.values;\r\n\t\t\treturn values.hsl.concat([values.alpha]);\r\n\t\t},\r\n\t\talpha: function (val) {\r\n\t\t\tif (val === undefined) {\r\n\t\t\t\treturn this.values.alpha;\r\n\t\t\t}\r\n\t\t\tthis.setValues('alpha', val);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tred: function (val) {\r\n\t\t\treturn this.setChannel('rgb', 0, val);\r\n\t\t},\r\n\t\tgreen: function (val) {\r\n\t\t\treturn this.setChannel('rgb', 1, val);\r\n\t\t},\r\n\t\tblue: function (val) {\r\n\t\t\treturn this.setChannel('rgb', 2, val);\r\n\t\t},\r\n\t\thue: function (val) {\r\n\t\t\tif (val) {\r\n\t\t\t\tval %= 360;\r\n\t\t\t\tval = val < 0 ? 360 + val : val;\r\n\t\t\t}\r\n\t\t\treturn this.setChannel('hsl', 0, val);\r\n\t\t},\r\n\t\tsaturation: function (val) {\r\n\t\t\treturn this.setChannel('hsl', 1, val);\r\n\t\t},\r\n\t\tlightness: function (val) {\r\n\t\t\treturn this.setChannel('hsl', 2, val);\r\n\t\t},\r\n\t\tsaturationv: function (val) {\r\n\t\t\treturn this.setChannel('hsv', 1, val);\r\n\t\t},\r\n\t\twhiteness: function (val) {\r\n\t\t\treturn this.setChannel('hwb', 1, val);\r\n\t\t},\r\n\t\tblackness: function (val) {\r\n\t\t\treturn this.setChannel('hwb', 2, val);\r\n\t\t},\r\n\t\tvalue: function (val) {\r\n\t\t\treturn this.setChannel('hsv', 2, val);\r\n\t\t},\r\n\t\tcyan: function (val) {\r\n\t\t\treturn this.setChannel('cmyk', 0, val);\r\n\t\t},\r\n\t\tmagenta: function (val) {\r\n\t\t\treturn this.setChannel('cmyk', 1, val);\r\n\t\t},\r\n\t\tyellow: function (val) {\r\n\t\t\treturn this.setChannel('cmyk', 2, val);\r\n\t\t},\r\n\t\tblack: function (val) {\r\n\t\t\treturn this.setChannel('cmyk', 3, val);\r\n\t\t},\r\n\t\r\n\t\thexString: function () {\r\n\t\t\treturn string.hexString(this.values.rgb);\r\n\t\t},\r\n\t\trgbString: function () {\r\n\t\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\r\n\t\t},\r\n\t\trgbaString: function () {\r\n\t\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\r\n\t\t},\r\n\t\tpercentString: function () {\r\n\t\t\treturn string.percentString(this.values.rgb, this.values.alpha);\r\n\t\t},\r\n\t\thslString: function () {\r\n\t\t\treturn string.hslString(this.values.hsl, this.values.alpha);\r\n\t\t},\r\n\t\thslaString: function () {\r\n\t\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\r\n\t\t},\r\n\t\thwbString: function () {\r\n\t\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\r\n\t\t},\r\n\t\tkeyword: function () {\r\n\t\t\treturn string.keyword(this.values.rgb, this.values.alpha);\r\n\t\t},\r\n\t\r\n\t\trgbNumber: function () {\r\n\t\t\tvar rgb = this.values.rgb;\r\n\t\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\r\n\t\t},\r\n\t\r\n\t\tluminosity: function () {\r\n\t\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\r\n\t\t\tvar rgb = this.values.rgb;\r\n\t\t\tvar lum = [];\r\n\t\t\tfor (var i = 0; i < rgb.length; i++) {\r\n\t\t\t\tvar chan = rgb[i] / 255;\r\n\t\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\r\n\t\t\t}\r\n\t\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\r\n\t\t},\r\n\t\r\n\t\tcontrast: function (color2) {\r\n\t\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\r\n\t\t\tvar lum1 = this.luminosity();\r\n\t\t\tvar lum2 = color2.luminosity();\r\n\t\t\tif (lum1 > lum2) {\r\n\t\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\r\n\t\t\t}\r\n\t\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\r\n\t\t},\r\n\t\r\n\t\tlevel: function (color2) {\r\n\t\t\tvar contrastRatio = this.contrast(color2);\r\n\t\t\tif (contrastRatio >= 7.1) {\r\n\t\t\t\treturn 'AAA';\r\n\t\t\t}\r\n\t\r\n\t\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\r\n\t\t},\r\n\t\r\n\t\tdark: function () {\r\n\t\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\r\n\t\t\tvar rgb = this.values.rgb;\r\n\t\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\r\n\t\t\treturn yiq < 128;\r\n\t\t},\r\n\t\r\n\t\tlight: function () {\r\n\t\t\treturn !this.dark();\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\t\tvar rgb = [];\r\n\t\t\tfor (var i = 0; i < 3; i++) {\r\n\t\t\t\trgb[i] = 255 - this.values.rgb[i];\r\n\t\t\t}\r\n\t\t\tthis.setValues('rgb', rgb);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tlighten: function (ratio) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\thsl[2] += hsl[2] * ratio;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tdarken: function (ratio) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\thsl[2] -= hsl[2] * ratio;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsaturate: function (ratio) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\thsl[1] += hsl[1] * ratio;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tdesaturate: function (ratio) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\thsl[1] -= hsl[1] * ratio;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\twhiten: function (ratio) {\r\n\t\t\tvar hwb = this.values.hwb;\r\n\t\t\thwb[1] += hwb[1] * ratio;\r\n\t\t\tthis.setValues('hwb', hwb);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tblacken: function (ratio) {\r\n\t\t\tvar hwb = this.values.hwb;\r\n\t\t\thwb[2] += hwb[2] * ratio;\r\n\t\t\tthis.setValues('hwb', hwb);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tgreyscale: function () {\r\n\t\t\tvar rgb = this.values.rgb;\r\n\t\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\r\n\t\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\r\n\t\t\tthis.setValues('rgb', [val, val, val]);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tclearer: function (ratio) {\r\n\t\t\tvar alpha = this.values.alpha;\r\n\t\t\tthis.setValues('alpha', alpha - (alpha * ratio));\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\topaquer: function (ratio) {\r\n\t\t\tvar alpha = this.values.alpha;\r\n\t\t\tthis.setValues('alpha', alpha + (alpha * ratio));\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\trotate: function (degrees) {\r\n\t\t\tvar hsl = this.values.hsl;\r\n\t\t\tvar hue = (hsl[0] + degrees) % 360;\r\n\t\t\thsl[0] = hue < 0 ? 360 + hue : hue;\r\n\t\t\tthis.setValues('hsl', hsl);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Ported from sass implementation in C\r\n\t\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\r\n\t\t */\r\n\t\tmix: function (mixinColor, weight) {\r\n\t\t\tvar color1 = this;\r\n\t\t\tvar color2 = mixinColor;\r\n\t\t\tvar p = weight === undefined ? 0.5 : weight;\r\n\t\r\n\t\t\tvar w = 2 * p - 1;\r\n\t\t\tvar a = color1.alpha() - color2.alpha();\r\n\t\r\n\t\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\r\n\t\t\tvar w2 = 1 - w1;\r\n\t\r\n\t\t\treturn this\r\n\t\t\t\t.rgb(\r\n\t\t\t\t\tw1 * color1.red() + w2 * color2.red(),\r\n\t\t\t\t\tw1 * color1.green() + w2 * color2.green(),\r\n\t\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\r\n\t\t\t\t)\r\n\t\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\t\treturn this.rgb();\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\r\n\t\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\r\n\t\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\r\n\t\t\t// except 'alpha' which is a number.\r\n\t\t\tvar result = new Color();\r\n\t\t\tvar source = this.values;\r\n\t\t\tvar target = result.values;\r\n\t\t\tvar value, type;\r\n\t\r\n\t\t\tfor (var prop in source) {\r\n\t\t\t\tif (source.hasOwnProperty(prop)) {\r\n\t\t\t\t\tvalue = source[prop];\r\n\t\t\t\t\ttype = ({}).toString.call(value);\r\n\t\t\t\t\tif (type === '[object Array]') {\r\n\t\t\t\t\t\ttarget[prop] = value.slice(0);\r\n\t\t\t\t\t} else if (type === '[object Number]') {\r\n\t\t\t\t\t\ttarget[prop] = value;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.error('unexpected color value:', value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\t}\r\n\t};\r\n\t\r\n\tColor.prototype.spaces = {\r\n\t\trgb: ['red', 'green', 'blue'],\r\n\t\thsl: ['hue', 'saturation', 'lightness'],\r\n\t\thsv: ['hue', 'saturation', 'value'],\r\n\t\thwb: ['hue', 'whiteness', 'blackness'],\r\n\t\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\r\n\t};\r\n\t\r\n\tColor.prototype.maxes = {\r\n\t\trgb: [255, 255, 255],\r\n\t\thsl: [360, 100, 100],\r\n\t\thsv: [360, 100, 100],\r\n\t\thwb: [360, 100, 100],\r\n\t\tcmyk: [100, 100, 100, 100]\r\n\t};\r\n\t\r\n\tColor.prototype.getValues = function (space) {\r\n\t\tvar values = this.values;\r\n\t\tvar vals = {};\r\n\t\r\n\t\tfor (var i = 0; i < space.length; i++) {\r\n\t\t\tvals[space.charAt(i)] = values[space][i];\r\n\t\t}\r\n\t\r\n\t\tif (values.alpha !== 1) {\r\n\t\t\tvals.a = values.alpha;\r\n\t\t}\r\n\t\r\n\t\t// {r: 255, g: 255, b: 255, a: 0.4}\r\n\t\treturn vals;\r\n\t};\r\n\t\r\n\tColor.prototype.setValues = function (space, vals) {\r\n\t\tvar values = this.values;\r\n\t\tvar spaces = this.spaces;\r\n\t\tvar maxes = this.maxes;\r\n\t\tvar alpha = 1;\r\n\t\tvar i;\r\n\t\r\n\t\tif (space === 'alpha') {\r\n\t\t\talpha = vals;\r\n\t\t} else if (vals.length) {\r\n\t\t\t// [10, 10, 10]\r\n\t\t\tvalues[space] = vals.slice(0, space.length);\r\n\t\t\talpha = vals[space.length];\r\n\t\t} else if (vals[space.charAt(0)] !== undefined) {\r\n\t\t\t// {r: 10, g: 10, b: 10}\r\n\t\t\tfor (i = 0; i < space.length; i++) {\r\n\t\t\t\tvalues[space][i] = vals[space.charAt(i)];\r\n\t\t\t}\r\n\t\r\n\t\t\talpha = vals.a;\r\n\t\t} else if (vals[spaces[space][0]] !== undefined) {\r\n\t\t\t// {red: 10, green: 10, blue: 10}\r\n\t\t\tvar chans = spaces[space];\r\n\t\r\n\t\t\tfor (i = 0; i < space.length; i++) {\r\n\t\t\t\tvalues[space][i] = vals[chans[i]];\r\n\t\t\t}\r\n\t\r\n\t\t\talpha = vals.alpha;\r\n\t\t}\r\n\t\r\n\t\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\r\n\t\r\n\t\tif (space === 'alpha') {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\r\n\t\tvar capped;\r\n\t\r\n\t\t// cap values of the space prior converting all values\r\n\t\tfor (i = 0; i < space.length; i++) {\r\n\t\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\r\n\t\t\tvalues[space][i] = Math.round(capped);\r\n\t\t}\r\n\t\r\n\t\t// convert to all the other color spaces\r\n\t\tfor (var sname in spaces) {\r\n\t\t\tif (sname !== space) {\r\n\t\t\t\tvalues[sname] = convert[space][sname](values[space]);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\treturn true;\r\n\t};\r\n\t\r\n\tColor.prototype.setSpace = function (space, args) {\r\n\t\tvar vals = args[0];\r\n\t\r\n\t\tif (vals === undefined) {\r\n\t\t\t// color.rgb()\r\n\t\t\treturn this.getValues(space);\r\n\t\t}\r\n\t\r\n\t\t// color.rgb(10, 10, 10)\r\n\t\tif (typeof vals === 'number') {\r\n\t\t\tvals = Array.prototype.slice.call(args);\r\n\t\t}\r\n\t\r\n\t\tthis.setValues(space, vals);\r\n\t\treturn this;\r\n\t};\r\n\t\r\n\tColor.prototype.setChannel = function (space, index, val) {\r\n\t\tvar svalues = this.values[space];\r\n\t\tif (val === undefined) {\r\n\t\t\t// color.red()\r\n\t\t\treturn svalues[index];\r\n\t\t} else if (val === svalues[index]) {\r\n\t\t\t// color.red(color.red())\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\r\n\t\t// color.red(100)\r\n\t\tsvalues[index] = val;\r\n\t\tthis.setValues(space, svalues);\r\n\t\r\n\t\treturn this;\r\n\t};\r\n\t\r\n\tif (typeof window !== 'undefined') {\r\n\t\twindow.Color = Color;\r\n\t}\r\n\t\r\n\tmodule.exports = Color;\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar conversions = __webpack_require__(7);\n\t\n\tvar convert = function() {\n\t   return new Converter();\n\t}\n\t\n\tfor (var func in conversions) {\n\t  // export Raw versions\n\t  convert[func + \"Raw\"] =  (function(func) {\n\t    // accept array or plain args\n\t    return function(arg) {\n\t      if (typeof arg == \"number\")\n\t        arg = Array.prototype.slice.call(arguments);\n\t      return conversions[func](arg);\n\t    }\n\t  })(func);\n\t\n\t  var pair = /(\\w+)2(\\w+)/.exec(func),\n\t      from = pair[1],\n\t      to = pair[2];\n\t\n\t  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n\t  convert[from] = convert[from] || {};\n\t\n\t  convert[from][to] = convert[func] = (function(func) { \n\t    return function(arg) {\n\t      if (typeof arg == \"number\")\n\t        arg = Array.prototype.slice.call(arguments);\n\t      \n\t      var val = conversions[func](arg);\n\t      if (typeof val == \"string\" || val === undefined)\n\t        return val; // keyword\n\t\n\t      for (var i = 0; i < val.length; i++)\n\t        val[i] = Math.round(val[i]);\n\t      return val;\n\t    }\n\t  })(func);\n\t}\n\t\n\t\n\t/* Converter does lazy conversion and caching */\n\tvar Converter = function() {\n\t   this.convs = {};\n\t};\n\t\n\t/* Either get the values for a space or\n\t  set the values for a space, depending on args */\n\tConverter.prototype.routeSpace = function(space, args) {\n\t   var values = args[0];\n\t   if (values === undefined) {\n\t      // color.rgb()\n\t      return this.getValues(space);\n\t   }\n\t   // color.rgb(10, 10, 10)\n\t   if (typeof values == \"number\") {\n\t      values = Array.prototype.slice.call(args);        \n\t   }\n\t\n\t   return this.setValues(space, values);\n\t};\n\t  \n\t/* Set the values for a space, invalidating cache */\n\tConverter.prototype.setValues = function(space, values) {\n\t   this.space = space;\n\t   this.convs = {};\n\t   this.convs[space] = values;\n\t   return this;\n\t};\n\t\n\t/* Get the values for a space. If there's already\n\t  a conversion for the space, fetch it, otherwise\n\t  compute it */\n\tConverter.prototype.getValues = function(space) {\n\t   var vals = this.convs[space];\n\t   if (!vals) {\n\t      var fspace = this.space,\n\t          from = this.convs[fspace];\n\t      vals = convert[fspace][space](from);\n\t\n\t      this.convs[space] = vals;\n\t   }\n\t  return vals;\n\t};\n\t\n\t[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n\t   Converter.prototype[space] = function(vals) {\n\t      return this.routeSpace(space, arguments);\n\t   }\n\t});\n\t\n\tmodule.exports = convert;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/* MIT license */\n\t\n\tmodule.exports = {\n\t  rgb2hsl: rgb2hsl,\n\t  rgb2hsv: rgb2hsv,\n\t  rgb2hwb: rgb2hwb,\n\t  rgb2cmyk: rgb2cmyk,\n\t  rgb2keyword: rgb2keyword,\n\t  rgb2xyz: rgb2xyz,\n\t  rgb2lab: rgb2lab,\n\t  rgb2lch: rgb2lch,\n\t\n\t  hsl2rgb: hsl2rgb,\n\t  hsl2hsv: hsl2hsv,\n\t  hsl2hwb: hsl2hwb,\n\t  hsl2cmyk: hsl2cmyk,\n\t  hsl2keyword: hsl2keyword,\n\t\n\t  hsv2rgb: hsv2rgb,\n\t  hsv2hsl: hsv2hsl,\n\t  hsv2hwb: hsv2hwb,\n\t  hsv2cmyk: hsv2cmyk,\n\t  hsv2keyword: hsv2keyword,\n\t\n\t  hwb2rgb: hwb2rgb,\n\t  hwb2hsl: hwb2hsl,\n\t  hwb2hsv: hwb2hsv,\n\t  hwb2cmyk: hwb2cmyk,\n\t  hwb2keyword: hwb2keyword,\n\t\n\t  cmyk2rgb: cmyk2rgb,\n\t  cmyk2hsl: cmyk2hsl,\n\t  cmyk2hsv: cmyk2hsv,\n\t  cmyk2hwb: cmyk2hwb,\n\t  cmyk2keyword: cmyk2keyword,\n\t\n\t  keyword2rgb: keyword2rgb,\n\t  keyword2hsl: keyword2hsl,\n\t  keyword2hsv: keyword2hsv,\n\t  keyword2hwb: keyword2hwb,\n\t  keyword2cmyk: keyword2cmyk,\n\t  keyword2lab: keyword2lab,\n\t  keyword2xyz: keyword2xyz,\n\t\n\t  xyz2rgb: xyz2rgb,\n\t  xyz2lab: xyz2lab,\n\t  xyz2lch: xyz2lch,\n\t\n\t  lab2xyz: lab2xyz,\n\t  lab2rgb: lab2rgb,\n\t  lab2lch: lab2lch,\n\t\n\t  lch2lab: lch2lab,\n\t  lch2xyz: lch2xyz,\n\t  lch2rgb: lch2rgb\n\t}\n\t\n\t\n\tfunction rgb2hsl(rgb) {\n\t  var r = rgb[0]/255,\n\t      g = rgb[1]/255,\n\t      b = rgb[2]/255,\n\t      min = Math.min(r, g, b),\n\t      max = Math.max(r, g, b),\n\t      delta = max - min,\n\t      h, s, l;\n\t\n\t  if (max == min)\n\t    h = 0;\n\t  else if (r == max)\n\t    h = (g - b) / delta;\n\t  else if (g == max)\n\t    h = 2 + (b - r) / delta;\n\t  else if (b == max)\n\t    h = 4 + (r - g)/ delta;\n\t\n\t  h = Math.min(h * 60, 360);\n\t\n\t  if (h < 0)\n\t    h += 360;\n\t\n\t  l = (min + max) / 2;\n\t\n\t  if (max == min)\n\t    s = 0;\n\t  else if (l <= 0.5)\n\t    s = delta / (max + min);\n\t  else\n\t    s = delta / (2 - max - min);\n\t\n\t  return [h, s * 100, l * 100];\n\t}\n\t\n\tfunction rgb2hsv(rgb) {\n\t  var r = rgb[0],\n\t      g = rgb[1],\n\t      b = rgb[2],\n\t      min = Math.min(r, g, b),\n\t      max = Math.max(r, g, b),\n\t      delta = max - min,\n\t      h, s, v;\n\t\n\t  if (max == 0)\n\t    s = 0;\n\t  else\n\t    s = (delta/max * 1000)/10;\n\t\n\t  if (max == min)\n\t    h = 0;\n\t  else if (r == max)\n\t    h = (g - b) / delta;\n\t  else if (g == max)\n\t    h = 2 + (b - r) / delta;\n\t  else if (b == max)\n\t    h = 4 + (r - g) / delta;\n\t\n\t  h = Math.min(h * 60, 360);\n\t\n\t  if (h < 0)\n\t    h += 360;\n\t\n\t  v = ((max / 255) * 1000) / 10;\n\t\n\t  return [h, s, v];\n\t}\n\t\n\tfunction rgb2hwb(rgb) {\n\t  var r = rgb[0],\n\t      g = rgb[1],\n\t      b = rgb[2],\n\t      h = rgb2hsl(rgb)[0],\n\t      w = 1/255 * Math.min(r, Math.min(g, b)),\n\t      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\t\n\t  return [h, w * 100, b * 100];\n\t}\n\t\n\tfunction rgb2cmyk(rgb) {\n\t  var r = rgb[0] / 255,\n\t      g = rgb[1] / 255,\n\t      b = rgb[2] / 255,\n\t      c, m, y, k;\n\t\n\t  k = Math.min(1 - r, 1 - g, 1 - b);\n\t  c = (1 - r - k) / (1 - k) || 0;\n\t  m = (1 - g - k) / (1 - k) || 0;\n\t  y = (1 - b - k) / (1 - k) || 0;\n\t  return [c * 100, m * 100, y * 100, k * 100];\n\t}\n\t\n\tfunction rgb2keyword(rgb) {\n\t  return reverseKeywords[JSON.stringify(rgb)];\n\t}\n\t\n\tfunction rgb2xyz(rgb) {\n\t  var r = rgb[0] / 255,\n\t      g = rgb[1] / 255,\n\t      b = rgb[2] / 255;\n\t\n\t  // assume sRGB\n\t  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\t  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\t  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\t\n\t  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\t  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\t  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\t\n\t  return [x * 100, y *100, z * 100];\n\t}\n\t\n\tfunction rgb2lab(rgb) {\n\t  var xyz = rgb2xyz(rgb),\n\t        x = xyz[0],\n\t        y = xyz[1],\n\t        z = xyz[2],\n\t        l, a, b;\n\t\n\t  x /= 95.047;\n\t  y /= 100;\n\t  z /= 108.883;\n\t\n\t  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n\t  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n\t  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\t\n\t  l = (116 * y) - 16;\n\t  a = 500 * (x - y);\n\t  b = 200 * (y - z);\n\t\n\t  return [l, a, b];\n\t}\n\t\n\tfunction rgb2lch(args) {\n\t  return lab2lch(rgb2lab(args));\n\t}\n\t\n\tfunction hsl2rgb(hsl) {\n\t  var h = hsl[0] / 360,\n\t      s = hsl[1] / 100,\n\t      l = hsl[2] / 100,\n\t      t1, t2, t3, rgb, val;\n\t\n\t  if (s == 0) {\n\t    val = l * 255;\n\t    return [val, val, val];\n\t  }\n\t\n\t  if (l < 0.5)\n\t    t2 = l * (1 + s);\n\t  else\n\t    t2 = l + s - l * s;\n\t  t1 = 2 * l - t2;\n\t\n\t  rgb = [0, 0, 0];\n\t  for (var i = 0; i < 3; i++) {\n\t    t3 = h + 1 / 3 * - (i - 1);\n\t    t3 < 0 && t3++;\n\t    t3 > 1 && t3--;\n\t\n\t    if (6 * t3 < 1)\n\t      val = t1 + (t2 - t1) * 6 * t3;\n\t    else if (2 * t3 < 1)\n\t      val = t2;\n\t    else if (3 * t3 < 2)\n\t      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t    else\n\t      val = t1;\n\t\n\t    rgb[i] = val * 255;\n\t  }\n\t\n\t  return rgb;\n\t}\n\t\n\tfunction hsl2hsv(hsl) {\n\t  var h = hsl[0],\n\t      s = hsl[1] / 100,\n\t      l = hsl[2] / 100,\n\t      sv, v;\n\t\n\t  if(l === 0) {\n\t      // no need to do calc on black\n\t      // also avoids divide by 0 error\n\t      return [0, 0, 0];\n\t  }\n\t\n\t  l *= 2;\n\t  s *= (l <= 1) ? l : 2 - l;\n\t  v = (l + s) / 2;\n\t  sv = (2 * s) / (l + s);\n\t  return [h, sv * 100, v * 100];\n\t}\n\t\n\tfunction hsl2hwb(args) {\n\t  return rgb2hwb(hsl2rgb(args));\n\t}\n\t\n\tfunction hsl2cmyk(args) {\n\t  return rgb2cmyk(hsl2rgb(args));\n\t}\n\t\n\tfunction hsl2keyword(args) {\n\t  return rgb2keyword(hsl2rgb(args));\n\t}\n\t\n\t\n\tfunction hsv2rgb(hsv) {\n\t  var h = hsv[0] / 60,\n\t      s = hsv[1] / 100,\n\t      v = hsv[2] / 100,\n\t      hi = Math.floor(h) % 6;\n\t\n\t  var f = h - Math.floor(h),\n\t      p = 255 * v * (1 - s),\n\t      q = 255 * v * (1 - (s * f)),\n\t      t = 255 * v * (1 - (s * (1 - f))),\n\t      v = 255 * v;\n\t\n\t  switch(hi) {\n\t    case 0:\n\t      return [v, t, p];\n\t    case 1:\n\t      return [q, v, p];\n\t    case 2:\n\t      return [p, v, t];\n\t    case 3:\n\t      return [p, q, v];\n\t    case 4:\n\t      return [t, p, v];\n\t    case 5:\n\t      return [v, p, q];\n\t  }\n\t}\n\t\n\tfunction hsv2hsl(hsv) {\n\t  var h = hsv[0],\n\t      s = hsv[1] / 100,\n\t      v = hsv[2] / 100,\n\t      sl, l;\n\t\n\t  l = (2 - s) * v;\n\t  sl = s * v;\n\t  sl /= (l <= 1) ? l : 2 - l;\n\t  sl = sl || 0;\n\t  l /= 2;\n\t  return [h, sl * 100, l * 100];\n\t}\n\t\n\tfunction hsv2hwb(args) {\n\t  return rgb2hwb(hsv2rgb(args))\n\t}\n\t\n\tfunction hsv2cmyk(args) {\n\t  return rgb2cmyk(hsv2rgb(args));\n\t}\n\t\n\tfunction hsv2keyword(args) {\n\t  return rgb2keyword(hsv2rgb(args));\n\t}\n\t\n\t// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\n\tfunction hwb2rgb(hwb) {\n\t  var h = hwb[0] / 360,\n\t      wh = hwb[1] / 100,\n\t      bl = hwb[2] / 100,\n\t      ratio = wh + bl,\n\t      i, v, f, n;\n\t\n\t  // wh + bl cant be > 1\n\t  if (ratio > 1) {\n\t    wh /= ratio;\n\t    bl /= ratio;\n\t  }\n\t\n\t  i = Math.floor(6 * h);\n\t  v = 1 - bl;\n\t  f = 6 * h - i;\n\t  if ((i & 0x01) != 0) {\n\t    f = 1 - f;\n\t  }\n\t  n = wh + f * (v - wh);  // linear interpolation\n\t\n\t  switch (i) {\n\t    default:\n\t    case 6:\n\t    case 0: r = v; g = n; b = wh; break;\n\t    case 1: r = n; g = v; b = wh; break;\n\t    case 2: r = wh; g = v; b = n; break;\n\t    case 3: r = wh; g = n; b = v; break;\n\t    case 4: r = n; g = wh; b = v; break;\n\t    case 5: r = v; g = wh; b = n; break;\n\t  }\n\t\n\t  return [r * 255, g * 255, b * 255];\n\t}\n\t\n\tfunction hwb2hsl(args) {\n\t  return rgb2hsl(hwb2rgb(args));\n\t}\n\t\n\tfunction hwb2hsv(args) {\n\t  return rgb2hsv(hwb2rgb(args));\n\t}\n\t\n\tfunction hwb2cmyk(args) {\n\t  return rgb2cmyk(hwb2rgb(args));\n\t}\n\t\n\tfunction hwb2keyword(args) {\n\t  return rgb2keyword(hwb2rgb(args));\n\t}\n\t\n\tfunction cmyk2rgb(cmyk) {\n\t  var c = cmyk[0] / 100,\n\t      m = cmyk[1] / 100,\n\t      y = cmyk[2] / 100,\n\t      k = cmyk[3] / 100,\n\t      r, g, b;\n\t\n\t  r = 1 - Math.min(1, c * (1 - k) + k);\n\t  g = 1 - Math.min(1, m * (1 - k) + k);\n\t  b = 1 - Math.min(1, y * (1 - k) + k);\n\t  return [r * 255, g * 255, b * 255];\n\t}\n\t\n\tfunction cmyk2hsl(args) {\n\t  return rgb2hsl(cmyk2rgb(args));\n\t}\n\t\n\tfunction cmyk2hsv(args) {\n\t  return rgb2hsv(cmyk2rgb(args));\n\t}\n\t\n\tfunction cmyk2hwb(args) {\n\t  return rgb2hwb(cmyk2rgb(args));\n\t}\n\t\n\tfunction cmyk2keyword(args) {\n\t  return rgb2keyword(cmyk2rgb(args));\n\t}\n\t\n\t\n\tfunction xyz2rgb(xyz) {\n\t  var x = xyz[0] / 100,\n\t      y = xyz[1] / 100,\n\t      z = xyz[2] / 100,\n\t      r, g, b;\n\t\n\t  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\t  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\t  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\t\n\t  // assume sRGB\n\t  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t    : r = (r * 12.92);\n\t\n\t  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t    : g = (g * 12.92);\n\t\n\t  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t    : b = (b * 12.92);\n\t\n\t  r = Math.min(Math.max(0, r), 1);\n\t  g = Math.min(Math.max(0, g), 1);\n\t  b = Math.min(Math.max(0, b), 1);\n\t\n\t  return [r * 255, g * 255, b * 255];\n\t}\n\t\n\tfunction xyz2lab(xyz) {\n\t  var x = xyz[0],\n\t      y = xyz[1],\n\t      z = xyz[2],\n\t      l, a, b;\n\t\n\t  x /= 95.047;\n\t  y /= 100;\n\t  z /= 108.883;\n\t\n\t  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n\t  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n\t  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\t\n\t  l = (116 * y) - 16;\n\t  a = 500 * (x - y);\n\t  b = 200 * (y - z);\n\t\n\t  return [l, a, b];\n\t}\n\t\n\tfunction xyz2lch(args) {\n\t  return lab2lch(xyz2lab(args));\n\t}\n\t\n\tfunction lab2xyz(lab) {\n\t  var l = lab[0],\n\t      a = lab[1],\n\t      b = lab[2],\n\t      x, y, z, y2;\n\t\n\t  if (l <= 8) {\n\t    y = (l * 100) / 903.3;\n\t    y2 = (7.787 * (y / 100)) + (16 / 116);\n\t  } else {\n\t    y = 100 * Math.pow((l + 16) / 116, 3);\n\t    y2 = Math.pow(y / 100, 1/3);\n\t  }\n\t\n\t  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\t\n\t  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\t\n\t  return [x, y, z];\n\t}\n\t\n\tfunction lab2lch(lab) {\n\t  var l = lab[0],\n\t      a = lab[1],\n\t      b = lab[2],\n\t      hr, h, c;\n\t\n\t  hr = Math.atan2(b, a);\n\t  h = hr * 360 / 2 / Math.PI;\n\t  if (h < 0) {\n\t    h += 360;\n\t  }\n\t  c = Math.sqrt(a * a + b * b);\n\t  return [l, c, h];\n\t}\n\t\n\tfunction lab2rgb(args) {\n\t  return xyz2rgb(lab2xyz(args));\n\t}\n\t\n\tfunction lch2lab(lch) {\n\t  var l = lch[0],\n\t      c = lch[1],\n\t      h = lch[2],\n\t      a, b, hr;\n\t\n\t  hr = h / 360 * 2 * Math.PI;\n\t  a = c * Math.cos(hr);\n\t  b = c * Math.sin(hr);\n\t  return [l, a, b];\n\t}\n\t\n\tfunction lch2xyz(args) {\n\t  return lab2xyz(lch2lab(args));\n\t}\n\t\n\tfunction lch2rgb(args) {\n\t  return lab2rgb(lch2lab(args));\n\t}\n\t\n\tfunction keyword2rgb(keyword) {\n\t  return cssKeywords[keyword];\n\t}\n\t\n\tfunction keyword2hsl(args) {\n\t  return rgb2hsl(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2hsv(args) {\n\t  return rgb2hsv(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2hwb(args) {\n\t  return rgb2hwb(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2cmyk(args) {\n\t  return rgb2cmyk(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2lab(args) {\n\t  return rgb2lab(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2xyz(args) {\n\t  return rgb2xyz(keyword2rgb(args));\n\t}\n\t\n\tvar cssKeywords = {\n\t  aliceblue:  [240,248,255],\n\t  antiquewhite: [250,235,215],\n\t  aqua: [0,255,255],\n\t  aquamarine: [127,255,212],\n\t  azure:  [240,255,255],\n\t  beige:  [245,245,220],\n\t  bisque: [255,228,196],\n\t  black:  [0,0,0],\n\t  blanchedalmond: [255,235,205],\n\t  blue: [0,0,255],\n\t  blueviolet: [138,43,226],\n\t  brown:  [165,42,42],\n\t  burlywood:  [222,184,135],\n\t  cadetblue:  [95,158,160],\n\t  chartreuse: [127,255,0],\n\t  chocolate:  [210,105,30],\n\t  coral:  [255,127,80],\n\t  cornflowerblue: [100,149,237],\n\t  cornsilk: [255,248,220],\n\t  crimson:  [220,20,60],\n\t  cyan: [0,255,255],\n\t  darkblue: [0,0,139],\n\t  darkcyan: [0,139,139],\n\t  darkgoldenrod:  [184,134,11],\n\t  darkgray: [169,169,169],\n\t  darkgreen:  [0,100,0],\n\t  darkgrey: [169,169,169],\n\t  darkkhaki:  [189,183,107],\n\t  darkmagenta:  [139,0,139],\n\t  darkolivegreen: [85,107,47],\n\t  darkorange: [255,140,0],\n\t  darkorchid: [153,50,204],\n\t  darkred:  [139,0,0],\n\t  darksalmon: [233,150,122],\n\t  darkseagreen: [143,188,143],\n\t  darkslateblue:  [72,61,139],\n\t  darkslategray:  [47,79,79],\n\t  darkslategrey:  [47,79,79],\n\t  darkturquoise:  [0,206,209],\n\t  darkviolet: [148,0,211],\n\t  deeppink: [255,20,147],\n\t  deepskyblue:  [0,191,255],\n\t  dimgray:  [105,105,105],\n\t  dimgrey:  [105,105,105],\n\t  dodgerblue: [30,144,255],\n\t  firebrick:  [178,34,34],\n\t  floralwhite:  [255,250,240],\n\t  forestgreen:  [34,139,34],\n\t  fuchsia:  [255,0,255],\n\t  gainsboro:  [220,220,220],\n\t  ghostwhite: [248,248,255],\n\t  gold: [255,215,0],\n\t  goldenrod:  [218,165,32],\n\t  gray: [128,128,128],\n\t  green:  [0,128,0],\n\t  greenyellow:  [173,255,47],\n\t  grey: [128,128,128],\n\t  honeydew: [240,255,240],\n\t  hotpink:  [255,105,180],\n\t  indianred:  [205,92,92],\n\t  indigo: [75,0,130],\n\t  ivory:  [255,255,240],\n\t  khaki:  [240,230,140],\n\t  lavender: [230,230,250],\n\t  lavenderblush:  [255,240,245],\n\t  lawngreen:  [124,252,0],\n\t  lemonchiffon: [255,250,205],\n\t  lightblue:  [173,216,230],\n\t  lightcoral: [240,128,128],\n\t  lightcyan:  [224,255,255],\n\t  lightgoldenrodyellow: [250,250,210],\n\t  lightgray:  [211,211,211],\n\t  lightgreen: [144,238,144],\n\t  lightgrey:  [211,211,211],\n\t  lightpink:  [255,182,193],\n\t  lightsalmon:  [255,160,122],\n\t  lightseagreen:  [32,178,170],\n\t  lightskyblue: [135,206,250],\n\t  lightslategray: [119,136,153],\n\t  lightslategrey: [119,136,153],\n\t  lightsteelblue: [176,196,222],\n\t  lightyellow:  [255,255,224],\n\t  lime: [0,255,0],\n\t  limegreen:  [50,205,50],\n\t  linen:  [250,240,230],\n\t  magenta:  [255,0,255],\n\t  maroon: [128,0,0],\n\t  mediumaquamarine: [102,205,170],\n\t  mediumblue: [0,0,205],\n\t  mediumorchid: [186,85,211],\n\t  mediumpurple: [147,112,219],\n\t  mediumseagreen: [60,179,113],\n\t  mediumslateblue:  [123,104,238],\n\t  mediumspringgreen:  [0,250,154],\n\t  mediumturquoise:  [72,209,204],\n\t  mediumvioletred:  [199,21,133],\n\t  midnightblue: [25,25,112],\n\t  mintcream:  [245,255,250],\n\t  mistyrose:  [255,228,225],\n\t  moccasin: [255,228,181],\n\t  navajowhite:  [255,222,173],\n\t  navy: [0,0,128],\n\t  oldlace:  [253,245,230],\n\t  olive:  [128,128,0],\n\t  olivedrab:  [107,142,35],\n\t  orange: [255,165,0],\n\t  orangered:  [255,69,0],\n\t  orchid: [218,112,214],\n\t  palegoldenrod:  [238,232,170],\n\t  palegreen:  [152,251,152],\n\t  paleturquoise:  [175,238,238],\n\t  palevioletred:  [219,112,147],\n\t  papayawhip: [255,239,213],\n\t  peachpuff:  [255,218,185],\n\t  peru: [205,133,63],\n\t  pink: [255,192,203],\n\t  plum: [221,160,221],\n\t  powderblue: [176,224,230],\n\t  purple: [128,0,128],\n\t  rebeccapurple: [102, 51, 153],\n\t  red:  [255,0,0],\n\t  rosybrown:  [188,143,143],\n\t  royalblue:  [65,105,225],\n\t  saddlebrown:  [139,69,19],\n\t  salmon: [250,128,114],\n\t  sandybrown: [244,164,96],\n\t  seagreen: [46,139,87],\n\t  seashell: [255,245,238],\n\t  sienna: [160,82,45],\n\t  silver: [192,192,192],\n\t  skyblue:  [135,206,235],\n\t  slateblue:  [106,90,205],\n\t  slategray:  [112,128,144],\n\t  slategrey:  [112,128,144],\n\t  snow: [255,250,250],\n\t  springgreen:  [0,255,127],\n\t  steelblue:  [70,130,180],\n\t  tan:  [210,180,140],\n\t  teal: [0,128,128],\n\t  thistle:  [216,191,216],\n\t  tomato: [255,99,71],\n\t  turquoise:  [64,224,208],\n\t  violet: [238,130,238],\n\t  wheat:  [245,222,179],\n\t  white:  [255,255,255],\n\t  whitesmoke: [245,245,245],\n\t  yellow: [255,255,0],\n\t  yellowgreen:  [154,205,50]\n\t};\n\t\n\tvar reverseKeywords = {};\n\tfor (var key in cssKeywords) {\n\t  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n\t}\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* MIT license */\r\n\tvar colorNames = __webpack_require__(9);\r\n\t\r\n\tmodule.exports = {\r\n\t   getRgba: getRgba,\r\n\t   getHsla: getHsla,\r\n\t   getRgb: getRgb,\r\n\t   getHsl: getHsl,\r\n\t   getHwb: getHwb,\r\n\t   getAlpha: getAlpha,\r\n\t\r\n\t   hexString: hexString,\r\n\t   rgbString: rgbString,\r\n\t   rgbaString: rgbaString,\r\n\t   percentString: percentString,\r\n\t   percentaString: percentaString,\r\n\t   hslString: hslString,\r\n\t   hslaString: hslaString,\r\n\t   hwbString: hwbString,\r\n\t   keyword: keyword\r\n\t}\r\n\t\r\n\tfunction getRgba(string) {\r\n\t   if (!string) {\r\n\t      return;\r\n\t   }\r\n\t   var abbr =  /^#([a-fA-F0-9]{3})$/,\r\n\t       hex =  /^#([a-fA-F0-9]{6})$/,\r\n\t       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n\t       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n\t       keyword = /(\\w+)/;\r\n\t\r\n\t   var rgb = [0, 0, 0],\r\n\t       a = 1,\r\n\t       match = string.match(abbr);\r\n\t   if (match) {\r\n\t      match = match[1];\r\n\t      for (var i = 0; i < rgb.length; i++) {\r\n\t         rgb[i] = parseInt(match[i] + match[i], 16);\r\n\t      }\r\n\t   }\r\n\t   else if (match = string.match(hex)) {\r\n\t      match = match[1];\r\n\t      for (var i = 0; i < rgb.length; i++) {\r\n\t         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\r\n\t      }\r\n\t   }\r\n\t   else if (match = string.match(rgba)) {\r\n\t      for (var i = 0; i < rgb.length; i++) {\r\n\t         rgb[i] = parseInt(match[i + 1]);\r\n\t      }\r\n\t      a = parseFloat(match[4]);\r\n\t   }\r\n\t   else if (match = string.match(per)) {\r\n\t      for (var i = 0; i < rgb.length; i++) {\r\n\t         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\r\n\t      }\r\n\t      a = parseFloat(match[4]);\r\n\t   }\r\n\t   else if (match = string.match(keyword)) {\r\n\t      if (match[1] == \"transparent\") {\r\n\t         return [0, 0, 0, 0];\r\n\t      }\r\n\t      rgb = colorNames[match[1]];\r\n\t      if (!rgb) {\r\n\t         return;\r\n\t      }\r\n\t   }\r\n\t\r\n\t   for (var i = 0; i < rgb.length; i++) {\r\n\t      rgb[i] = scale(rgb[i], 0, 255);\r\n\t   }\r\n\t   if (!a && a != 0) {\r\n\t      a = 1;\r\n\t   }\r\n\t   else {\r\n\t      a = scale(a, 0, 1);\r\n\t   }\r\n\t   rgb[3] = a;\r\n\t   return rgb;\r\n\t}\r\n\t\r\n\tfunction getHsla(string) {\r\n\t   if (!string) {\r\n\t      return;\r\n\t   }\r\n\t   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n\t   var match = string.match(hsl);\r\n\t   if (match) {\r\n\t      var alpha = parseFloat(match[4]);\r\n\t      var h = scale(parseInt(match[1]), 0, 360),\r\n\t          s = scale(parseFloat(match[2]), 0, 100),\r\n\t          l = scale(parseFloat(match[3]), 0, 100),\r\n\t          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n\t      return [h, s, l, a];\r\n\t   }\r\n\t}\r\n\t\r\n\tfunction getHwb(string) {\r\n\t   if (!string) {\r\n\t      return;\r\n\t   }\r\n\t   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n\t   var match = string.match(hwb);\r\n\t   if (match) {\r\n\t    var alpha = parseFloat(match[4]);\r\n\t      var h = scale(parseInt(match[1]), 0, 360),\r\n\t          w = scale(parseFloat(match[2]), 0, 100),\r\n\t          b = scale(parseFloat(match[3]), 0, 100),\r\n\t          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n\t      return [h, w, b, a];\r\n\t   }\r\n\t}\r\n\t\r\n\tfunction getRgb(string) {\r\n\t   var rgba = getRgba(string);\r\n\t   return rgba && rgba.slice(0, 3);\r\n\t}\r\n\t\r\n\tfunction getHsl(string) {\r\n\t  var hsla = getHsla(string);\r\n\t  return hsla && hsla.slice(0, 3);\r\n\t}\r\n\t\r\n\tfunction getAlpha(string) {\r\n\t   var vals = getRgba(string);\r\n\t   if (vals) {\r\n\t      return vals[3];\r\n\t   }\r\n\t   else if (vals = getHsla(string)) {\r\n\t      return vals[3];\r\n\t   }\r\n\t   else if (vals = getHwb(string)) {\r\n\t      return vals[3];\r\n\t   }\r\n\t}\r\n\t\r\n\t// generators\r\n\tfunction hexString(rgb) {\r\n\t   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\r\n\t              + hexDouble(rgb[2]);\r\n\t}\r\n\t\r\n\tfunction rgbString(rgba, alpha) {\r\n\t   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n\t      return rgbaString(rgba, alpha);\r\n\t   }\r\n\t   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\r\n\t}\r\n\t\r\n\tfunction rgbaString(rgba, alpha) {\r\n\t   if (alpha === undefined) {\r\n\t      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\r\n\t   }\r\n\t   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\r\n\t           + \", \" + alpha + \")\";\r\n\t}\r\n\t\r\n\tfunction percentString(rgba, alpha) {\r\n\t   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n\t      return percentaString(rgba, alpha);\r\n\t   }\r\n\t   var r = Math.round(rgba[0]/255 * 100),\r\n\t       g = Math.round(rgba[1]/255 * 100),\r\n\t       b = Math.round(rgba[2]/255 * 100);\r\n\t\r\n\t   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\r\n\t}\r\n\t\r\n\tfunction percentaString(rgba, alpha) {\r\n\t   var r = Math.round(rgba[0]/255 * 100),\r\n\t       g = Math.round(rgba[1]/255 * 100),\r\n\t       b = Math.round(rgba[2]/255 * 100);\r\n\t   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\r\n\t}\r\n\t\r\n\tfunction hslString(hsla, alpha) {\r\n\t   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\r\n\t      return hslaString(hsla, alpha);\r\n\t   }\r\n\t   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\r\n\t}\r\n\t\r\n\tfunction hslaString(hsla, alpha) {\r\n\t   if (alpha === undefined) {\r\n\t      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\r\n\t   }\r\n\t   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\r\n\t           + alpha + \")\";\r\n\t}\r\n\t\r\n\t// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\r\n\t// (hwb have alpha optional & 1 is default value)\r\n\tfunction hwbString(hwb, alpha) {\r\n\t   if (alpha === undefined) {\r\n\t      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\r\n\t   }\r\n\t   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\r\n\t           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\r\n\t}\r\n\t\r\n\tfunction keyword(rgb) {\r\n\t  return reverseNames[rgb.slice(0, 3)];\r\n\t}\r\n\t\r\n\t// helpers\r\n\tfunction scale(num, min, max) {\r\n\t   return Math.min(Math.max(min, num), max);\r\n\t}\r\n\t\r\n\tfunction hexDouble(num) {\r\n\t  var str = num.toString(16).toUpperCase();\r\n\t  return (str.length < 2) ? \"0\" + str : str;\r\n\t}\r\n\t\r\n\t\r\n\t//create a list of reverse color names\r\n\tvar reverseNames = {};\r\n\tfor (var name in colorNames) {\r\n\t   reverseNames[colorNames[name]] = name;\r\n\t}\r\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\r\n\t\t\"aliceblue\": [240, 248, 255],\r\n\t\t\"antiquewhite\": [250, 235, 215],\r\n\t\t\"aqua\": [0, 255, 255],\r\n\t\t\"aquamarine\": [127, 255, 212],\r\n\t\t\"azure\": [240, 255, 255],\r\n\t\t\"beige\": [245, 245, 220],\r\n\t\t\"bisque\": [255, 228, 196],\r\n\t\t\"black\": [0, 0, 0],\r\n\t\t\"blanchedalmond\": [255, 235, 205],\r\n\t\t\"blue\": [0, 0, 255],\r\n\t\t\"blueviolet\": [138, 43, 226],\r\n\t\t\"brown\": [165, 42, 42],\r\n\t\t\"burlywood\": [222, 184, 135],\r\n\t\t\"cadetblue\": [95, 158, 160],\r\n\t\t\"chartreuse\": [127, 255, 0],\r\n\t\t\"chocolate\": [210, 105, 30],\r\n\t\t\"coral\": [255, 127, 80],\r\n\t\t\"cornflowerblue\": [100, 149, 237],\r\n\t\t\"cornsilk\": [255, 248, 220],\r\n\t\t\"crimson\": [220, 20, 60],\r\n\t\t\"cyan\": [0, 255, 255],\r\n\t\t\"darkblue\": [0, 0, 139],\r\n\t\t\"darkcyan\": [0, 139, 139],\r\n\t\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\t\"darkgray\": [169, 169, 169],\r\n\t\t\"darkgreen\": [0, 100, 0],\r\n\t\t\"darkgrey\": [169, 169, 169],\r\n\t\t\"darkkhaki\": [189, 183, 107],\r\n\t\t\"darkmagenta\": [139, 0, 139],\r\n\t\t\"darkolivegreen\": [85, 107, 47],\r\n\t\t\"darkorange\": [255, 140, 0],\r\n\t\t\"darkorchid\": [153, 50, 204],\r\n\t\t\"darkred\": [139, 0, 0],\r\n\t\t\"darksalmon\": [233, 150, 122],\r\n\t\t\"darkseagreen\": [143, 188, 143],\r\n\t\t\"darkslateblue\": [72, 61, 139],\r\n\t\t\"darkslategray\": [47, 79, 79],\r\n\t\t\"darkslategrey\": [47, 79, 79],\r\n\t\t\"darkturquoise\": [0, 206, 209],\r\n\t\t\"darkviolet\": [148, 0, 211],\r\n\t\t\"deeppink\": [255, 20, 147],\r\n\t\t\"deepskyblue\": [0, 191, 255],\r\n\t\t\"dimgray\": [105, 105, 105],\r\n\t\t\"dimgrey\": [105, 105, 105],\r\n\t\t\"dodgerblue\": [30, 144, 255],\r\n\t\t\"firebrick\": [178, 34, 34],\r\n\t\t\"floralwhite\": [255, 250, 240],\r\n\t\t\"forestgreen\": [34, 139, 34],\r\n\t\t\"fuchsia\": [255, 0, 255],\r\n\t\t\"gainsboro\": [220, 220, 220],\r\n\t\t\"ghostwhite\": [248, 248, 255],\r\n\t\t\"gold\": [255, 215, 0],\r\n\t\t\"goldenrod\": [218, 165, 32],\r\n\t\t\"gray\": [128, 128, 128],\r\n\t\t\"green\": [0, 128, 0],\r\n\t\t\"greenyellow\": [173, 255, 47],\r\n\t\t\"grey\": [128, 128, 128],\r\n\t\t\"honeydew\": [240, 255, 240],\r\n\t\t\"hotpink\": [255, 105, 180],\r\n\t\t\"indianred\": [205, 92, 92],\r\n\t\t\"indigo\": [75, 0, 130],\r\n\t\t\"ivory\": [255, 255, 240],\r\n\t\t\"khaki\": [240, 230, 140],\r\n\t\t\"lavender\": [230, 230, 250],\r\n\t\t\"lavenderblush\": [255, 240, 245],\r\n\t\t\"lawngreen\": [124, 252, 0],\r\n\t\t\"lemonchiffon\": [255, 250, 205],\r\n\t\t\"lightblue\": [173, 216, 230],\r\n\t\t\"lightcoral\": [240, 128, 128],\r\n\t\t\"lightcyan\": [224, 255, 255],\r\n\t\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\t\"lightgray\": [211, 211, 211],\r\n\t\t\"lightgreen\": [144, 238, 144],\r\n\t\t\"lightgrey\": [211, 211, 211],\r\n\t\t\"lightpink\": [255, 182, 193],\r\n\t\t\"lightsalmon\": [255, 160, 122],\r\n\t\t\"lightseagreen\": [32, 178, 170],\r\n\t\t\"lightskyblue\": [135, 206, 250],\r\n\t\t\"lightslategray\": [119, 136, 153],\r\n\t\t\"lightslategrey\": [119, 136, 153],\r\n\t\t\"lightsteelblue\": [176, 196, 222],\r\n\t\t\"lightyellow\": [255, 255, 224],\r\n\t\t\"lime\": [0, 255, 0],\r\n\t\t\"limegreen\": [50, 205, 50],\r\n\t\t\"linen\": [250, 240, 230],\r\n\t\t\"magenta\": [255, 0, 255],\r\n\t\t\"maroon\": [128, 0, 0],\r\n\t\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\t\"mediumblue\": [0, 0, 205],\r\n\t\t\"mediumorchid\": [186, 85, 211],\r\n\t\t\"mediumpurple\": [147, 112, 219],\r\n\t\t\"mediumseagreen\": [60, 179, 113],\r\n\t\t\"mediumslateblue\": [123, 104, 238],\r\n\t\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\t\"mediumturquoise\": [72, 209, 204],\r\n\t\t\"mediumvioletred\": [199, 21, 133],\r\n\t\t\"midnightblue\": [25, 25, 112],\r\n\t\t\"mintcream\": [245, 255, 250],\r\n\t\t\"mistyrose\": [255, 228, 225],\r\n\t\t\"moccasin\": [255, 228, 181],\r\n\t\t\"navajowhite\": [255, 222, 173],\r\n\t\t\"navy\": [0, 0, 128],\r\n\t\t\"oldlace\": [253, 245, 230],\r\n\t\t\"olive\": [128, 128, 0],\r\n\t\t\"olivedrab\": [107, 142, 35],\r\n\t\t\"orange\": [255, 165, 0],\r\n\t\t\"orangered\": [255, 69, 0],\r\n\t\t\"orchid\": [218, 112, 214],\r\n\t\t\"palegoldenrod\": [238, 232, 170],\r\n\t\t\"palegreen\": [152, 251, 152],\r\n\t\t\"paleturquoise\": [175, 238, 238],\r\n\t\t\"palevioletred\": [219, 112, 147],\r\n\t\t\"papayawhip\": [255, 239, 213],\r\n\t\t\"peachpuff\": [255, 218, 185],\r\n\t\t\"peru\": [205, 133, 63],\r\n\t\t\"pink\": [255, 192, 203],\r\n\t\t\"plum\": [221, 160, 221],\r\n\t\t\"powderblue\": [176, 224, 230],\r\n\t\t\"purple\": [128, 0, 128],\r\n\t\t\"rebeccapurple\": [102, 51, 153],\r\n\t\t\"red\": [255, 0, 0],\r\n\t\t\"rosybrown\": [188, 143, 143],\r\n\t\t\"royalblue\": [65, 105, 225],\r\n\t\t\"saddlebrown\": [139, 69, 19],\r\n\t\t\"salmon\": [250, 128, 114],\r\n\t\t\"sandybrown\": [244, 164, 96],\r\n\t\t\"seagreen\": [46, 139, 87],\r\n\t\t\"seashell\": [255, 245, 238],\r\n\t\t\"sienna\": [160, 82, 45],\r\n\t\t\"silver\": [192, 192, 192],\r\n\t\t\"skyblue\": [135, 206, 235],\r\n\t\t\"slateblue\": [106, 90, 205],\r\n\t\t\"slategray\": [112, 128, 144],\r\n\t\t\"slategrey\": [112, 128, 144],\r\n\t\t\"snow\": [255, 250, 250],\r\n\t\t\"springgreen\": [0, 255, 127],\r\n\t\t\"steelblue\": [70, 130, 180],\r\n\t\t\"tan\": [210, 180, 140],\r\n\t\t\"teal\": [0, 128, 128],\r\n\t\t\"thistle\": [216, 191, 216],\r\n\t\t\"tomato\": [255, 99, 71],\r\n\t\t\"turquoise\": [64, 224, 208],\r\n\t\t\"violet\": [238, 130, 238],\r\n\t\t\"wheat\": [245, 222, 179],\r\n\t\t\"white\": [255, 255, 255],\r\n\t\t\"whitesmoke\": [245, 245, 245],\r\n\t\t\"yellow\": [255, 255, 0],\r\n\t\t\"yellowgreen\": [154, 205, 50]\r\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\t// Global Chart canvas helpers object for drawing items to canvas\n\t\tvar helpers = Chart.canvasHelpers = {};\n\t\n\t\thelpers.drawPoint = function(ctx, pointStyle, radius, x, y) {\n\t\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\t\n\t\t\tif (typeof pointStyle === 'object') {\n\t\t\t\ttype = pointStyle.toString();\n\t\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\t\tctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tswitch (pointStyle) {\n\t\t\t// Default includes circle\n\t\t\tdefault:\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fill();\n\t\t\t\tbreak;\n\t\t\tcase 'triangle':\n\t\t\t\tctx.beginPath();\n\t\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fill();\n\t\t\t\tbreak;\n\t\t\tcase 'rect':\n\t\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\t\tbreak;\n\t\t\tcase 'rectRot':\n\t\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(x - size, y);\n\t\t\t\tctx.lineTo(x, y + size);\n\t\t\t\tctx.lineTo(x + size, y);\n\t\t\t\tctx.lineTo(x, y - size);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fill();\n\t\t\t\tbreak;\n\t\t\tcase 'cross':\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(x, y + radius);\n\t\t\t\tctx.lineTo(x, y - radius);\n\t\t\t\tctx.moveTo(x - radius, y);\n\t\t\t\tctx.lineTo(x + radius, y);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\tcase 'crossRot':\n\t\t\t\tctx.beginPath();\n\t\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\tcase 'star':\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(x, y + radius);\n\t\t\t\tctx.lineTo(x, y - radius);\n\t\t\t\tctx.moveTo(x - radius, y);\n\t\t\t\tctx.lineTo(x + radius, y);\n\t\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\tcase 'line':\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(x - radius, y);\n\t\t\t\tctx.lineTo(x + radius, y);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\tcase 'dash':\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(x, y);\n\t\t\t\tctx.lineTo(x + radius, y);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\t}\n\t\n\t\t\tctx.stroke();\n\t\t};\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.elements = {};\n\t\n\t\tChart.Element = function(configuration) {\n\t\t\thelpers.extend(this, configuration);\n\t\t\tthis.initialize.apply(this, arguments);\n\t\t};\n\t\n\t\thelpers.extend(Chart.Element.prototype, {\n\t\n\t\t\tinitialize: function() {\n\t\t\t\tthis.hidden = false;\n\t\t\t},\n\t\n\t\t\tpivot: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tif (!me._view) {\n\t\t\t\t\tme._view = helpers.clone(me._model);\n\t\t\t\t}\n\t\t\t\tme._start = helpers.clone(me._view);\n\t\t\t\treturn me;\n\t\t\t},\n\t\n\t\t\ttransition: function(ease) {\n\t\t\t\tvar me = this;\n\t\n\t\t\t\tif (!me._view) {\n\t\t\t\t\tme._view = helpers.clone(me._model);\n\t\t\t\t}\n\t\n\t\t\t\t// No animation -> No Transition\n\t\t\t\tif (ease === 1) {\n\t\t\t\t\tme._view = me._model;\n\t\t\t\t\tme._start = null;\n\t\t\t\t\treturn me;\n\t\t\t\t}\n\t\n\t\t\t\tif (!me._start) {\n\t\t\t\t\tme.pivot();\n\t\t\t\t}\n\t\n\t\t\t\thelpers.each(me._model, function(value, key) {\n\t\n\t\t\t\t\tif (key[0] === '_') {\n\t\t\t\t\t\t// Only non-underscored properties\n\t\t\t\t\t// Init if doesn't exist\n\t\t\t\t\t} else if (!me._view.hasOwnProperty(key)) {\n\t\t\t\t\t\tif (typeof value === 'number' && !isNaN(me._view[key])) {\n\t\t\t\t\t\t\tme._view[key] = value * ease;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme._view[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t// No unnecessary computations\n\t\t\t\t\t} else if (value === me._view[key]) {\n\t\t\t\t\t\t// It's the same! Woohoo!\n\t\t\t\t\t// Color transitions if possible\n\t\t\t\t\t} else if (typeof value === 'string') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);\n\t\t\t\t\t\t\tme._view[key] = color.rgbString();\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tme._view[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t// Number transitions\n\t\t\t\t\t} else if (typeof value === 'number') {\n\t\t\t\t\t\tvar startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;\n\t\t\t\t\t\tme._view[key] = ((me._model[key] - startVal) * ease) + startVal;\n\t\t\t\t\t// Everything else\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme._view[key] = value;\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\t\n\t\t\t\treturn me;\n\t\t\t},\n\t\n\t\t\ttooltipPosition: function() {\n\t\t\t\treturn {\n\t\t\t\t\tx: this._model.x,\n\t\t\t\t\ty: this._model.y\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\thasValue: function() {\n\t\t\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t\t\t}\n\t\t});\n\t\n\t\tChart.Element.extend = helpers.inherits;\n\t\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/* global window: false */\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.global.animation = {\n\t\t\tduration: 1000,\n\t\t\teasing: 'easeOutQuart',\n\t\t\tonProgress: helpers.noop,\n\t\t\tonComplete: helpers.noop\n\t\t};\n\t\n\t\tChart.Animation = Chart.Element.extend({\n\t\t\tcurrentStep: null, // the current animation step\n\t\t\tnumSteps: 60, // default number of steps\n\t\t\teasing: '', // the easing to use for this animation\n\t\t\trender: null, // render function used by the animation service\n\t\n\t\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\t\tonAnimationComplete: null // user specified callback to fire when the animation finishes\n\t\t});\n\t\n\t\tChart.animationService = {\n\t\t\tframeDuration: 17,\n\t\t\tanimations: [],\n\t\t\tdropFrames: 0,\n\t\t\trequest: null,\n\t\t\taddAnimation: function(chartInstance, animationObject, duration, lazy) {\n\t\t\t\tvar me = this;\n\t\n\t\t\t\tif (!lazy) {\n\t\t\t\t\tchartInstance.animating = true;\n\t\t\t\t}\n\t\n\t\t\t\tfor (var index = 0; index < me.animations.length; ++index) {\n\t\t\t\t\tif (me.animations[index].chartInstance === chartInstance) {\n\t\t\t\t\t\t// replacing an in progress animation\n\t\t\t\t\t\tme.animations[index].animationObject = animationObject;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tme.animations.push({\n\t\t\t\t\tchartInstance: chartInstance,\n\t\t\t\t\tanimationObject: animationObject\n\t\t\t\t});\n\t\n\t\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\t\tif (me.animations.length === 1) {\n\t\t\t\t\tme.requestAnimationFrame();\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Cancel the animation for a given chart instance\n\t\t\tcancelAnimation: function(chartInstance) {\n\t\t\t\tvar index = helpers.findIndex(this.animations, function(animationWrapper) {\n\t\t\t\t\treturn animationWrapper.chartInstance === chartInstance;\n\t\t\t\t});\n\t\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\t\tchartInstance.animating = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\trequestAnimationFrame: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tif (me.request === null) {\n\t\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\t\tme.request = null;\n\t\t\t\t\t\tme.startDigest();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tstartDigest: function() {\n\t\t\t\tvar me = this;\n\t\n\t\t\t\tvar startTime = Date.now();\n\t\t\t\tvar framesToDrop = 0;\n\t\n\t\t\t\tif (me.dropFrames > 1) {\n\t\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t\t}\n\t\n\t\t\t\tvar i = 0;\n\t\t\t\twhile (i < me.animations.length) {\n\t\t\t\t\tif (me.animations[i].animationObject.currentStep === null) {\n\t\t\t\t\t\tme.animations[i].animationObject.currentStep = 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tme.animations[i].animationObject.currentStep += 1 + framesToDrop;\n\t\n\t\t\t\t\tif (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {\n\t\t\t\t\t\tme.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tme.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);\n\t\t\t\t\tif (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {\n\t\t\t\t\t\tme.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {\n\t\t\t\t\t\tif (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {\n\t\t\t\t\t\t\tme.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// executed the last frame. Remove the animation.\n\t\t\t\t\t\tme.animations[i].chartInstance.animating = false;\n\t\n\t\t\t\t\t\tme.animations.splice(i, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar endTime = Date.now();\n\t\t\t\tvar dropFrames = (endTime - startTime) / me.frameDuration;\n\t\n\t\t\t\tme.dropFrames += dropFrames;\n\t\n\t\t\t\t// Do we have more stuff to animate?\n\t\t\t\tif (me.animations.length > 0) {\n\t\t\t\t\tme.requestAnimationFrame();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\t// Create a dictionary of chart types, to allow for extension of existing types\n\t\tChart.types = {};\n\t\n\t\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\t\tChart.instances = {};\n\t\n\t\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\t\tChart.controllers = {};\n\t\n\t\t/**\n\t\t * @class Chart.Controller\n\t\t * The main controller of a chart.\n\t\t */\n\t\tChart.Controller = function(instance) {\n\t\n\t\t\tthis.chart = instance;\n\t\t\tthis.config = instance.config;\n\t\t\tthis.options = this.config.options = helpers.configMerge(Chart.defaults.global, Chart.defaults[this.config.type], this.config.options || {});\n\t\t\tthis.id = helpers.uid();\n\t\n\t\t\tObject.defineProperty(this, 'data', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.config.data;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t// Add the chart instance to the global namespace\n\t\t\tChart.instances[this.id] = this;\n\t\n\t\t\tif (this.options.responsive) {\n\t\t\t\t// Silent resize before chart draws\n\t\t\t\tthis.resize(true);\n\t\t\t}\n\t\n\t\t\tthis.initialize();\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\thelpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller */ {\n\t\n\t\t\tinitialize: function() {\n\t\t\t\tvar me = this;\n\t\t\t\t// Before init plugin notification\n\t\t\t\tChart.plugins.notify('beforeInit', [me]);\n\t\n\t\t\t\tme.bindEvents();\n\t\n\t\t\t\t// Make sure controllers are built first so that each dataset is bound to an axis before the scales\n\t\t\t\t// are built\n\t\t\t\tme.ensureScalesHaveIDs();\n\t\t\t\tme.buildOrUpdateControllers();\n\t\t\t\tme.buildScales();\n\t\t\t\tme.updateLayout();\n\t\t\t\tme.resetElements();\n\t\t\t\tme.initToolTip();\n\t\t\t\tme.update();\n\t\n\t\t\t\t// After init plugin notification\n\t\t\t\tChart.plugins.notify('afterInit', [me]);\n\t\n\t\t\t\treturn me;\n\t\t\t},\n\t\n\t\t\tclear: function() {\n\t\t\t\thelpers.clear(this.chart);\n\t\t\t\treturn this;\n\t\t\t},\n\t\n\t\t\tstop: function() {\n\t\t\t\t// Stops any current animation loop occuring\n\t\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\t\treturn this;\n\t\t\t},\n\t\n\t\t\tresize: function(silent) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tvar canvas = chart.canvas;\n\t\t\t\tvar newWidth = helpers.getMaximumWidth(canvas);\n\t\t\t\tvar aspectRatio = chart.aspectRatio;\n\t\t\t\tvar newHeight = (me.options.maintainAspectRatio && isNaN(aspectRatio) === false && isFinite(aspectRatio) && aspectRatio !== 0) ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas);\n\t\n\t\t\t\tvar sizeChanged = chart.width !== newWidth || chart.height !== newHeight;\n\t\n\t\t\t\tif (!sizeChanged) {\n\t\t\t\t\treturn me;\n\t\t\t\t}\n\t\n\t\t\t\tcanvas.width = chart.width = newWidth;\n\t\t\t\tcanvas.height = chart.height = newHeight;\n\t\n\t\t\t\thelpers.retinaScale(chart);\n\t\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tChart.plugins.notify('resize', [me, newSize]);\n\t\n\t\t\t\t// Notify of resize\n\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t}\n\t\n\t\t\t\tif (!silent) {\n\t\t\t\t\tme.stop();\n\t\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t\t}\n\t\n\t\t\t\treturn me;\n\t\t\t},\n\t\n\t\t\tensureScalesHaveIDs: function() {\n\t\t\t\tvar options = this.options;\n\t\t\t\tvar scalesOptions = options.scales || {};\n\t\t\t\tvar scaleOptions = options.scale;\n\t\n\t\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t\t});\n\t\n\t\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t\t});\n\t\n\t\t\t\tif (scaleOptions) {\n\t\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t\t */\n\t\t\tbuildScales: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar options = me.options;\n\t\t\t\tvar scales = me.scales = {};\n\t\t\t\tvar items = [];\n\t\n\t\t\t\tif (options.scales) {\n\t\t\t\t\titems = items.concat(\n\t\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category'};\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear'};\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\n\t\t\t\tif (options.scale) {\n\t\t\t\t\titems.push({options: options.scale, dtype: 'radialLinear', isDefault: true});\n\t\t\t\t}\n\t\n\t\t\t\thelpers.each(items, function(item) {\n\t\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\t\tvar scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\n\t\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\t\tif (!scaleClass) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar scale = new scaleClass({\n\t\t\t\t\t\tid: scaleOptions.id,\n\t\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\t\tctx: me.chart.ctx,\n\t\t\t\t\t\tchart: me\n\t\t\t\t\t});\n\t\n\t\t\t\t\tscales[scale.id] = scale;\n\t\n\t\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\t\tif (item.isDefault) {\n\t\t\t\t\t\tme.scale = scale;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t\t},\n\t\n\t\t\tupdateLayout: function() {\n\t\t\t\tChart.layoutService.update(this, this.chart.width, this.chart.height);\n\t\t\t},\n\t\n\t\t\tbuildOrUpdateControllers: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar types = [];\n\t\t\t\tvar newControllers = [];\n\t\n\t\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (!meta.type) {\n\t\t\t\t\t\tmeta.type = dataset.type || me.config.type;\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttypes.push(meta.type);\n\t\n\t\t\t\t\tif (meta.controller) {\n\t\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmeta.controller = new Chart.controllers[meta.type](me, datasetIndex);\n\t\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\t\n\t\t\t\tif (types.length > 1) {\n\t\t\t\t\tfor (var i = 1; i < types.length; i++) {\n\t\t\t\t\t\tif (types[i] !== types[i - 1]) {\n\t\t\t\t\t\t\tme.isCombo = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn newControllers;\n\t\t\t},\n\t\n\t\t\tresetElements: function() {\n\t\t\t\tvar me = this;\n\t\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t\t}, me);\n\t\t\t},\n\t\n\t\t\tupdate: function(animationDuration, lazy) {\n\t\t\t\tvar me = this;\n\t\t\t\tChart.plugins.notify('beforeUpdate', [me]);\n\t\n\t\t\t\t// In case the entire data object changed\n\t\t\t\tme.tooltip._data = me.data;\n\t\n\t\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\t\n\t\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t\t}, me);\n\t\n\t\t\t\tChart.layoutService.update(me, me.chart.width, me.chart.height);\n\t\n\t\t\t\t// Apply changes to the dataets that require the scales to have been calculated i.e BorderColor chages\n\t\t\t\tChart.plugins.notify('afterScaleUpdate', [me]);\n\t\n\t\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\t\thelpers.each(newControllers, function(controller) {\n\t\t\t\t\tcontroller.reset();\n\t\t\t\t});\n\t\n\t\t\t\tme.updateDatasets();\n\t\n\t\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\t\tChart.plugins.notify('afterUpdate', [me]);\n\t\n\t\t\t\tme.render(animationDuration, lazy);\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * @method beforeDatasetsUpdate\n\t\t\t * @description Called before all datasets are updated. If a plugin returns false,\n\t\t\t * the datasets update will be cancelled until another chart update is triggered.\n\t\t\t * @param {Object} instance the chart instance being updated.\n\t\t\t * @returns {Boolean} false to cancel the datasets update.\n\t\t\t * @memberof Chart.PluginBase\n\t\t\t * @since version 2.1.5\n\t\t\t * @instance\n\t\t\t */\n\t\n\t\t\t/**\n\t\t\t * @method afterDatasetsUpdate\n\t\t\t * @description Called after all datasets have been updated. Note that this\n\t\t\t * extension will not be called if the datasets update has been cancelled.\n\t\t\t * @param {Object} instance the chart instance being updated.\n\t\t\t * @memberof Chart.PluginBase\n\t\t\t * @since version 2.1.5\n\t\t\t * @instance\n\t\t\t */\n\t\n\t\t\t/**\n\t\t\t * Updates all datasets unless a plugin returns false to the beforeDatasetsUpdate\n\t\t\t * extension, in which case no datasets will be updated and the afterDatasetsUpdate\n\t\t\t * notification will be skipped.\n\t\t\t * @protected\n\t\t\t * @instance\n\t\t\t */\n\t\t\tupdateDatasets: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar i, ilen;\n\t\n\t\t\t\tif (Chart.plugins.notify('beforeDatasetsUpdate', [me])) {\n\t\t\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\t\t\tme.getDatasetMeta(i).controller.update();\n\t\t\t\t\t}\n\t\n\t\t\t\t\tChart.plugins.notify('afterDatasetsUpdate', [me]);\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\trender: function(duration, lazy) {\n\t\t\t\tvar me = this;\n\t\t\t\tChart.plugins.notify('beforeRender', [me]);\n\t\n\t\t\t\tvar animationOptions = me.options.animation;\n\t\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n\t\t\t\t\tvar animation = new Chart.Animation();\n\t\t\t\t\tanimation.numSteps = (duration || animationOptions.duration) / 16.66; // 60 fps\n\t\t\t\t\tanimation.easing = animationOptions.easing;\n\t\n\t\t\t\t\t// render function\n\t\t\t\t\tanimation.render = function(chartInstance, animationObject) {\n\t\t\t\t\t\tvar easingFunction = helpers.easingEffects[animationObject.easing];\n\t\t\t\t\t\tvar stepDecimal = animationObject.currentStep / animationObject.numSteps;\n\t\t\t\t\t\tvar easeDecimal = easingFunction(stepDecimal);\n\t\n\t\t\t\t\t\tchartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// user events\n\t\t\t\t\tanimation.onAnimationProgress = animationOptions.onProgress;\n\t\t\t\t\tanimation.onAnimationComplete = animationOptions.onComplete;\n\t\n\t\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t\t} else {\n\t\t\t\t\tme.draw();\n\t\t\t\t\tif (animationOptions && animationOptions.onComplete && animationOptions.onComplete.call) {\n\t\t\t\t\t\tanimationOptions.onComplete.call(me);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn me;\n\t\t\t},\n\t\n\t\t\tdraw: function(ease) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar easingDecimal = ease || 1;\n\t\t\t\tme.clear();\n\t\n\t\t\t\tChart.plugins.notify('beforeDraw', [me, easingDecimal]);\n\t\n\t\t\t\t// Draw all the scales\n\t\t\t\thelpers.each(me.boxes, function(box) {\n\t\t\t\t\tbox.draw(me.chartArea);\n\t\t\t\t}, me);\n\t\t\t\tif (me.scale) {\n\t\t\t\t\tme.scale.draw();\n\t\t\t\t}\n\t\n\t\t\t\tChart.plugins.notify('beforeDatasetsDraw', [me, easingDecimal]);\n\t\n\t\t\t\t// Draw each dataset via its respective controller (reversed to support proper line stacking)\n\t\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\tme.getDatasetMeta(datasetIndex).controller.draw(ease);\n\t\t\t\t\t}\n\t\t\t\t}, me, true);\n\t\n\t\t\t\tChart.plugins.notify('afterDatasetsDraw', [me, easingDecimal]);\n\t\n\t\t\t\t// Finally draw the tooltip\n\t\t\t\tme.tooltip.transition(easingDecimal).draw();\n\t\n\t\t\t\tChart.plugins.notify('afterDraw', [me, easingDecimal]);\n\t\t\t},\n\t\n\t\t\t// Get the single element that was clicked on\n\t\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\t\tgetElementAtEvent: function(e) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar eventPosition = helpers.getRelativePosition(e, me.chart);\n\t\t\t\tvar elementsArray = [];\n\t\n\t\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\thelpers.each(meta.data, function(element) {\n\t\t\t\t\t\t\tif (element.inRange(eventPosition.x, eventPosition.y)) {\n\t\t\t\t\t\t\t\telementsArray.push(element);\n\t\t\t\t\t\t\t\treturn elementsArray;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\treturn elementsArray.slice(0, 1);\n\t\t\t},\n\t\n\t\t\tgetElementsAtEvent: function(e) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar eventPosition = helpers.getRelativePosition(e, me.chart);\n\t\t\t\tvar elementsArray = [];\n\t\n\t\t\t\tvar found = function() {\n\t\t\t\t\tif (me.data.datasets) {\n\t\t\t\t\t\tfor (var i = 0; i < me.data.datasets.length; i++) {\n\t\t\t\t\t\t\tvar meta = me.getDatasetMeta(i);\n\t\t\t\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\t\t\t\tfor (var j = 0; j < meta.data.length; j++) {\n\t\t\t\t\t\t\t\t\tif (meta.data[j].inRange(eventPosition.x, eventPosition.y)) {\n\t\t\t\t\t\t\t\t\t\treturn meta.data[j];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.call(me);\n\t\n\t\t\t\tif (!found) {\n\t\t\t\t\treturn elementsArray;\n\t\t\t\t}\n\t\n\t\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex),\n\t\t\t\t\t\t\telement = meta.data[found._index];\n\t\t\t\t\t\tif (element && !element._view.skip) {\n\t\t\t\t\t\t\telementsArray.push(element);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\t\n\t\t\t\treturn elementsArray;\n\t\t\t},\n\t\n\t\t\tgetElementsAtXAxis: function(e) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar eventPosition = helpers.getRelativePosition(e, me.chart);\n\t\t\t\tvar elementsArray = [];\n\t\n\t\t\t\tvar found = function() {\n\t\t\t\t\tif (me.data.datasets) {\n\t\t\t\t\t\tfor (var i = 0; i < me.data.datasets.length; i++) {\n\t\t\t\t\t\t\tvar meta = me.getDatasetMeta(i);\n\t\t\t\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\t\t\t\tfor (var j = 0; j < meta.data.length; j++) {\n\t\t\t\t\t\t\t\t\tif (meta.data[j].inLabelRange(eventPosition.x, eventPosition.y)) {\n\t\t\t\t\t\t\t\t\t\treturn meta.data[j];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.call(me);\n\t\n\t\t\t\tif (!found) {\n\t\t\t\t\treturn elementsArray;\n\t\t\t\t}\n\t\n\t\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\tvar index = helpers.findIndex(meta.data, function(it) {\n\t\t\t\t\t\t\treturn found._model.x === it._model.x;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (index !== -1 && !meta.data[index]._view.skip) {\n\t\t\t\t\t\t\telementsArray.push(meta.data[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\t\n\t\t\t\treturn elementsArray;\n\t\t\t},\n\t\n\t\t\tgetElementsAtEventForMode: function(e, mode) {\n\t\t\t\tvar me = this;\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase 'single':\n\t\t\t\t\treturn me.getElementAtEvent(e);\n\t\t\t\tcase 'label':\n\t\t\t\t\treturn me.getElementsAtEvent(e);\n\t\t\t\tcase 'dataset':\n\t\t\t\t\treturn me.getDatasetAtEvent(e);\n\t\t\t\tcase 'x-axis':\n\t\t\t\t\treturn me.getElementsAtXAxis(e);\n\t\t\t\tdefault:\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tgetDatasetAtEvent: function(e) {\n\t\t\t\tvar elementsArray = this.getElementAtEvent(e);\n\t\n\t\t\t\tif (elementsArray.length > 0) {\n\t\t\t\t\telementsArray = this.getDatasetMeta(elementsArray[0]._datasetIndex).data;\n\t\t\t\t}\n\t\n\t\t\t\treturn elementsArray;\n\t\t\t},\n\t\n\t\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\t\tif (!dataset._meta) {\n\t\t\t\t\tdataset._meta = {};\n\t\t\t\t}\n\t\n\t\t\t\tvar meta = dataset._meta[me.id];\n\t\t\t\tif (!meta) {\n\t\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\tdata: [],\n\t\t\t\t\t\tdataset: null,\n\t\t\t\t\t\tcontroller: null,\n\t\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\t\txAxisID: null,\n\t\t\t\t\t\tyAxisID: null\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\treturn meta;\n\t\t\t},\n\t\n\t\t\tgetVisibleDatasetCount: function() {\n\t\t\t\tvar count = 0;\n\t\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {\n\t\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn count;\n\t\t\t},\n\t\n\t\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\t\n\t\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\t\treturn typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t\t},\n\t\n\t\t\tgenerateLegend: function() {\n\t\t\t\treturn this.options.legendCallback(this);\n\t\t\t},\n\t\n\t\t\tdestroy: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tme.stop();\n\t\t\t\tme.clear();\n\t\t\t\thelpers.unbindEvents(me, me.events);\n\t\t\t\thelpers.removeResizeListener(me.chart.canvas.parentNode);\n\t\n\t\t\t\t// Reset canvas height/width attributes\n\t\t\t\tvar canvas = me.chart.canvas;\n\t\t\t\tcanvas.width = me.chart.width;\n\t\t\t\tcanvas.height = me.chart.height;\n\t\n\t\t\t\t// if we scaled the canvas in response to a devicePixelRatio !== 1, we need to undo that transform here\n\t\t\t\tif (me.chart.originalDevicePixelRatio !== undefined) {\n\t\t\t\t\tme.chart.ctx.scale(1 / me.chart.originalDevicePixelRatio, 1 / me.chart.originalDevicePixelRatio);\n\t\t\t\t}\n\t\n\t\t\t\t// Reset to the old style since it may have been changed by the device pixel ratio changes\n\t\t\t\tcanvas.style.width = me.chart.originalCanvasStyleWidth;\n\t\t\t\tcanvas.style.height = me.chart.originalCanvasStyleHeight;\n\t\n\t\t\t\tChart.plugins.notify('destroy', [me]);\n\t\n\t\t\t\tdelete Chart.instances[me.id];\n\t\t\t},\n\t\n\t\t\ttoBase64Image: function() {\n\t\t\t\treturn this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\n\t\t\t},\n\t\n\t\t\tinitToolTip: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t\t_chart: me.chart,\n\t\t\t\t\t_chartInstance: me,\n\t\t\t\t\t_data: me.data,\n\t\t\t\t\t_options: me.options.tooltips\n\t\t\t\t}, me);\n\t\t\t},\n\t\n\t\t\tbindEvents: function() {\n\t\t\t\tvar me = this;\n\t\t\t\thelpers.bindEvents(me, me.options.events, function(evt) {\n\t\t\t\t\tme.eventHandler(evt);\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\t\tvar method = enabled? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\t\tvar element, i, ilen;\n\t\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase 'single':\n\t\t\t\t\telements = [elements[0]];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'label':\n\t\t\t\tcase 'dataset':\n\t\t\t\tcase 'x-axis':\n\t\t\t\t\t// elements = elements;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// unsupported mode\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tfor (i=0, ilen=elements.length; i<ilen; ++i) {\n\t\t\t\t\telement = elements[i];\n\t\t\t\t\tif (element) {\n\t\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\teventHandler: function(e) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar tooltip = me.tooltip;\n\t\t\t\tvar options = me.options || {};\n\t\t\t\tvar hoverOptions = options.hover;\n\t\t\t\tvar tooltipsOptions = options.tooltips;\n\t\n\t\t\t\tme.lastActive = me.lastActive || [];\n\t\t\t\tme.lastTooltipActive = me.lastTooltipActive || [];\n\t\n\t\t\t\t// Find Active Elements for hover and tooltips\n\t\t\t\tif (e.type === 'mouseout') {\n\t\t\t\t\tme.active = [];\n\t\t\t\t\tme.tooltipActive = [];\n\t\t\t\t} else {\n\t\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode);\n\t\t\t\t\tme.tooltipActive = me.getElementsAtEventForMode(e, tooltipsOptions.mode);\n\t\t\t\t}\n\t\n\t\t\t\t// On Hover hook\n\t\t\t\tif (hoverOptions.onHover) {\n\t\t\t\t\thoverOptions.onHover.call(me, me.active);\n\t\t\t\t}\n\t\n\t\t\t\tif (me.legend && me.legend.handleEvent) {\n\t\t\t\t\tme.legend.handleEvent(e);\n\t\t\t\t}\n\t\n\t\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\t\tif (options.onClick) {\n\t\t\t\t\t\toptions.onClick.call(me, e, me.active);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\t\tif (me.lastActive.length) {\n\t\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t\t}\n\t\n\t\t\t\t// Built in hover styling\n\t\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t\t}\n\t\n\t\t\t\t// Built in Tooltips\n\t\t\t\tif (tooltipsOptions.enabled || tooltipsOptions.custom) {\n\t\t\t\t\ttooltip.initialize();\n\t\t\t\t\ttooltip._active = me.tooltipActive;\n\t\t\t\t\ttooltip.update(true);\n\t\t\t\t}\n\t\n\t\t\t\t// Hover animations\n\t\t\t\ttooltip.pivot();\n\t\n\t\t\t\tif (!me.animating) {\n\t\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\t\tif (!helpers.arrayEquals(me.active, me.lastActive) ||\n\t\t\t\t\t\t!helpers.arrayEquals(me.tooltipActive, me.lastTooltipActive)) {\n\t\n\t\t\t\t\t\tme.stop();\n\t\n\t\t\t\t\t\tif (tooltipsOptions.enabled || tooltipsOptions.custom) {\n\t\t\t\t\t\t\ttooltip.update(true);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\t\t\tme.render(hoverOptions.animationDuration, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Remember Last Actives\n\t\t\t\tme.lastActive = me.active;\n\t\t\t\tme.lastTooltipActive = me.tooltipActive;\n\t\t\t\treturn me;\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\tvar noop = helpers.noop;\n\t\n\t\t// Base class for all dataset controllers (line, bar, etc)\n\t\tChart.DatasetController = function(chart, datasetIndex) {\n\t\t\tthis.initialize(chart, datasetIndex);\n\t\t};\n\t\n\t\thelpers.extend(Chart.DatasetController.prototype, {\n\t\n\t\t\t/**\n\t\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t\t * @type {Chart.core.element}\n\t\t\t */\n\t\t\tdatasetElementType: null,\n\t\n\t\t\t/**\n\t\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t\t * @type {Chart.core.element}\n\t\t\t */\n\t\t\tdataElementType: null,\n\t\n\t\t\tinitialize: function(chart, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tme.chart = chart;\n\t\t\t\tme.index = datasetIndex;\n\t\t\t\tme.linkScales();\n\t\t\t\tme.addElements();\n\t\t\t},\n\t\n\t\t\tupdateIndex: function(datasetIndex) {\n\t\t\t\tthis.index = datasetIndex;\n\t\t\t},\n\t\n\t\t\tlinkScales: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar dataset = me.getDataset();\n\t\n\t\t\t\tif (meta.xAxisID === null) {\n\t\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t\t}\n\t\t\t\tif (meta.yAxisID === null) {\n\t\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tgetDataset: function() {\n\t\t\t\treturn this.chart.data.datasets[this.index];\n\t\t\t},\n\t\n\t\t\tgetMeta: function() {\n\t\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t\t},\n\t\n\t\t\tgetScaleForId: function(scaleID) {\n\t\t\t\treturn this.chart.scales[scaleID];\n\t\t\t},\n\t\n\t\t\treset: function() {\n\t\t\t\tthis.update(true);\n\t\t\t},\n\t\n\t\t\tcreateMetaDataset: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar type = me.datasetElementType;\n\t\t\t\treturn type && new type({\n\t\t\t\t\t_chart: me.chart.chart,\n\t\t\t\t\t_datasetIndex: me.index\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tcreateMetaData: function(index) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar type = me.dataElementType;\n\t\t\t\treturn type && new type({\n\t\t\t\t\t_chart: me.chart.chart,\n\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t_index: index\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\taddElements: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar data = me.getDataset().data || [];\n\t\t\t\tvar metaData = meta.data;\n\t\t\t\tvar i, ilen;\n\t\n\t\t\t\tfor (i=0, ilen=data.length; i<ilen; ++i) {\n\t\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(meta, i);\n\t\t\t\t}\n\t\n\t\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t\t},\n\t\n\t\t\taddElementAndReset: function(index) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar element = me.createMetaData(index);\n\t\t\t\tme.getMeta().data.splice(index, 0, element);\n\t\t\t\tme.updateElement(element, index, true);\n\t\t\t},\n\t\n\t\t\tbuildOrUpdateElements: function() {\n\t\t\t\t// Handle the number of data points changing\n\t\t\t\tvar meta = this.getMeta(),\n\t\t\t\t\tmd = meta.data,\n\t\t\t\t\tnumData = this.getDataset().data.length,\n\t\t\t\t\tnumMetaData = md.length;\n\t\n\t\t\t\t// Make sure that we handle number of datapoints changing\n\t\t\t\tif (numData < numMetaData) {\n\t\t\t\t\t// Remove excess bars for data points that have been removed\n\t\t\t\t\tmd.splice(numData, numMetaData - numData);\n\t\t\t\t} else if (numData > numMetaData) {\n\t\t\t\t\t// Add new elements\n\t\t\t\t\tfor (var index = numMetaData; index < numData; ++index) {\n\t\t\t\t\t\tthis.addElementAndReset(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tupdate: noop,\n\t\n\t\t\tdraw: function(ease) {\n\t\t\t\tvar easingDecimal = ease || 1;\n\t\t\t\thelpers.each(this.getMeta().data, function(element) {\n\t\t\t\t\telement.transition(easingDecimal).draw();\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tremoveHoverStyle: function(element, elementOpts) {\n\t\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\t\tindex = element._index,\n\t\t\t\t\tcustom = element.custom || {},\n\t\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\t\tmodel = element._model;\n\t\n\t\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t\t},\n\t\n\t\t\tsetHoverStyle: function(element) {\n\t\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\t\tindex = element._index,\n\t\t\t\t\tcustom = element.custom || {},\n\t\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\t\tgetHoverColor = helpers.getHoverColor,\n\t\t\t\t\tmodel = element._model;\n\t\n\t\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t\t}\n\t\n\t\t});\n\t\n\t\tChart.DatasetController.extend = helpers.inherits;\n\t};\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n\t\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n\t\t// It is this service's responsibility of carrying out that layout.\n\t\tChart.layoutService = {\n\t\t\tdefaults: {},\n\t\n\t\t\t// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.\n\t\t\taddBox: function(chartInstance, box) {\n\t\t\t\tif (!chartInstance.boxes) {\n\t\t\t\t\tchartInstance.boxes = [];\n\t\t\t\t}\n\t\t\t\tchartInstance.boxes.push(box);\n\t\t\t},\n\t\n\t\t\tremoveBox: function(chartInstance, box) {\n\t\t\t\tif (!chartInstance.boxes) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tchartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);\n\t\t\t},\n\t\n\t\t\t// The most important function\n\t\t\tupdate: function(chartInstance, width, height) {\n\t\n\t\t\t\tif (!chartInstance) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar xPadding = 0;\n\t\t\t\tvar yPadding = 0;\n\t\n\t\t\t\tvar leftBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\t\treturn box.options.position === 'left';\n\t\t\t\t});\n\t\t\t\tvar rightBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\t\treturn box.options.position === 'right';\n\t\t\t\t});\n\t\t\t\tvar topBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\t\treturn box.options.position === 'top';\n\t\t\t\t});\n\t\t\t\tvar bottomBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\t\treturn box.options.position === 'bottom';\n\t\t\t\t});\n\t\n\t\t\t\t// Boxes that overlay the chartarea such as the radialLinear scale\n\t\t\t\tvar chartAreaBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\t\treturn box.options.position === 'chartArea';\n\t\t\t\t});\n\t\n\t\t\t\t// Ensure that full width boxes are at the very top / bottom\n\t\t\t\ttopBoxes.sort(function(a, b) {\n\t\t\t\t\treturn (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);\n\t\t\t\t});\n\t\t\t\tbottomBoxes.sort(function(a, b) {\n\t\t\t\t\treturn (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);\n\t\t\t\t});\n\t\n\t\t\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t\t\t// Our canvas looks like the following.\n\t\t\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t\t\t// B1 is the bottom axis\n\t\t\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t\t\t// an error will be thrown.\n\t\t\t\t//\n\t\t\t\t// |----------------------------------------------------|\n\t\t\t\t// |                  T1 (Full Width)                   |\n\t\t\t\t// |----------------------------------------------------|\n\t\t\t\t// |    |    |                 T2                  |    |\n\t\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t\t// |    |    | C1 |                           | C2 |    |\n\t\t\t\t// |    |    |----|                           |----|    |\n\t\t\t\t// |    |    |                                     |    |\n\t\t\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t\t\t// |    |    |                                     |    |\n\t\t\t\t// |    |    |----|                           |----|    |\n\t\t\t\t// |    |    | C3 |                           | C4 |    |\n\t\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t\t// |    |    |                 B1                  |    |\n\t\t\t\t// |----------------------------------------------------|\n\t\t\t\t// |                  B2 (Full Width)                   |\n\t\t\t\t// |----------------------------------------------------|\n\t\t\t\t//\n\t\t\t\t// What we do to find the best sizing, we do the following\n\t\t\t\t// 1. Determine the minimum size of the chart area.\n\t\t\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t\t\t// 6. Refit each axis\n\t\t\t\t// 7. Position each axis in the final location\n\t\t\t\t// 8. Tell the chart the final location of the chart area\n\t\t\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\t\n\t\t\t\t// Step 1\n\t\t\t\tvar chartWidth = width - (2 * xPadding);\n\t\t\t\tvar chartHeight = height - (2 * yPadding);\n\t\t\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\t\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\t\n\t\t\t\t// Step 2\n\t\t\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\t\n\t\t\t\t// Step 3\n\t\t\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\t\n\t\t\t\t// Step 4\n\t\t\t\tvar maxChartAreaWidth = chartWidth;\n\t\t\t\tvar maxChartAreaHeight = chartHeight;\n\t\t\t\tvar minBoxSizes = [];\n\t\n\t\t\t\tfunction getMinimumBoxSize(box) {\n\t\t\t\t\tvar minSize;\n\t\t\t\t\tvar isHorizontal = box.isHorizontal();\n\t\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tminSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tminSize = box.update(verticalBoxWidth, chartAreaHeight);\n\t\t\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tminBoxSizes.push({\n\t\t\t\t\t\thorizontal: isHorizontal,\n\t\t\t\t\t\tminSize: minSize,\n\t\t\t\t\t\tbox: box\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\t\n\t\t\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t\t\t// be if the axes are drawn at their minimum sizes.\n\t\n\t\t\t\t// Steps 5 & 6\n\t\t\t\tvar totalLeftBoxesWidth = xPadding;\n\t\t\t\tvar totalRightBoxesWidth = xPadding;\n\t\t\t\tvar totalTopBoxesHeight = yPadding;\n\t\t\t\tvar totalBottomBoxesHeight = yPadding;\n\t\n\t\t\t\t// Function to fit a box\n\t\t\t\tfunction fitBox(box) {\n\t\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\t\t\treturn minBox.box === box;\n\t\t\t\t\t});\n\t\n\t\t\t\t\tif (minBoxSize) {\n\t\t\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\t\t\tleft: totalLeftBoxesWidth,\n\t\t\t\t\t\t\t\tright: totalRightBoxesWidth,\n\t\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\t\t\tbox.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\t\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\t\n\t\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t\t});\n\t\n\t\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t\t});\n\t\n\t\t\t\t// Set the Left and Right margins for the horizontal boxes\n\t\t\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\t\n\t\t\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t\t});\n\t\n\t\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t\t});\n\t\n\t\t\t\tfunction finalFitVerticalBox(box) {\n\t\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\t\t\treturn minSize.box === box;\n\t\t\t\t\t});\n\t\n\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t\t\t};\n\t\n\t\t\t\t\tif (minBoxSize) {\n\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Let the left layout know the final margin\n\t\t\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\t\n\t\t\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\t\t\ttotalLeftBoxesWidth = xPadding;\n\t\t\t\ttotalRightBoxesWidth = xPadding;\n\t\t\t\ttotalTopBoxesHeight = yPadding;\n\t\t\t\ttotalBottomBoxesHeight = yPadding;\n\t\n\t\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t\t});\n\t\n\t\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t\t});\n\t\n\t\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t\t});\n\t\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t\t});\n\t\n\t\t\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t\t\t// without calling `fit` again\n\t\t\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\t\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\t\n\t\t\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t\t});\n\t\n\t\t\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t\t});\n\t\n\t\t\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\t\t\tif (!box.options.fullWidth) {\n\t\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\t\t\tif (!box.options.fullWidth) {\n\t\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\n\t\t\t\t// Step 7 - Position the boxes\n\t\t\t\tvar left = xPadding;\n\t\t\t\tvar top = yPadding;\n\t\n\t\t\t\tfunction placeBox(box) {\n\t\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\t\tbox.left = box.options.fullWidth ? xPadding : totalLeftBoxesWidth;\n\t\t\t\t\t\tbox.right = box.options.fullWidth ? width - xPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\t\t\tbox.top = top;\n\t\t\t\t\t\tbox.bottom = top + box.height;\n\t\n\t\t\t\t\t\t// Move to next point\n\t\t\t\t\t\ttop = box.bottom;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbox.left = left;\n\t\t\t\t\t\tbox.right = left + box.width;\n\t\t\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\t\n\t\t\t\t\t\t// Move to next point\n\t\t\t\t\t\tleft = box.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\t\n\t\t\t\t// Account for chart width and height\n\t\t\t\tleft += maxChartAreaWidth;\n\t\t\t\ttop += maxChartAreaHeight;\n\t\n\t\t\t\thelpers.each(rightBoxes, placeBox);\n\t\t\t\thelpers.each(bottomBoxes, placeBox);\n\t\n\t\t\t\t// Step 8\n\t\t\t\tchartInstance.chartArea = {\n\t\t\t\t\tleft: totalLeftBoxesWidth,\n\t\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t\t\t};\n\t\n\t\t\t\t// Step 9\n\t\t\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\t\t\tbox.left = chartInstance.chartArea.left;\n\t\t\t\t\tbox.top = chartInstance.chartArea.top;\n\t\t\t\t\tbox.right = chartInstance.chartArea.right;\n\t\t\t\t\tbox.bottom = chartInstance.chartArea.bottom;\n\t\n\t\t\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t};\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.scaleService = {\n\t\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t\t// use the new chart options to grab the correct scale\n\t\t\tconstructors: {},\n\t\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t\t// old browsers\n\t\n\t\t\t// Scale config defaults\n\t\t\tdefaults: {},\n\t\t\tregisterScaleType: function(type, scaleConstructor, defaults) {\n\t\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\t\tthis.defaults[type] = helpers.clone(defaults);\n\t\t\t},\n\t\t\tgetScaleConstructor: function(type) {\n\t\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t\t},\n\t\t\tgetScaleDefaults: function(type) {\n\t\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\n\t\t\t},\n\t\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\t\tvar defaults = this.defaults;\n\t\t\t\tif (defaults.hasOwnProperty(type)) {\n\t\t\t\t\tdefaults[type] = helpers.extend(defaults[type], additions);\n\t\t\t\t}\n\t\t\t},\n\t\t\taddScalesToLayout: function(chartInstance) {\n\t\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\t\thelpers.each(chartInstance.scales, function(scale) {\n\t\t\t\t\tChart.layoutService.addBox(chartInstance, scale);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar noop = Chart.helpers.noop;\n\t\n\t\t/**\n\t\t * The plugin service singleton\n\t\t * @namespace Chart.plugins\n\t\t * @since 2.1.0\n\t\t */\n\t\tChart.plugins = {\n\t\t\t_plugins: [],\n\t\n\t\t\t/**\n\t\t\t * Registers the given plugin(s) if not already registered.\n\t\t\t * @param {Array|Object} plugins plugin instance(s).\n\t\t\t */\n\t\t\tregister: function(plugins) {\n\t\t\t\tvar p = this._plugins;\n\t\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\t\t\tp.push(plugin);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Unregisters the given plugin(s) only if registered.\n\t\t\t * @param {Array|Object} plugins plugin instance(s).\n\t\t\t */\n\t\t\tunregister: function(plugins) {\n\t\t\t\tvar p = this._plugins;\n\t\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\t\tvar idx = p.indexOf(plugin);\n\t\t\t\t\tif (idx !== -1) {\n\t\t\t\t\t\tp.splice(idx, 1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Remove all registered p^lugins.\n\t\t\t * @since 2.1.5\n\t\t\t */\n\t\t\tclear: function() {\n\t\t\t\tthis._plugins = [];\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Returns the number of registered plugins?\n\t\t\t * @returns {Number}\n\t\t\t * @since 2.1.5\n\t\t\t */\n\t\t\tcount: function() {\n\t\t\t\treturn this._plugins.length;\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Returns all registered plugin intances.\n\t\t\t * @returns {Array} array of plugin objects.\n\t\t\t * @since 2.1.5\n\t\t\t */\n\t\t\tgetAll: function() {\n\t\t\t\treturn this._plugins;\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Calls registered plugins on the specified extension, with the given args. This\n\t\t\t * method immediately returns as soon as a plugin explicitly returns false. The\n\t\t\t * returned value can be used, for instance, to interrupt the current action.\n\t\t\t * @param {String} extension the name of the plugin method to call (e.g. 'beforeUpdate').\n\t\t\t * @param {Array} [args] extra arguments to apply to the extension call.\n\t\t\t * @returns {Boolean} false if any of the plugins return false, else returns true.\n\t\t\t */\n\t\t\tnotify: function(extension, args) {\n\t\t\t\tvar plugins = this._plugins;\n\t\t\t\tvar ilen = plugins.length;\n\t\t\t\tvar i, plugin;\n\t\n\t\t\t\tfor (i=0; i<ilen; ++i) {\n\t\t\t\t\tplugin = plugins[i];\n\t\t\t\t\tif (typeof plugin[extension] === 'function') {\n\t\t\t\t\t\tif (plugin[extension].apply(plugin, args || []) === false) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * Plugin extension methods.\n\t\t * @interface Chart.PluginBase\n\t\t * @since 2.1.0\n\t\t */\n\t\tChart.PluginBase = Chart.Element.extend({\n\t\t\t// Called at start of chart init\n\t\t\tbeforeInit: noop,\n\t\n\t\t\t// Called at end of chart init\n\t\t\tafterInit: noop,\n\t\n\t\t\t// Called at start of update\n\t\t\tbeforeUpdate: noop,\n\t\n\t\t\t// Called at end of update\n\t\t\tafterUpdate: noop,\n\t\n\t\t\t// Called at start of draw\n\t\t\tbeforeDraw: noop,\n\t\n\t\t\t// Called at end of draw\n\t\t\tafterDraw: noop,\n\t\n\t\t\t// Called during destroy\n\t\t\tdestroy: noop\n\t\t});\n\t\n\t\t/**\n\t\t * Provided for backward compatibility, use Chart.plugins instead\n\t\t * @namespace Chart.pluginService\n\t\t * @deprecated since version 2.1.5\n\t\t * @todo remove me at version 3\n\t\t */\n\t\tChart.pluginService = Chart.plugins;\n\t};\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.scale = {\n\t\t\tdisplay: true,\n\t\t\tposition: 'left',\n\t\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\tdisplay: true,\n\t\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\t\tlineWidth: 1,\n\t\t\t\tdrawBorder: true,\n\t\t\t\tdrawOnChartArea: true,\n\t\t\t\tdrawTicks: true,\n\t\t\t\ttickMarkLength: 10,\n\t\t\t\tzeroLineWidth: 1,\n\t\t\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\t\t\toffsetGridLines: false,\n\t\t\t\tborderDash: [],\n\t\t\t\tborderDashOffset: 0.0\n\t\t\t},\n\t\n\t\t\t// scale label\n\t\t\tscaleLabel: {\n\t\t\t\t// actual label\n\t\t\t\tlabelString: '',\n\t\n\t\t\t\t// display property\n\t\t\t\tdisplay: false\n\t\t\t},\n\t\n\t\t\t// label settings\n\t\t\tticks: {\n\t\t\t\tbeginAtZero: false,\n\t\t\t\tminRotation: 0,\n\t\t\t\tmaxRotation: 50,\n\t\t\t\tmirror: false,\n\t\t\t\tpadding: 10,\n\t\t\t\treverse: false,\n\t\t\t\tdisplay: true,\n\t\t\t\tautoSkip: true,\n\t\t\t\tautoSkipPadding: 0,\n\t\t\t\tlabelOffset: 0,\n\t\t\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\t\t\tcallback: function(value) {\n\t\t\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tChart.Scale = Chart.Element.extend({\n\t\n\t\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t\t// Any function defined here is inherited by all scale types.\n\t\t\t// Any function can be extended by the scale type\n\t\n\t\t\tbeforeUpdate: function() {\n\t\t\t\thelpers.callCallback(this.options.beforeUpdate, [this]);\n\t\t\t},\n\t\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\t\tvar me = this;\n\t\n\t\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\t\tme.beforeUpdate();\n\t\n\t\t\t\t// Absorb the master measurements\n\t\t\t\tme.maxWidth = maxWidth;\n\t\t\t\tme.maxHeight = maxHeight;\n\t\t\t\tme.margins = helpers.extend({\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tbottom: 0\n\t\t\t\t}, margins);\n\t\n\t\t\t\t// Dimensions\n\t\t\t\tme.beforeSetDimensions();\n\t\t\t\tme.setDimensions();\n\t\t\t\tme.afterSetDimensions();\n\t\n\t\t\t\t// Data min/max\n\t\t\t\tme.beforeDataLimits();\n\t\t\t\tme.determineDataLimits();\n\t\t\t\tme.afterDataLimits();\n\t\n\t\t\t\t// Ticks\n\t\t\t\tme.beforeBuildTicks();\n\t\t\t\tme.buildTicks();\n\t\t\t\tme.afterBuildTicks();\n\t\n\t\t\t\tme.beforeTickToLabelConversion();\n\t\t\t\tme.convertTicksToLabels();\n\t\t\t\tme.afterTickToLabelConversion();\n\t\n\t\t\t\t// Tick Rotation\n\t\t\t\tme.beforeCalculateTickRotation();\n\t\t\t\tme.calculateTickRotation();\n\t\t\t\tme.afterCalculateTickRotation();\n\t\t\t\t// Fit\n\t\t\t\tme.beforeFit();\n\t\t\t\tme.fit();\n\t\t\t\tme.afterFit();\n\t\t\t\t//\n\t\t\t\tme.afterUpdate();\n\t\n\t\t\t\treturn me.minSize;\n\t\n\t\t\t},\n\t\t\tafterUpdate: function() {\n\t\t\t\thelpers.callCallback(this.options.afterUpdate, [this]);\n\t\t\t},\n\t\n\t\t\t//\n\t\n\t\t\tbeforeSetDimensions: function() {\n\t\t\t\thelpers.callCallback(this.options.beforeSetDimensions, [this]);\n\t\t\t},\n\t\t\tsetDimensions: function() {\n\t\t\t\tvar me = this;\n\t\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\tme.width = me.maxWidth;\n\t\t\t\t\tme.left = 0;\n\t\t\t\t\tme.right = me.width;\n\t\t\t\t} else {\n\t\t\t\t\tme.height = me.maxHeight;\n\t\n\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\tme.top = 0;\n\t\t\t\t\tme.bottom = me.height;\n\t\t\t\t}\n\t\n\t\t\t\t// Reset padding\n\t\t\t\tme.paddingLeft = 0;\n\t\t\t\tme.paddingTop = 0;\n\t\t\t\tme.paddingRight = 0;\n\t\t\t\tme.paddingBottom = 0;\n\t\t\t},\n\t\t\tafterSetDimensions: function() {\n\t\t\t\thelpers.callCallback(this.options.afterSetDimensions, [this]);\n\t\t\t},\n\t\n\t\t\t// Data limits\n\t\t\tbeforeDataLimits: function() {\n\t\t\t\thelpers.callCallback(this.options.beforeDataLimits, [this]);\n\t\t\t},\n\t\t\tdetermineDataLimits: helpers.noop,\n\t\t\tafterDataLimits: function() {\n\t\t\t\thelpers.callCallback(this.options.afterDataLimits, [this]);\n\t\t\t},\n\t\n\t\t\t//\n\t\t\tbeforeBuildTicks: function() {\n\t\t\t\thelpers.callCallback(this.options.beforeBuildTicks, [this]);\n\t\t\t},\n\t\t\tbuildTicks: helpers.noop,\n\t\t\tafterBuildTicks: function() {\n\t\t\t\thelpers.callCallback(this.options.afterBuildTicks, [this]);\n\t\t\t},\n\t\n\t\t\tbeforeTickToLabelConversion: function() {\n\t\t\t\thelpers.callCallback(this.options.beforeTickToLabelConversion, [this]);\n\t\t\t},\n\t\t\tconvertTicksToLabels: function() {\n\t\t\t\tvar me = this;\n\t\t\t\t// Convert ticks to strings\n\t\t\t\tme.ticks = me.ticks.map(function(numericalTick, index, ticks) {\n\t\t\t\t\tif (me.options.ticks.userCallback) {\n\t\t\t\t\t\treturn me.options.ticks.userCallback(numericalTick, index, ticks);\n\t\t\t\t\t}\n\t\t\t\t\treturn me.options.ticks.callback(numericalTick, index, ticks);\n\t\t\t\t},\n\t\t\t\tme);\n\t\t\t},\n\t\t\tafterTickToLabelConversion: function() {\n\t\t\t\thelpers.callCallback(this.options.afterTickToLabelConversion, [this]);\n\t\t\t},\n\t\n\t\t\t//\n\t\n\t\t\tbeforeCalculateTickRotation: function() {\n\t\t\t\thelpers.callCallback(this.options.beforeCalculateTickRotation, [this]);\n\t\t\t},\n\t\t\tcalculateTickRotation: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar context = me.ctx;\n\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\t\tvar optionTicks = me.options.ticks;\n\t\n\t\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t\t// between x offsets between 0 and 1.\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\t\t\t\tcontext.font = tickLabelFont;\n\t\n\t\t\t\tvar firstWidth = context.measureText(me.ticks[0]).width;\n\t\t\t\tvar lastWidth = context.measureText(me.ticks[me.ticks.length - 1]).width;\n\t\t\t\tvar firstRotated;\n\t\n\t\t\t\tme.labelRotation = optionTicks.minRotation || 0;\n\t\t\t\tme.paddingRight = 0;\n\t\t\t\tme.paddingLeft = 0;\n\t\n\t\t\t\tif (me.options.display) {\n\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\tme.paddingRight = lastWidth / 2 + 3;\n\t\t\t\t\t\tme.paddingLeft = firstWidth / 2 + 3;\n\t\n\t\t\t\t\t\tif (!me.longestTextCache) {\n\t\t\t\t\t\t\tme.longestTextCache = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickLabelFont, me.ticks, me.longestTextCache);\n\t\t\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\t\t\tvar cosRotation;\n\t\t\t\t\t\tvar sinRotation;\n\t\n\t\t\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\t\t\t// only the index matters for a dataset scale, but we want a consistent interface between scales\n\t\t\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\t\n\t\t\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\t\t\twhile (labelWidth > tickWidth && me.labelRotation < optionTicks.maxRotation) {\n\t\t\t\t\t\t\tcosRotation = Math.cos(helpers.toRadians(me.labelRotation));\n\t\t\t\t\t\t\tsinRotation = Math.sin(helpers.toRadians(me.labelRotation));\n\t\n\t\t\t\t\t\t\tfirstRotated = cosRotation * firstWidth;\n\t\n\t\t\t\t\t\t\t// We're right aligning the text now.\n\t\t\t\t\t\t\tif (firstRotated + tickFontSize / 2 > me.yLabelWidth) {\n\t\t\t\t\t\t\t\tme.paddingLeft = firstRotated + tickFontSize / 2;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tme.paddingRight = tickFontSize / 2;\n\t\n\t\t\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\t\t\tme.labelRotation--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tme.labelRotation++;\n\t\t\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (me.margins) {\n\t\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tafterCalculateTickRotation: function() {\n\t\t\t\thelpers.callCallback(this.options.afterCalculateTickRotation, [this]);\n\t\t\t},\n\t\n\t\t\t//\n\t\n\t\t\tbeforeFit: function() {\n\t\t\t\thelpers.callCallback(this.options.beforeFit, [this]);\n\t\t\t},\n\t\t\tfit: function() {\n\t\t\t\tvar me = this;\n\t\t\t\t// Reset\n\t\t\t\tvar minSize = me.minSize = {\n\t\t\t\t\twidth: 0,\n\t\t\t\t\theight: 0\n\t\t\t\t};\n\t\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\t\tvar display = opts.display;\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = helpers.getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = helpers.getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\t\n\t\t\t\tvar scaleLabelFontSize = helpers.getValueOrDefault(scaleLabelOpts.fontSize, globalDefaults.defaultFontSize);\n\t\n\t\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\t\n\t\t\t\t// Width\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t\t}\n\t\n\t\t\t\t// height\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t\t}\n\t\n\t\t\t\t// Are we showing a title for the scale?\n\t\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tminSize.height += (scaleLabelFontSize * 1.5);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tminSize.width += (scaleLabelFontSize * 1.5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (tickOpts.display && display) {\n\t\t\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\t\t\tif (!me.longestTextCache) {\n\t\t\t\t\t\tme.longestTextCache = {};\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickLabelFont, me.ticks, me.longestTextCache);\n\t\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\n\t\t\t\t\tvar lineSpace = tickFontSize * 0.5;\n\t\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\t\n\t\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\t\tvar labelHeight = (Math.sin(helpers.toRadians(me.labelRotation)) * me.longestLabelWidth) + (tickFontSize * tallestLabelHeightInLines) + (lineSpace * tallestLabelHeightInLines);\n\t\n\t\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\n\t\t\t\t\t\tme.ctx.font = tickLabelFont;\n\t\n\t\t\t\t\t\tvar firstLabelWidth = me.ctx.measureText(me.ticks[0]).width;\n\t\t\t\t\t\tvar lastLabelWidth = me.ctx.measureText(me.ticks[me.ticks.length - 1]).width;\n\t\n\t\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\n\t\t\t\t\t\t// by the font height\n\t\t\t\t\t\tvar cosRotation = Math.cos(helpers.toRadians(me.labelRotation));\n\t\t\t\t\t\tvar sinRotation = Math.sin(helpers.toRadians(me.labelRotation));\n\t\t\t\t\t\tme.paddingLeft = me.labelRotation !== 0 ? (cosRotation * firstLabelWidth) + 3 : firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = me.labelRotation !== 0 ? (sinRotation * (tickFontSize / 2)) + 3 : lastLabelWidth / 2 + 3; // when rotated\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\n\t\t\t\t\t\tvar maxLabelWidth = me.maxWidth - minSize.width;\n\t\n\t\t\t\t\t\t// Account for padding\n\t\t\t\t\t\tvar mirror = tickOpts.mirror;\n\t\t\t\t\t\tif (!mirror) {\n\t\t\t\t\t\t\tlargestTextWidth += me.options.ticks.padding;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If mirrored text is on the inside so don't expand\n\t\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (largestTextWidth < maxLabelWidth) {\n\t\t\t\t\t\t\t// We don't need all the room\n\t\t\t\t\t\t\tminSize.width += largestTextWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Expand to max size\n\t\t\t\t\t\t\tminSize.width = me.maxWidth;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tme.paddingTop = tickFontSize / 2;\n\t\t\t\t\t\tme.paddingBottom = tickFontSize / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (me.margins) {\n\t\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t\t}\n\t\n\t\t\t\tme.width = minSize.width;\n\t\t\t\tme.height = minSize.height;\n\t\n\t\t\t},\n\t\t\tafterFit: function() {\n\t\t\t\thelpers.callCallback(this.options.afterFit, [this]);\n\t\t\t},\n\t\n\t\t\t// Shared Methods\n\t\t\tisHorizontal: function() {\n\t\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t\t},\n\t\t\tisFullWidth: function() {\n\t\t\t\treturn (this.options.fullWidth);\n\t\t\t},\n\t\n\t\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\t\tgetRightValue: function(rawValue) {\n\t\t\t\t// Null and undefined values first\n\t\t\t\tif (rawValue === null || typeof(rawValue) === 'undefined') {\n\t\t\t\t\treturn NaN;\n\t\t\t\t}\n\t\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number\n\t\t\t\tif (typeof(rawValue) === 'number' && isNaN(rawValue)) {\n\t\t\t\t\treturn NaN;\n\t\t\t\t}\n\t\t\t\t// If it is in fact an object, dive in one more level\n\t\t\t\tif (typeof(rawValue) === 'object') {\n\t\t\t\t\tif ((rawValue instanceof Date) || (rawValue.isValid)) {\n\t\t\t\t\t\treturn rawValue;\n\t\t\t\t\t}\n\t\t\t\t\treturn this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\n\t\t\t\t}\n\t\n\t\t\t\t// Value is good, return it\n\t\t\t\treturn rawValue;\n\t\t\t},\n\t\n\t\t\t// Used to get the value to display in the tooltip for the data at the given index\n\t\t\t// function getLabelForIndex(index, datasetIndex)\n\t\t\tgetLabelForIndex: helpers.noop,\n\t\n\t\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\t\tgetPixelForValue: helpers.noop,\n\t\n\t\t\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\t\tgetValueForPixel: helpers.noop,\n\t\n\t\t\t// Used for tick location, should\n\t\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\t\tvar me = this;\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\t\tvar tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\t\n\t\t\t\t\tif (includeOffset) {\n\t\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\t\treturn finalVal;\n\t\t\t\t}\n\t\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\t\treturn me.top + (index * (innerHeight / (me.ticks.length - 1)));\n\t\t\t},\n\t\n\t\t\t// Utility for getting the pixel location of a percentage of scale\n\t\t\tgetPixelForDecimal: function(decimal /* , includeOffset*/) {\n\t\t\t\tvar me = this;\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\t\n\t\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\t\treturn finalVal;\n\t\t\t\t}\n\t\t\t\treturn me.top + (decimal * me.height);\n\t\t\t},\n\t\n\t\t\tgetBasePixel: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar min = me.min;\n\t\t\t\tvar max = me.max;\n\t\n\t\t\t\treturn me.getPixelForValue(\n\t\t\t\t\tme.beginAtZero? 0:\n\t\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t\t0);\n\t\t\t},\n\t\n\t\t\t// Actualy draw the scale on the canvas\n\t\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\t\tdraw: function(chartArea) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar options = me.options;\n\t\t\t\tif (!options.display) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar context = me.ctx;\n\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\t\tvar optionTicks = options.ticks;\n\t\t\t\tvar gridLines = options.gridLines;\n\t\t\t\tvar scaleLabel = options.scaleLabel;\n\t\n\t\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\t\tvar skipRatio;\n\t\t\t\tvar useAutoskipper = optionTicks.autoSkip;\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\n\t\t\t\t// figure out the maximum number of gridlines to show\n\t\t\t\tvar maxTicks;\n\t\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t\t}\n\t\n\t\t\t\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\t\t\t\tvar tl = gridLines.tickMarkLength;\n\t\t\t\tvar borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\tvar borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\n\t\t\t\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\tvar scaleLabelFontSize = helpers.getValueOrDefault(scaleLabel.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar scaleLabelFontStyle = helpers.getValueOrDefault(scaleLabel.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar scaleLabelFontFamily = helpers.getValueOrDefault(scaleLabel.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);\n\t\n\t\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\t\n\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\tcontext.fillStyle = tickFontColor;\n\t\n\t\t\t\tvar itemsToDraw = [];\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tskipRatio = false;\n\t\n\t\t\t\t\t// Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation\n\t\t\t\t\t// See #2584\n\t\t\t\t\tif (isRotated) {\n\t\t\t\t\t\tlongestRotatedLabel /= 2;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\t\tif (maxTicks && me.ticks.length > maxTicks) {\n\t\t\t\t\t\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\n\t\t\t\t\t\t\tif (!skipRatio) {\n\t\t\t\t\t\t\t\tskipRatio = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tskipRatio += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (!useAutoskipper) {\n\t\t\t\t\t\tskipRatio = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\n\t\t\t\tvar xTickStart = options.position === 'right' ? me.left : me.right - tl;\n\t\t\t\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n\t\t\t\tvar yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\n\t\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\n\t\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// If the callback returned a null or undefined value, do not draw this line\n\t\t\t\t\tif (label === undefined || label === null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar isLastTick = me.ticks.length === index + 1;\n\t\n\t\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\t\tvar shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\n\t\t\t\t\tif (shouldSkip && !isLastTick || (label === undefined || label === null)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar lineWidth, lineColor;\n\t\t\t\t\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\n\t\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\t\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Common properties\n\t\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\t\tvar textAlign = 'middle';\n\t\t\t\t\tvar textBaseline = 'middle';\n\t\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tif (!isRotated) {\n\t\t\t\t\t\t\ttextBaseline = options.position === 'top' ? 'bottom' : 'top';\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttextAlign = isRotated ? 'right' : 'center';\n\t\n\t\t\t\t\t\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\n\t\t\t\t\t\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\t\t\t\t\t\tlabelY = (isRotated) ? me.top + 12 : options.position === 'top' ? me.bottom - tl : me.top + tl;\n\t\n\t\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\t\ty2 = chartArea.bottom;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (options.position === 'left') {\n\t\t\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\t\t\tlabelX = me.right + optionTicks.padding;\n\t\t\t\t\t\t\t\ttextAlign = 'left';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlabelX = me.right - optionTicks.padding;\n\t\t\t\t\t\t\t\ttextAlign = 'right';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// right side\n\t\t\t\t\t\t} else if (optionTicks.mirror) {\n\t\t\t\t\t\t\tlabelX = me.left - optionTicks.padding;\n\t\t\t\t\t\t\ttextAlign = 'right';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlabelX = me.left + optionTicks.padding;\n\t\t\t\t\t\t\ttextAlign = 'left';\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines\n\t\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\t\t\t\t\t\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);\n\t\n\t\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\t\tx2 = chartArea.right;\n\t\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\titemsToDraw.push({\n\t\t\t\t\t\ttx1: tx1,\n\t\t\t\t\t\tty1: ty1,\n\t\t\t\t\t\ttx2: tx2,\n\t\t\t\t\t\tty2: ty2,\n\t\t\t\t\t\tx1: x1,\n\t\t\t\t\t\ty1: y1,\n\t\t\t\t\t\tx2: x2,\n\t\t\t\t\t\ty2: y2,\n\t\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\t\tlabel: label,\n\t\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t\t});\n\t\t\t\t});\n\t\n\t\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\t\tif (gridLines.display) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontext.beginPath();\n\t\n\t\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontext.stroke();\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\t\tcontext.font = tickLabelFont;\n\t\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\t\n\t\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\t\tfor (var i = 0, y = -(label.length - 1)*tickFontSize*0.75; i < label.length; ++i) {\n\t\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\t\ty += (tickFontSize * 1.5);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tif (scaleLabel.display) {\n\t\t\t\t\t// Draw the scale label\n\t\t\t\t\tvar scaleLabelX;\n\t\t\t\t\tvar scaleLabelY;\n\t\t\t\t\tvar rotation = 0;\n\t\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\t\tscaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFontSize / 2) : me.top + (scaleLabelFontSize / 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\t\tscaleLabelX = isLeft ? me.left + (scaleLabelFontSize / 2) : me.right - (scaleLabelFontSize / 2);\n\t\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\t\tcontext.rotate(rotation);\n\t\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\t\tcontext.font = scaleLabelFont;\n\t\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\n\t\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\t\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\t\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\t\tvar x1 = me.left,\n\t\t\t\t\t\tx2 = me.right,\n\t\t\t\t\t\ty1 = me.top,\n\t\t\t\t\t\ty2 = me.bottom;\n\t\n\t\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontext.beginPath();\n\t\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.global.title = {\n\t\t\tdisplay: false,\n\t\t\tposition: 'top',\n\t\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\n\t\n\t\t\tfontStyle: 'bold',\n\t\t\tpadding: 10,\n\t\n\t\t\t// actual title\n\t\t\ttext: ''\n\t\t};\n\t\n\t\tvar noop = helpers.noop;\n\t\tChart.Title = Chart.Element.extend({\n\t\n\t\t\tinitialize: function(config) {\n\t\t\t\tvar me = this;\n\t\t\t\thelpers.extend(me, config);\n\t\t\t\tme.options = helpers.configMerge(Chart.defaults.global.title, config.options);\n\t\n\t\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\t\tme.legendHitBoxes = [];\n\t\t\t},\n\t\n\t\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\n\t\t\tbeforeUpdate: function() {\n\t\t\t\tvar chartOpts = this.chart.options;\n\t\t\t\tif (chartOpts && chartOpts.title) {\n\t\t\t\t\tthis.options = helpers.configMerge(Chart.defaults.global.title, chartOpts.title);\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\t\tvar me = this;\n\t\n\t\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\t\tme.beforeUpdate();\n\t\n\t\t\t\t// Absorb the master measurements\n\t\t\t\tme.maxWidth = maxWidth;\n\t\t\t\tme.maxHeight = maxHeight;\n\t\t\t\tme.margins = margins;\n\t\n\t\t\t\t// Dimensions\n\t\t\t\tme.beforeSetDimensions();\n\t\t\t\tme.setDimensions();\n\t\t\t\tme.afterSetDimensions();\n\t\t\t\t// Labels\n\t\t\t\tme.beforeBuildLabels();\n\t\t\t\tme.buildLabels();\n\t\t\t\tme.afterBuildLabels();\n\t\n\t\t\t\t// Fit\n\t\t\t\tme.beforeFit();\n\t\t\t\tme.fit();\n\t\t\t\tme.afterFit();\n\t\t\t\t//\n\t\t\t\tme.afterUpdate();\n\t\n\t\t\t\treturn me.minSize;\n\t\n\t\t\t},\n\t\t\tafterUpdate: noop,\n\t\n\t\t\t//\n\t\n\t\t\tbeforeSetDimensions: noop,\n\t\t\tsetDimensions: function() {\n\t\t\t\tvar me = this;\n\t\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\tme.width = me.maxWidth;\n\t\t\t\t\tme.left = 0;\n\t\t\t\t\tme.right = me.width;\n\t\t\t\t} else {\n\t\t\t\t\tme.height = me.maxHeight;\n\t\n\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\tme.top = 0;\n\t\t\t\t\tme.bottom = me.height;\n\t\t\t\t}\n\t\n\t\t\t\t// Reset padding\n\t\t\t\tme.paddingLeft = 0;\n\t\t\t\tme.paddingTop = 0;\n\t\t\t\tme.paddingRight = 0;\n\t\t\t\tme.paddingBottom = 0;\n\t\n\t\t\t\t// Reset minSize\n\t\t\t\tme.minSize = {\n\t\t\t\t\twidth: 0,\n\t\t\t\t\theight: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tafterSetDimensions: noop,\n\t\n\t\t\t//\n\t\n\t\t\tbeforeBuildLabels: noop,\n\t\t\tbuildLabels: noop,\n\t\t\tafterBuildLabels: noop,\n\t\n\t\t\t//\n\t\n\t\t\tbeforeFit: noop,\n\t\t\tfit: function() {\n\t\t\t\tvar me = this,\n\t\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\topts = me.options,\n\t\t\t\t\tglobalDefaults = Chart.defaults.global,\n\t\t\t\t\tdisplay = opts.display,\n\t\t\t\t\tfontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\tminSize = me.minSize;\n\t\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\t\tminSize.height = display ? fontSize + (opts.padding * 2) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width = display ? fontSize + (opts.padding * 2) : 0;\n\t\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t\t}\n\t\n\t\t\t\tme.width = minSize.width;\n\t\t\t\tme.height = minSize.height;\n\t\n\t\t\t},\n\t\t\tafterFit: noop,\n\t\n\t\t\t// Shared Methods\n\t\t\tisHorizontal: function() {\n\t\t\t\tvar pos = this.options.position;\n\t\t\t\treturn pos === 'top' || pos === 'bottom';\n\t\t\t},\n\t\n\t\t\t// Actualy draw the title block on the canvas\n\t\t\tdraw: function() {\n\t\t\t\tvar me = this,\n\t\t\t\t\tctx = me.ctx,\n\t\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\topts = me.options,\n\t\t\t\t\tglobalDefaults = Chart.defaults.global;\n\t\n\t\t\t\tif (opts.display) {\n\t\t\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\tfontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\t\tfontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\t\ttitleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\n\t\t\t\t\t\trotation = 0,\n\t\t\t\t\t\ttitleX,\n\t\t\t\t\t\ttitleY,\n\t\t\t\t\t\ttop = me.top,\n\t\t\t\t\t\tleft = me.left,\n\t\t\t\t\t\tbottom = me.bottom,\n\t\t\t\t\t\tright = me.right;\n\t\n\t\t\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\t\t\tctx.font = titleFont;\n\t\n\t\t\t\t\t// Horizontal\n\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\t\t\ttitleY = top + ((bottom - top) / 2); // midpoint of the height\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttitleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);\n\t\t\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.translate(titleX, titleY);\n\t\t\t\t\tctx.rotate(rotation);\n\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\tctx.fillText(opts.text, 0, 0);\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\t// Register the title plugin\n\t\tChart.plugins.register({\n\t\t\tbeforeInit: function(chartInstance) {\n\t\t\t\tvar opts = chartInstance.options;\n\t\t\t\tvar titleOpts = opts.title;\n\t\n\t\t\t\tif (titleOpts) {\n\t\t\t\t\tchartInstance.titleBlock = new Chart.Title({\n\t\t\t\t\t\tctx: chartInstance.chart.ctx,\n\t\t\t\t\t\toptions: titleOpts,\n\t\t\t\t\t\tchart: chartInstance\n\t\t\t\t\t});\n\t\n\t\t\t\t\tChart.layoutService.addBox(chartInstance, chartInstance.titleBlock);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\tvar noop = helpers.noop;\n\t\n\t\tChart.defaults.global.legend = {\n\t\n\t\t\tdisplay: true,\n\t\t\tposition: 'top',\n\t\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\n\t\t\treverse: false,\n\t\n\t\t\t// a callback that will handle\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.datasetIndex;\n\t\t\t\tvar ci = this.chart;\n\t\t\t\tvar meta = ci.getDatasetMeta(index);\n\t\n\t\t\t\t// See controller.isDatasetVisible comment\n\t\t\t\tmeta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;\n\t\n\t\t\t\t// We hid a dataset ... rerender the chart\n\t\t\t\tci.update();\n\t\t\t},\n\t\n\t\t\tonHover: null,\n\t\n\t\t\tlabels: {\n\t\t\t\tboxWidth: 40,\n\t\t\t\tpadding: 10,\n\t\t\t\t// Generates labels shown in the legend\n\t\t\t\t// Valid properties to return:\n\t\t\t\t// text : text to display\n\t\t\t\t// fillStyle : fill of coloured box\n\t\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t\t// lineCap : cap style for line\n\t\t\t\t// lineDash\n\t\t\t\t// lineDashOffset :\n\t\t\t\t// lineJoin :\n\t\t\t\t// lineWidth :\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\t\n\t\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t}, this) : [];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tChart.Legend = Chart.Element.extend({\n\t\n\t\t\tinitialize: function(config) {\n\t\t\t\thelpers.extend(this, config);\n\t\n\t\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\t\tthis.legendHitBoxes = [];\n\t\n\t\t\t\t// Are we in doughnut mode which has a different data type\n\t\t\t\tthis.doughnutMode = false;\n\t\t\t},\n\t\n\t\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t\t// Any function defined here is inherited by all legend types.\n\t\t\t// Any function can be extended by the legend type\n\t\n\t\t\tbeforeUpdate: noop,\n\t\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\t\tvar me = this;\n\t\n\t\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\t\tme.beforeUpdate();\n\t\n\t\t\t\t// Absorb the master measurements\n\t\t\t\tme.maxWidth = maxWidth;\n\t\t\t\tme.maxHeight = maxHeight;\n\t\t\t\tme.margins = margins;\n\t\n\t\t\t\t// Dimensions\n\t\t\t\tme.beforeSetDimensions();\n\t\t\t\tme.setDimensions();\n\t\t\t\tme.afterSetDimensions();\n\t\t\t\t// Labels\n\t\t\t\tme.beforeBuildLabels();\n\t\t\t\tme.buildLabels();\n\t\t\t\tme.afterBuildLabels();\n\t\n\t\t\t\t// Fit\n\t\t\t\tme.beforeFit();\n\t\t\t\tme.fit();\n\t\t\t\tme.afterFit();\n\t\t\t\t//\n\t\t\t\tme.afterUpdate();\n\t\n\t\t\t\treturn me.minSize;\n\t\t\t},\n\t\t\tafterUpdate: noop,\n\t\n\t\t\t//\n\t\n\t\t\tbeforeSetDimensions: noop,\n\t\t\tsetDimensions: function() {\n\t\t\t\tvar me = this;\n\t\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\tme.width = me.maxWidth;\n\t\t\t\t\tme.left = 0;\n\t\t\t\t\tme.right = me.width;\n\t\t\t\t} else {\n\t\t\t\t\tme.height = me.maxHeight;\n\t\n\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\tme.top = 0;\n\t\t\t\t\tme.bottom = me.height;\n\t\t\t\t}\n\t\n\t\t\t\t// Reset padding\n\t\t\t\tme.paddingLeft = 0;\n\t\t\t\tme.paddingTop = 0;\n\t\t\t\tme.paddingRight = 0;\n\t\t\t\tme.paddingBottom = 0;\n\t\n\t\t\t\t// Reset minSize\n\t\t\t\tme.minSize = {\n\t\t\t\t\twidth: 0,\n\t\t\t\t\theight: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tafterSetDimensions: noop,\n\t\n\t\t\t//\n\t\n\t\t\tbeforeBuildLabels: noop,\n\t\t\tbuildLabels: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tme.legendItems = me.options.labels.generateLabels.call(me, me.chart);\n\t\t\t\tif (me.options.reverse) {\n\t\t\t\t\tme.legendItems.reverse();\n\t\t\t\t}\n\t\t\t},\n\t\t\tafterBuildLabels: noop,\n\t\n\t\t\t//\n\t\n\t\t\tbeforeFit: noop,\n\t\t\tfit: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar labelOpts = opts.labels;\n\t\t\t\tvar display = opts.display;\n\t\n\t\t\t\tvar ctx = me.ctx;\n\t\n\t\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\n\t\t\t\t// Reset hit boxes\n\t\t\t\tvar hitboxes = me.legendHitBoxes = [];\n\t\n\t\t\t\tvar minSize = me.minSize;\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\t\tminSize.height = display ? 10 : 0;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width = display ? 10 : 0;\n\t\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t\t}\n\t\n\t\t\t\t// Increase sizes here\n\t\t\t\tif (display) {\n\t\t\t\t\tctx.font = labelFont;\n\t\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t// Labels\n\t\n\t\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\t\n\t\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\t\tctx.textBaseline = 'top';\n\t\n\t\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\t\tvar boxWidth = labelOpts.usePointStyle ?\n\t\t\t\t\t\t\t\tfontSize * Math.sqrt(2) :\n\t\t\t\t\t\t\t\tlabelOpts.boxWidth;\n\t\n\t\t\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\t\t\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\tminSize.height += totalHeight;\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\t\t\tvar currentColWidth = 0;\n\t\t\t\t\t\tvar currentColHeight = 0;\n\t\t\t\t\t\tvar itemHeight = fontSize + vPadding;\n\t\n\t\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\t\t// If usePointStyle is set, multiple boxWidth by 2 since it represents\n\t\t\t\t\t\t\t// the radius and not truly the width\n\t\t\t\t\t\t\tvar boxWidth = labelOpts.usePointStyle ? 2 * labelOpts.boxWidth : labelOpts.boxWidth;\n\t\n\t\t\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\t\n\t\t\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\t\n\t\t\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Get max width\n\t\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\t\t\tcurrentColHeight += itemHeight;\n\t\n\t\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\t\tminSize.width += totalWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tme.width = minSize.width;\n\t\t\t\tme.height = minSize.height;\n\t\t\t},\n\t\t\tafterFit: noop,\n\t\n\t\t\t// Shared Methods\n\t\t\tisHorizontal: function() {\n\t\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t\t},\n\t\n\t\t\t// Actualy draw the legend on the canvas\n\t\t\tdraw: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar labelOpts = opts.labels;\n\t\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\t\tlineDefault = globalDefault.elements.line,\n\t\t\t\t\tlegendWidth = me.width,\n\t\t\t\t\tlineWidths = me.lineWidths;\n\t\n\t\t\t\tif (opts.display) {\n\t\t\t\t\tvar ctx = me.ctx,\n\t\t\t\t\t\tcursor,\n\t\t\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\t\tfontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n\t\t\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\n\t\t\t\t\t// Canvas setup\n\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\tctx.textBaseline = 'top';\n\t\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\t\t\tctx.font = labelFont;\n\t\n\t\t\t\t\tvar boxWidth = labelOpts.boxWidth,\n\t\t\t\t\t\thitboxes = me.legendHitBoxes;\n\t\n\t\t\t\t\t// current position\n\t\t\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Set the ctx for the box\n\t\t\t\t\t\tctx.save();\n\t\n\t\t\t\t\t\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\t\t\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\t\t\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\t\t\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\t\t\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\t\t\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\t\t\tvar isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\t\n\t\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\t\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t\t\t// Recalulate x and y for drawPoint() because its expecting\n\t\t\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\t\t\tvar centerY = y + offSet;\n\t\n\t\t\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\t\t\tChart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t};\n\t\t\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\t\t\tctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\n\t\n\t\t\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\t\t\tctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\n\t\t\t\t\t\t\tctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\n\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Horizontal\n\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tcursor = {\n\t\t\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\t\tline: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursor = {\n\t\t\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\t\tline: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width,\n\t\t\t\t\t\t\twidth = labelOpts.usePointStyle ?\n\t\t\t\t\t\t\t\tfontSize + (fontSize / 2) + textWidth :\n\t\t\t\t\t\t\t\tboxWidth + (fontSize / 2) + textWidth,\n\t\t\t\t\t\t\tx = cursor.x,\n\t\t\t\t\t\t\ty = cursor.y;\n\t\n\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\t\t\ty = cursor.y = me.top;\n\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tdrawLegendBox(x, y, legendItem);\n\t\n\t\t\t\t\t\thitboxes[i].left = x;\n\t\t\t\t\t\thitboxes[i].top = y;\n\t\n\t\t\t\t\t\t// Fill the actual label\n\t\t\t\t\t\tfillText(x, y, legendItem, textWidth);\n\t\n\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// Handle an event\n\t\t\thandleEvent: function(e) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\n\t\t\t\tif (type === 'mousemove') {\n\t\t\t\t\tif (!opts.onHover) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (type === 'click') {\n\t\t\t\t\tif (!opts.onClick) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar position = helpers.getRelativePosition(e, me.chart.chart),\n\t\t\t\t\tx = position.x,\n\t\t\t\t\ty = position.y;\n\t\n\t\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t\t\t// See if we are touching one of the dataset boxes\n\t\t\t\t\tvar lh = me.legendHitBoxes;\n\t\t\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\t\t\tvar hitBox = lh[i];\n\t\n\t\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t\t\t// Touching an element\n\t\t\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t\t\topts.onClick.call(me, e, me.legendItems[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t\t\topts.onHover.call(me, e, me.legendItems[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\t// Register the legend plugin\n\t\tChart.plugins.register({\n\t\t\tbeforeInit: function(chartInstance) {\n\t\t\t\tvar opts = chartInstance.options;\n\t\t\t\tvar legendOpts = opts.legend;\n\t\n\t\t\t\tif (legendOpts) {\n\t\t\t\t\tchartInstance.legend = new Chart.Legend({\n\t\t\t\t\t\tctx: chartInstance.chart.ctx,\n\t\t\t\t\t\toptions: legendOpts,\n\t\t\t\t\t\tchart: chartInstance\n\t\t\t\t\t});\n\t\n\t\t\t\t\tChart.layoutService.addBox(chartInstance, chartInstance.legend);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.global.tooltips = {\n\t\t\tenabled: true,\n\t\t\tcustom: null,\n\t\t\tmode: 'single',\n\t\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\t\ttitleFontStyle: 'bold',\n\t\t\ttitleSpacing: 2,\n\t\t\ttitleMarginBottom: 6,\n\t\t\ttitleFontColor: '#fff',\n\t\t\ttitleAlign: 'left',\n\t\t\tbodySpacing: 2,\n\t\t\tbodyFontColor: '#fff',\n\t\t\tbodyAlign: 'left',\n\t\t\tfooterFontStyle: 'bold',\n\t\t\tfooterSpacing: 2,\n\t\t\tfooterMarginTop: 6,\n\t\t\tfooterFontColor: '#fff',\n\t\t\tfooterAlign: 'left',\n\t\t\tyPadding: 6,\n\t\t\txPadding: 6,\n\t\t\tyAlign: 'center',\n\t\t\txAlign: 'center',\n\t\t\tcaretSize: 5,\n\t\t\tcornerRadius: 6,\n\t\t\tmultiKeyBackground: '#fff',\n\t\t\tcallbacks: {\n\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\tbeforeTitle: helpers.noop,\n\t\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t\t// Pick first xLabel for now\n\t\t\t\t\tvar title = '';\n\t\t\t\t\tvar labels = data.labels;\n\t\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\t\n\t\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\t\tvar item = tooltipItems[0];\n\t\n\t\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn title;\n\t\t\t\t},\n\t\t\t\tafterTitle: helpers.noop,\n\t\n\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\tbeforeBody: helpers.noop,\n\t\n\t\t\t\t// Args are: (tooltipItem, data)\n\t\t\t\tbeforeLabel: helpers.noop,\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\treturn datasetLabel + ': ' + tooltipItem.yLabel;\n\t\t\t\t},\n\t\t\t\tlabelColor: function(tooltipItem, chartInstance) {\n\t\t\t\t\tvar meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\t\tvar view = activeElement._view;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tafterLabel: helpers.noop,\n\t\n\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\tafterBody: helpers.noop,\n\t\n\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\tbeforeFooter: helpers.noop,\n\t\t\t\tfooter: helpers.noop,\n\t\t\t\tafterFooter: helpers.noop\n\t\t\t}\n\t\t};\n\t\n\t\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\t\tfunction pushOrConcat(base, toPush) {\n\t\t\tif (toPush) {\n\t\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t\t// base = base.concat(toPush);\n\t\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t\t} else {\n\t\t\t\t\tbase.push(toPush);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn base;\n\t\t}\n\t\n\t\tfunction getAveragePosition(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tvar i, len;\n\t\t\tvar xPositions = [];\n\t\t\tvar yPositions = [];\n\t\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\txPositions.push(pos.x);\n\t\t\t\t\tyPositions.push(pos.y);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar x = 0,\n\t\t\t\ty = 0;\n\t\t\tfor (i = 0; i < xPositions.length; ++i) {\n\t\t\t\tif (xPositions[i]) {\n\t\t\t\t\tx += xPositions[i];\n\t\t\t\t\ty += yPositions[i];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tx: Math.round(x / xPositions.length),\n\t\t\t\ty: Math.round(y / xPositions.length)\n\t\t\t};\n\t\t}\n\t\n\t\t// Private helper to create a tooltip iteam model\n\t\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t\t// @return : new tooltip item\n\t\tfunction createTooltipItem(element) {\n\t\t\tvar xScale = element._xScale;\n\t\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\t\tvar index = element._index,\n\t\t\t\tdatasetIndex = element._datasetIndex;\n\t\n\t\t\treturn {\n\t\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\t\tindex: index,\n\t\t\t\tdatasetIndex: datasetIndex\n\t\t\t};\n\t\t}\n\t\n\t\tChart.Tooltip = Chart.Element.extend({\n\t\t\tinitialize: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\t\tvar tooltipOpts = me._options;\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\n\t\t\t\thelpers.extend(me, {\n\t\t\t\t\t_model: {\n\t\t\t\t\t\t// Positioning\n\t\t\t\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\t\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\t\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\t\t\t\tyAlign: tooltipOpts.yAlign,\n\t\n\t\t\t\t\t\t// Body\n\t\t\t\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t\t\t\t_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\t\t_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\t\t\t\tbodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\t\n\t\t\t\t\t\t// Title\n\t\t\t\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t\t\t\t_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\t\t_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\t\ttitleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\t\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\t\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\t\n\t\t\t\t\t\t// Footer\n\t\t\t\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t\t\t\t_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\t\t_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\t\tfooterFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\t\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\t\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\t\n\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\t\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\t\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\t\t\t\topacity: 0,\n\t\t\t\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\t// Get the title\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tgetTitle: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me._options;\n\t\t\t\tvar callbacks = opts.callbacks;\n\t\n\t\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments),\n\t\t\t\t\ttitle = callbacks.title.apply(me, arguments),\n\t\t\t\t\tafterTitle = callbacks.afterTitle.apply(me, arguments);\n\t\n\t\t\t\tvar lines = [];\n\t\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\t\tlines = pushOrConcat(lines, title);\n\t\t\t\tlines = pushOrConcat(lines, afterTitle);\n\t\n\t\t\t\treturn lines;\n\t\t\t},\n\t\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tgetBeforeBody: function() {\n\t\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t\t},\n\t\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tgetBody: function(tooltipItems, data) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar callbacks = me._options.callbacks;\n\t\t\t\tvar bodyItems = [];\n\t\n\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tvar bodyItem = {\n\t\t\t\t\t\tbefore: [],\n\t\t\t\t\t\tlines: [],\n\t\t\t\t\t\tafter: []\n\t\t\t\t\t};\n\t\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\t\n\t\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t\t});\n\t\n\t\t\t\treturn bodyItems;\n\t\t\t},\n\t\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tgetAfterBody: function() {\n\t\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t\t},\n\t\n\t\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tgetFooter: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar callbacks = me._options.callbacks;\n\t\n\t\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\t\n\t\t\t\tvar lines = [];\n\t\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\t\tlines = pushOrConcat(lines, afterFooter);\n\t\n\t\t\t\treturn lines;\n\t\t\t},\n\t\n\t\t\tupdate: function(changed) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me._options;\n\t\t\t\tvar model = me._model;\n\t\t\t\tvar active = me._active;\n\t\n\t\t\t\tvar data = me._data;\n\t\t\t\tvar chartInstance = me._chartInstance;\n\t\n\t\t\t\tvar i, len;\n\t\n\t\t\t\tif (active.length) {\n\t\t\t\t\tmodel.opacity = 1;\n\t\n\t\t\t\t\tvar labelColors = [],\n\t\t\t\t\t\ttooltipPosition = getAveragePosition(active);\n\t\n\t\t\t\t\tvar tooltipItems = [];\n\t\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// If there is more than one item, show color items\n\t\t\t\t\tif (active.length > 1) {\n\t\t\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Build the Text Lines\n\t\t\t\t\thelpers.extend(model, {\n\t\t\t\t\t\ttitle: me.getTitle(tooltipItems, data),\n\t\t\t\t\t\tbeforeBody: me.getBeforeBody(tooltipItems, data),\n\t\t\t\t\t\tbody: me.getBody(tooltipItems, data),\n\t\t\t\t\t\tafterBody: me.getAfterBody(tooltipItems, data),\n\t\t\t\t\t\tfooter: me.getFooter(tooltipItems, data),\n\t\t\t\t\t\tx: Math.round(tooltipPosition.x),\n\t\t\t\t\t\ty: Math.round(tooltipPosition.y),\n\t\t\t\t\t\tcaretPadding: helpers.getValueOrDefault(tooltipPosition.padding, 2),\n\t\t\t\t\t\tlabelColors: labelColors\n\t\t\t\t\t});\n\t\n\t\t\t\t\t// We need to determine alignment of\n\t\t\t\t\tvar tooltipSize = me.getTooltipSize(model);\n\t\t\t\t\tme.determineAlignment(tooltipSize); // Smart Tooltip placement to stay on the canvas\n\t\n\t\t\t\t\thelpers.extend(model, me.getBackgroundPoint(model, tooltipSize));\n\t\t\t\t} else {\n\t\t\t\t\tme._model.opacity = 0;\n\t\t\t\t}\n\t\n\t\t\t\tif (changed && opts.custom) {\n\t\t\t\t\topts.custom.call(me, model);\n\t\t\t\t}\n\t\n\t\t\t\treturn me;\n\t\t\t},\n\t\t\tgetTooltipSize: function(vm) {\n\t\t\t\tvar ctx = this._chart.ctx;\n\t\n\t\t\t\tvar size = {\n\t\t\t\t\theight: vm.yPadding * 2, // Tooltip Padding\n\t\t\t\t\twidth: 0\n\t\t\t\t};\n\t\n\t\t\t\t// Count of all lines in the body\n\t\t\t\tvar body = vm.body;\n\t\t\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t\t\t}, 0);\n\t\t\t\tcombinedBodyLength += vm.beforeBody.length + vm.afterBody.length;\n\t\n\t\t\t\tvar titleLineCount = vm.title.length;\n\t\t\t\tvar footerLineCount = vm.footer.length;\n\t\t\t\tvar titleFontSize = vm.titleFontSize,\n\t\t\t\t\tbodyFontSize = vm.bodyFontSize,\n\t\t\t\t\tfooterFontSize = vm.footerFontSize;\n\t\n\t\t\t\tsize.height += titleLineCount * titleFontSize; // Title Lines\n\t\t\t\tsize.height += (titleLineCount - 1) * vm.titleSpacing; // Title Line Spacing\n\t\t\t\tsize.height += titleLineCount ? vm.titleMarginBottom : 0; // Title's bottom Margin\n\t\t\t\tsize.height += combinedBodyLength * bodyFontSize; // Body Lines\n\t\t\t\tsize.height += combinedBodyLength ? (combinedBodyLength - 1) * vm.bodySpacing : 0; // Body Line Spacing\n\t\t\t\tsize.height += footerLineCount ? vm.footerMarginTop : 0; // Footer Margin\n\t\t\t\tsize.height += footerLineCount * (footerFontSize); // Footer Lines\n\t\t\t\tsize.height += footerLineCount ? (footerLineCount - 1) * vm.footerSpacing : 0; // Footer Line Spacing\n\t\n\t\t\t\t// Title width\n\t\t\t\tvar widthPadding = 0;\n\t\t\t\tvar maxLineWidth = function(line) {\n\t\t\t\t\tsize.width = Math.max(size.width, ctx.measureText(line).width + widthPadding);\n\t\t\t\t};\n\t\n\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\t\t\t\thelpers.each(vm.title, maxLineWidth);\n\t\n\t\t\t\t// Body width\n\t\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\t\t\t\thelpers.each(vm.beforeBody.concat(vm.afterBody), maxLineWidth);\n\t\n\t\t\t\t// Body lines may include some extra width due to the color box\n\t\t\t\twidthPadding = body.length > 1 ? (bodyFontSize + 2) : 0;\n\t\t\t\thelpers.each(body, function(bodyItem) {\n\t\t\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t\t\t});\n\t\n\t\t\t\t// Reset back to 0\n\t\t\t\twidthPadding = 0;\n\t\n\t\t\t\t// Footer width\n\t\t\t\tctx.font = helpers.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\t\t\t\thelpers.each(vm.footer, maxLineWidth);\n\t\n\t\t\t\t// Add padding\n\t\t\t\tsize.width += 2 * vm.xPadding;\n\t\n\t\t\t\treturn size;\n\t\t\t},\n\t\t\tdetermineAlignment: function(size) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar model = me._model;\n\t\t\t\tvar chart = me._chart;\n\t\t\t\tvar chartArea = me._chartInstance.chartArea;\n\t\n\t\t\t\tif (model.y < size.height) {\n\t\t\t\t\tmodel.yAlign = 'top';\n\t\t\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\t\t\tmodel.yAlign = 'bottom';\n\t\t\t\t}\n\t\n\t\t\t\tvar lf, rf; // functions to determine left, right alignment\n\t\t\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\t\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\t\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\t\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\t\n\t\t\t\tif (model.yAlign === 'center') {\n\t\t\t\t\tlf = function(x) {\n\t\t\t\t\t\treturn x <= midX;\n\t\t\t\t\t};\n\t\t\t\t\trf = function(x) {\n\t\t\t\t\t\treturn x > midX;\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tlf = function(x) {\n\t\t\t\t\t\treturn x <= (size.width / 2);\n\t\t\t\t\t};\n\t\t\t\t\trf = function(x) {\n\t\t\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\tolf = function(x) {\n\t\t\t\t\treturn x + size.width > chart.width;\n\t\t\t\t};\n\t\t\t\torf = function(x) {\n\t\t\t\t\treturn x - size.width < 0;\n\t\t\t\t};\n\t\t\t\tyf = function(y) {\n\t\t\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t\t\t};\n\t\n\t\t\t\tif (lf(model.x)) {\n\t\t\t\t\tmodel.xAlign = 'left';\n\t\n\t\t\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\t\t\tif (olf(model.x)) {\n\t\t\t\t\t\tmodel.xAlign = 'center';\n\t\t\t\t\t\tmodel.yAlign = yf(model.y);\n\t\t\t\t\t}\n\t\t\t\t} else if (rf(model.x)) {\n\t\t\t\t\tmodel.xAlign = 'right';\n\t\n\t\t\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\t\t\tif (orf(model.x)) {\n\t\t\t\t\t\tmodel.xAlign = 'center';\n\t\t\t\t\t\tmodel.yAlign = yf(model.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetBackgroundPoint: function(vm, size) {\n\t\t\t\t// Background Position\n\t\t\t\tvar pt = {\n\t\t\t\t\tx: vm.x,\n\t\t\t\t\ty: vm.y\n\t\t\t\t};\n\t\n\t\t\t\tvar caretSize = vm.caretSize,\n\t\t\t\t\tcaretPadding = vm.caretPadding,\n\t\t\t\t\tcornerRadius = vm.cornerRadius,\n\t\t\t\t\txAlign = vm.xAlign,\n\t\t\t\t\tyAlign = vm.yAlign,\n\t\t\t\t\tpaddingAndSize = caretSize + caretPadding,\n\t\t\t\t\tradiusAndPadding = cornerRadius + caretPadding;\n\t\n\t\t\t\tif (xAlign === 'right') {\n\t\t\t\t\tpt.x -= size.width;\n\t\t\t\t} else if (xAlign === 'center') {\n\t\t\t\t\tpt.x -= (size.width / 2);\n\t\t\t\t}\n\t\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\tpt.y += paddingAndSize;\n\t\t\t\t} else if (yAlign === 'bottom') {\n\t\t\t\t\tpt.y -= size.height + paddingAndSize;\n\t\t\t\t} else {\n\t\t\t\t\tpt.y -= (size.height / 2);\n\t\t\t\t}\n\t\n\t\t\t\tif (yAlign === 'center') {\n\t\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\t\tpt.x += paddingAndSize;\n\t\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\t\tpt.x -= paddingAndSize;\n\t\t\t\t\t}\n\t\t\t\t} else if (xAlign === 'left') {\n\t\t\t\t\tpt.x -= radiusAndPadding;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tpt.x += radiusAndPadding;\n\t\t\t\t}\n\t\n\t\t\t\treturn pt;\n\t\t\t},\n\t\t\tdrawCaret: function(tooltipPoint, size, opacity) {\n\t\t\t\tvar vm = this._view;\n\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\tvar x1, x2, x3;\n\t\t\t\tvar y1, y2, y3;\n\t\t\t\tvar caretSize = vm.caretSize;\n\t\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\t\tvar xAlign = vm.xAlign,\n\t\t\t\t\tyAlign = vm.yAlign;\n\t\t\t\tvar ptX = tooltipPoint.x,\n\t\t\t\t\tptY = tooltipPoint.y;\n\t\t\t\tvar width = size.width,\n\t\t\t\t\theight = size.height;\n\t\n\t\t\t\tif (yAlign === 'center') {\n\t\t\t\t\t// Left or right side\n\t\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\t\tx1 = ptX;\n\t\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\t\tx3 = x1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\t\tx3 = x1;\n\t\t\t\t\t}\n\t\n\t\t\t\t\ty2 = ptY + (height / 2);\n\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\t\tx1 = ptX + cornerRadius;\n\t\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\t\tx1 = ptX + width - cornerRadius;\n\t\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\t\tx3 = x2 - caretSize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx2 = ptX + (width / 2);\n\t\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\t\ty1 = ptY;\n\t\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\t\ty3 = y1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\t\ty3 = y1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar bgColor = helpers.color(vm.backgroundColor);\n\t\t\t\tctx.fillStyle = bgColor.alpha(opacity * bgColor.alpha()).rgbString();\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(x1, y1);\n\t\t\t\tctx.lineTo(x2, y2);\n\t\t\t\tctx.lineTo(x3, y3);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fill();\n\t\t\t},\n\t\t\tdrawTitle: function(pt, vm, ctx, opacity) {\n\t\t\t\tvar title = vm.title;\n\t\n\t\t\t\tif (title.length) {\n\t\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\t\tctx.textBaseline = 'top';\n\t\n\t\t\t\t\tvar titleFontSize = vm.titleFontSize,\n\t\t\t\t\t\ttitleSpacing = vm.titleSpacing;\n\t\n\t\t\t\t\tvar titleFontColor = helpers.color(vm.titleFontColor);\n\t\t\t\t\tctx.fillStyle = titleFontColor.alpha(opacity * titleFontColor.alpha()).rgbString();\n\t\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\t\n\t\t\t\t\tvar i, len;\n\t\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\t\n\t\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdrawBody: function(pt, vm, ctx, opacity) {\n\t\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\t\tvar body = vm.body;\n\t\n\t\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\t\n\t\t\t\tvar bodyFontColor = helpers.color(vm.bodyFontColor);\n\t\t\t\tvar textColor = bodyFontColor.alpha(opacity * bodyFontColor.alpha()).rgbString();\n\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\t\n\t\t\t\t// Before Body\n\t\t\t\tvar xLinePadding = 0;\n\t\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t\t};\n\t\n\t\t\t\t// Before body lines\n\t\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\t\n\t\t\t\tvar drawColorBoxes = body.length > 1;\n\t\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n\t\n\t\t\t\t// Draw body lines now\n\t\t\t\thelpers.each(body, function(bodyItem, i) {\n\t\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\t\n\t\t\t\t\thelpers.each(bodyItem.lines, function(line) {\n\t\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\t\tctx.fillStyle = helpers.color(vm.legendColorBackground).alpha(opacity).rgbaString();\n\t\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\t\n\t\t\t\t\t\t\t// Border\n\t\t\t\t\t\t\tctx.strokeStyle = helpers.color(vm.labelColors[i].borderColor).alpha(opacity).rgbaString();\n\t\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\t\n\t\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\t\tctx.fillStyle = helpers.color(vm.labelColors[i].backgroundColor).alpha(opacity).rgbaString();\n\t\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\t\n\t\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t\t});\n\t\n\t\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t\t});\n\t\n\t\t\t\t// Reset back to 0 for after body\n\t\t\t\txLinePadding = 0;\n\t\n\t\t\t\t// After body lines\n\t\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t\t},\n\t\t\tdrawFooter: function(pt, vm, ctx, opacity) {\n\t\t\t\tvar footer = vm.footer;\n\t\n\t\t\t\tif (footer.length) {\n\t\t\t\t\tpt.y += vm.footerMarginTop;\n\t\n\t\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\t\tctx.textBaseline = 'top';\n\t\n\t\t\t\t\tvar footerFontColor = helpers.color(vm.footerFontColor);\n\t\t\t\t\tctx.fillStyle = footerFontColor.alpha(opacity * footerFontColor.alpha()).rgbString();\n\t\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\t\n\t\t\t\t\thelpers.each(footer, function(line) {\n\t\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tdraw: function() {\n\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\tvar vm = this._view;\n\t\n\t\t\t\tif (vm.opacity === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar tooltipSize = this.getTooltipSize(vm);\n\t\t\t\tvar pt = {\n\t\t\t\t\tx: vm.x,\n\t\t\t\t\ty: vm.y\n\t\t\t\t};\n\t\n\t\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\t\n\t\t\t\tif (this._options.enabled) {\n\t\t\t\t\t// Draw Background\n\t\t\t\t\tvar bgColor = helpers.color(vm.backgroundColor);\n\t\t\t\t\tctx.fillStyle = bgColor.alpha(opacity * bgColor.alpha()).rgbString();\n\t\t\t\t\thelpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);\n\t\t\t\t\tctx.fill();\n\t\n\t\t\t\t\t// Draw Caret\n\t\t\t\t\tthis.drawCaret(pt, tooltipSize, opacity);\n\t\n\t\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\t\tpt.y += vm.yPadding;\n\t\n\t\t\t\t\t// Titles\n\t\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\t\n\t\t\t\t\t// Body\n\t\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\t\n\t\t\t\t\t// Footer\n\t\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers,\n\t\t\tglobalOpts = Chart.defaults.global;\n\t\n\t\tglobalOpts.elements.arc = {\n\t\t\tbackgroundColor: globalOpts.defaultColor,\n\t\t\tborderColor: '#fff',\n\t\t\tborderWidth: 2\n\t\t};\n\t\n\t\tChart.elements.Arc = Chart.Element.extend({\n\t\t\tinLabelRange: function(mouseX) {\n\t\t\t\tvar vm = this._view;\n\t\n\t\t\t\tif (vm) {\n\t\t\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tinRange: function(chartX, chartY) {\n\t\t\t\tvar vm = this._view;\n\t\n\t\t\t\tif (vm) {\n\t\t\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {\n\t\t\t\t\t\t\tx: chartX,\n\t\t\t\t\t\t\ty: chartY\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tangle = pointRelativePosition.angle,\n\t\t\t\t\t\tdistance = pointRelativePosition.distance;\n\t\n\t\t\t\t\t// Sanitise angle range\n\t\t\t\t\tvar startAngle = vm.startAngle;\n\t\t\t\t\tvar endAngle = vm.endAngle;\n\t\t\t\t\twhile (endAngle < startAngle) {\n\t\t\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t\t\t}\n\t\t\t\t\twhile (angle > endAngle) {\n\t\t\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t\t\t}\n\t\t\t\t\twhile (angle < startAngle) {\n\t\t\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Check if within the range of the open/close angle\n\t\t\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle),\n\t\t\t\t\t\twithinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\t\n\t\t\t\t\treturn (betweenAngles && withinRadius);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttooltipPosition: function() {\n\t\t\t\tvar vm = this._view;\n\t\n\t\t\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),\n\t\t\t\t\trangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\t\t\t\treturn {\n\t\t\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t\t\t};\n\t\t\t},\n\t\t\tdraw: function() {\n\t\n\t\t\t\tvar ctx = this._chart.ctx,\n\t\t\t\t\tvm = this._view,\n\t\t\t\t\tsA = vm.startAngle,\n\t\t\t\t\teA = vm.endAngle;\n\t\n\t\t\t\tctx.beginPath();\n\t\n\t\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\t\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\t\tctx.lineWidth = vm.borderWidth;\n\t\n\t\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\n\t\t\t\tctx.fill();\n\t\t\t\tctx.lineJoin = 'bevel';\n\t\n\t\t\t\tif (vm.borderWidth) {\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\n\t\tChart.defaults.global.elements.line = {\n\t\t\ttension: 0.4,\n\t\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\t\tborderWidth: 3,\n\t\t\tborderColor: globalDefaults.defaultColor,\n\t\t\tborderCapStyle: 'butt',\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0,\n\t\t\tborderJoinStyle: 'miter',\n\t\t\tcapBezierPoints: true,\n\t\t\tfill: true // do we fill in the area between the line and its base axis\n\t\t};\n\t\n\t\tChart.elements.Line = Chart.Element.extend({\n\t\t\tdraw: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar vm = me._view;\n\t\t\t\tvar spanGaps = vm.spanGaps;\n\t\t\t\tvar scaleZero = vm.scaleZero;\n\t\t\t\tvar loop = me._loop;\n\t\n\t\t\t\tvar ctx = me._chart.ctx;\n\t\t\t\tctx.save();\n\t\n\t\t\t\t// Helper function to draw a line to a point\n\t\t\t\tfunction lineToPoint(previousPoint, point) {\n\t\t\t\t\tvar pointVM = point._view;\n\t\t\t\t\tif (point._view.steppedLine === true) {\n\t\t\t\t\t\tctx.lineTo(pointVM.x, previousPoint._view.y);\n\t\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t\t} else if (point._view.tension === 0) {\n\t\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.bezierCurveTo(\n\t\t\t\t\t\t\tpreviousPoint._view.controlPointNextX,\n\t\t\t\t\t\t\tpreviousPoint._view.controlPointNextY,\n\t\t\t\t\t\t\tpointVM.controlPointPreviousX,\n\t\t\t\t\t\t\tpointVM.controlPointPreviousY,\n\t\t\t\t\t\t\tpointVM.x,\n\t\t\t\t\t\t\tpointVM.y\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar points = me._children.slice(); // clone array\n\t\t\t\tvar lastDrawnIndex = -1;\n\t\n\t\t\t\t// If we are looping, adding the first point again\n\t\t\t\tif (loop && points.length) {\n\t\t\t\t\tpoints.push(points[0]);\n\t\t\t\t}\n\t\n\t\t\t\tvar index, current, previous, currentVM;\n\t\n\t\t\t\t// Fill Line\n\t\t\t\tif (points.length && vm.fill) {\n\t\t\t\t\tctx.beginPath();\n\t\n\t\t\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\t\t\tcurrent = points[index];\n\t\t\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\t\t\tcurrentVM = current._view;\n\t\n\t\t\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\tctx.moveTo(scaleZero.x, scaleZero.y);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tctx.moveTo(currentVM.x, scaleZero);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\t\n\t\t\t\t\t\t\tif (currentVM.skip) {\n\t\t\t\t\t\t\t\t// Only do this if this is the first point that is skipped\n\t\t\t\t\t\t\t\tif (!spanGaps && lastDrawnIndex === (index - 1)) {\n\t\t\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t\t\tctx.lineTo(scaleZero.x, scaleZero.y);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tctx.lineTo(previous._view.x, scaleZero);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (lastDrawnIndex !== (index - 1)) {\n\t\t\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\n\t\t\t\t\t\t\t\t\t// If the first data point is NaN, then there is no real gap to skip\n\t\t\t\t\t\t\t\t\tif (spanGaps && lastDrawnIndex !== -1) {\n\t\t\t\t\t\t\t\t\t\t// We are spanning the gap, so simple draw a line to this point\n\t\t\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t\t\t} else if (loop) {\n\t\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, scaleZero);\n\t\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (!loop && lastDrawnIndex !== -1) {\n\t\t\t\t\t\tctx.lineTo(points[lastDrawnIndex]._view.x, scaleZero);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\n\t\t\t\t// Stroke Line Options\n\t\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\t\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\t\n\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t\t\t}\n\t\n\t\t\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\t\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\t\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\t\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\t\n\t\t\t\t// Stroke Line\n\t\t\t\tctx.beginPath();\n\t\t\t\tlastDrawnIndex = -1;\n\t\n\t\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\t\tcurrent = points[index];\n\t\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\t\tcurrentVM = current._view;\n\t\n\t\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\t\n\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers,\n\t\t\tglobalOpts = Chart.defaults.global,\n\t\t\tdefaultColor = globalOpts.defaultColor;\n\t\n\t\tglobalOpts.elements.point = {\n\t\t\tradius: 3,\n\t\t\tpointStyle: 'circle',\n\t\t\tbackgroundColor: defaultColor,\n\t\t\tborderWidth: 1,\n\t\t\tborderColor: defaultColor,\n\t\t\t// Hover\n\t\t\thitRadius: 1,\n\t\t\thoverRadius: 4,\n\t\t\thoverBorderWidth: 1\n\t\t};\n\t\n\t\tChart.elements.Point = Chart.Element.extend({\n\t\t\tinRange: function(mouseX, mouseY) {\n\t\t\t\tvar vm = this._view;\n\t\t\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t\t\t},\n\t\t\tinLabelRange: function(mouseX) {\n\t\t\t\tvar vm = this._view;\n\t\t\t\treturn vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n\t\t\t},\n\t\t\ttooltipPosition: function() {\n\t\t\t\tvar vm = this._view;\n\t\t\t\treturn {\n\t\t\t\t\tx: vm.x,\n\t\t\t\t\ty: vm.y,\n\t\t\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t\t\t};\n\t\t\t},\n\t\t\tdraw: function() {\n\t\t\t\tvar vm = this._view;\n\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\tvar pointStyle = vm.pointStyle;\n\t\t\t\tvar radius = vm.radius;\n\t\t\t\tvar x = vm.x;\n\t\t\t\tvar y = vm.y;\n\t\n\t\t\t\tif (vm.skip) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\t\t\tctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\n\t\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\t\n\t\t\t\tChart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar globalOpts = Chart.defaults.global;\n\t\n\t\tglobalOpts.elements.rectangle = {\n\t\t\tbackgroundColor: globalOpts.defaultColor,\n\t\t\tborderWidth: 0,\n\t\t\tborderColor: globalOpts.defaultColor,\n\t\t\tborderSkipped: 'bottom'\n\t\t};\n\t\n\t\tChart.elements.Rectangle = Chart.Element.extend({\n\t\t\tdraw: function() {\n\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\tvar vm = this._view;\n\t\n\t\t\t\tvar halfWidth = vm.width / 2,\n\t\t\t\t\tleftX = vm.x - halfWidth,\n\t\t\t\t\trightX = vm.x + halfWidth,\n\t\t\t\t\ttop = vm.base - (vm.base - vm.y),\n\t\t\t\t\thalfStroke = vm.borderWidth / 2;\n\t\n\t\t\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\t\t\tif (vm.borderWidth) {\n\t\t\t\t\tleftX += halfStroke;\n\t\t\t\t\trightX -= halfStroke;\n\t\t\t\t\ttop += halfStroke;\n\t\t\t\t}\n\t\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\t\tctx.lineWidth = vm.borderWidth;\n\t\n\t\t\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t\t\t// | 1 2 |\n\t\t\t\t// | 0 3 |\n\t\t\t\tvar corners = [\n\t\t\t\t\t[leftX, vm.base],\n\t\t\t\t\t[leftX, top],\n\t\t\t\t\t[rightX, top],\n\t\t\t\t\t[rightX, vm.base]\n\t\t\t\t];\n\t\n\t\t\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\t\t\tvar startCorner = borders.indexOf(vm.borderSkipped, 0);\n\t\t\t\tif (startCorner === -1) {\n\t\t\t\t\tstartCorner = 0;\n\t\t\t\t}\n\t\n\t\t\t\tfunction cornerAt(index) {\n\t\t\t\t\treturn corners[(startCorner + index) % 4];\n\t\t\t\t}\n\t\n\t\t\t\t// Draw rectangle from 'startCorner'\n\t\t\t\tctx.moveTo.apply(ctx, cornerAt(0));\n\t\t\t\tfor (var i = 1; i < 4; i++) {\n\t\t\t\t\tctx.lineTo.apply(ctx, cornerAt(i));\n\t\t\t\t}\n\t\n\t\t\t\tctx.fill();\n\t\t\t\tif (vm.borderWidth) {\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t},\n\t\t\theight: function() {\n\t\t\t\tvar vm = this._view;\n\t\t\t\treturn vm.base - vm.y;\n\t\t\t},\n\t\t\tinRange: function(mouseX, mouseY) {\n\t\t\t\tvar vm = this._view;\n\t\t\t\treturn vm ?\n\t\t\t\t\t\t(vm.y < vm.base ?\n\t\t\t\t\t\t\t(mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) && (mouseY >= vm.y && mouseY <= vm.base) :\n\t\t\t\t\t\t\t(mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) && (mouseY >= vm.base && mouseY <= vm.y)) :\n\t\t\t\t\t\tfalse;\n\t\t\t},\n\t\t\tinLabelRange: function(mouseX) {\n\t\t\t\tvar vm = this._view;\n\t\t\t\treturn vm ? (mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) : false;\n\t\t\t},\n\t\t\ttooltipPosition: function() {\n\t\t\t\tvar vm = this._view;\n\t\t\t\treturn {\n\t\t\t\t\tx: vm.x,\n\t\t\t\t\ty: vm.y\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\n\t};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers,\n\t\t\tnoop = helpers.noop;\n\t\n\t\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\t\thandleTickRangeOptions: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar tickOpts = opts.ticks;\n\t\n\t\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t\t// axis, they can manually override it\n\t\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\t\tvar maxSign = helpers.sign(me.max);\n\t\n\t\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t\t// move the top up to 0\n\t\t\t\t\t\tme.max = 0;\n\t\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t\t// move the botttom down to 0\n\t\t\t\t\t\tme.min = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\t\tme.min = tickOpts.min;\n\t\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\n\t\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\t\tme.max = tickOpts.max;\n\t\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\n\t\t\t\tif (me.min === me.max) {\n\t\t\t\t\tme.max++;\n\t\n\t\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\t\tme.min--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetTickLimit: noop,\n\t\t\thandleDirectionalChanges: noop,\n\t\n\t\t\tbuildTicks: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar ticks = me.ticks = [];\n\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\n\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t// the graph\n\t\n\t\t\t\tvar maxTicks = me.getTickLimit();\n\t\n\t\t\t\t// Make sure we always have at least 2 ticks\n\t\t\t\tmaxTicks = Math.max(2, maxTicks);\n\t\n\t\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t\t\t// for details.\n\t\n\t\t\t\tvar spacing;\n\t\t\t\tvar fixedStepSizeSet = (tickOpts.fixedStepSize && tickOpts.fixedStepSize > 0) || (tickOpts.stepSize && tickOpts.stepSize > 0);\n\t\t\t\tif (fixedStepSizeSet) {\n\t\t\t\t\tspacing = getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize);\n\t\t\t\t} else {\n\t\t\t\t\tvar niceRange = helpers.niceNum(me.max - me.min, false);\n\t\t\t\t\tspacing = helpers.niceNum(niceRange / (maxTicks - 1), true);\n\t\t\t\t}\n\t\t\t\tvar niceMin = Math.floor(me.min / spacing) * spacing;\n\t\t\t\tvar niceMax = Math.ceil(me.max / spacing) * spacing;\n\t\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t\n\t\t\t\t// If very close to our rounded value, use it.\n\t\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t\t\t} else {\n\t\t\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t\t\t}\n\t\n\t\t\t\t// Put the values into the ticks array\n\t\t\t\tticks.push(tickOpts.min !== undefined ? tickOpts.min : niceMin);\n\t\t\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\t\t\tticks.push(niceMin + (j * spacing));\n\t\t\t\t}\n\t\t\t\tticks.push(tickOpts.max !== undefined ? tickOpts.max : niceMax);\n\t\n\t\t\t\tme.handleDirectionalChanges();\n\t\n\t\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t\t// range of the scale\n\t\t\t\tme.max = helpers.max(ticks);\n\t\t\t\tme.min = helpers.min(ticks);\n\t\n\t\t\t\tif (tickOpts.reverse) {\n\t\t\t\t\tticks.reverse();\n\t\n\t\t\t\t\tme.start = me.max;\n\t\t\t\t\tme.end = me.min;\n\t\t\t\t} else {\n\t\t\t\t\tme.start = me.min;\n\t\t\t\t\tme.end = me.max;\n\t\t\t\t}\n\t\t\t},\n\t\t\tconvertTicksToLabels: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\t\n\t\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\t// Default config for a category scale\n\t\tvar defaultConfig = {\n\t\t\tposition: 'bottom'\n\t\t};\n\t\n\t\tvar DatasetScale = Chart.Scale.extend({\n\t\t\t/**\n\t\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use tose\n\t\t\t* else fall back to data.labels\n\t\t\t* @private\n\t\t\t*/\n\t\t\tgetLabels: function() {\n\t\t\t\tvar data = this.chart.data;\n\t\t\t\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t\t},\n\t\t\t// Implement this so that\n\t\t\tdetermineDataLimits: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tme.minIndex = 0;\n\t\t\t\tme.maxIndex = labels.length - 1;\n\t\t\t\tvar findIndex;\n\t\n\t\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t\t// user specified min value\n\t\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\n\t\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t\t}\n\t\n\t\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t\t// user specified max value\n\t\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\n\t\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t\t}\n\t\n\t\t\t\tme.min = labels[me.minIndex];\n\t\t\t\tme.max = labels[me.maxIndex];\n\t\t\t},\n\t\n\t\t\tbuildTicks: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t\t},\n\t\n\t\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar data = me.chart.data;\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\n\t\t\t\tif ((data.xLabels && isHorizontal) || (data.yLabels && !isHorizontal)) {\n\t\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t\t}\n\t\t\t\treturn me.ticks[index];\n\t\t\t},\n\t\n\t\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {\n\t\t\t\tvar me = this;\n\t\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\n\t\t\t\tif (value !== undefined && isNaN(index)) {\n\t\t\t\t\tvar labels = me.getLabels();\n\t\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t\t}\n\t\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\t\tvar valueWidth = innerWidth / offsetAmt;\n\t\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex)) + me.paddingLeft;\n\t\n\t\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n\t\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t\t}\n\t\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\t\tvar valueHeight = innerHeight / offsetAmt;\n\t\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex)) + me.paddingTop;\n\t\n\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {\n\t\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t\t}\n\t\n\t\t\t\treturn me.top + Math.round(heightOffset);\n\t\t\t},\n\t\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n\t\t\t},\n\t\t\tgetValueForPixel: function(pixel) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar value;\n\t\t\t\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\t\tvar horz = me.isHorizontal();\n\t\t\t\tvar innerDimension = horz ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);\n\t\t\t\tvar valueDimension = innerDimension / offsetAmt;\n\t\n\t\t\t\tpixel -= horz ? me.left : me.top;\n\t\n\t\t\t\tif (me.options.gridLines.offsetGridLines) {\n\t\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t\t}\n\t\t\t\tpixel -= horz ? me.paddingLeft : me.paddingTop;\n\t\n\t\t\t\tif (pixel <= 0) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t\t}\n\t\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tgetBasePixel: function() {\n\t\t\t\treturn this.bottom;\n\t\t\t}\n\t\t});\n\t\n\t\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\t\n\t};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tvar defaultConfig = {\n\t\t\tposition: 'left',\n\t\t\tticks: {\n\t\t\t\tcallback: function(tickValue, index, ticks) {\n\t\t\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\t\n\t\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t\t\t// not an integer\n\t\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\t\t\tvar tickString = '';\n\t\n\t\t\t\t\tif (tickValue !== 0) {\n\t\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn tickString;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tvar LinearScale = Chart.LinearScaleBase.extend({\n\t\t\tdetermineDataLimits: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tvar data = chart.data;\n\t\t\t\tvar datasets = data.datasets;\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\n\t\t\t\tfunction IDMatches(meta) {\n\t\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t\t}\n\t\n\t\t\t\t// First Calculate the range\n\t\t\t\tme.min = null;\n\t\t\t\tme.max = null;\n\t\n\t\t\t\tif (opts.stacked) {\n\t\t\t\t\tvar valuesPerType = {};\n\t\n\t\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\tif (valuesPerType[meta.type] === undefined) {\n\t\t\t\t\t\t\tvaluesPerType[meta.type] = {\n\t\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Store these per type\n\t\t\t\t\t\tvar positiveValues = valuesPerType[meta.type].positiveValues;\n\t\t\t\t\t\tvar negativeValues = valuesPerType[meta.type].negativeValues;\n\t\n\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\t\n\t\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\thelpers.each(valuesPerType, function(valuesForType) {\n\t\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t});\n\t\n\t\t\t\t} else {\n\t\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\t\tthis.handleTickRangeOptions();\n\t\t\t},\n\t\t\tgetTickLimit: function() {\n\t\t\t\tvar maxTicks;\n\t\t\t\tvar me = this;\n\t\t\t\tvar tickOpts = me.options.ticks;\n\t\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t\t} else {\n\t\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t\t}\n\t\n\t\t\t\treturn maxTicks;\n\t\t\t},\n\t\t\t// Called after the ticks are built. We need\n\t\t\thandleDirectionalChanges: function() {\n\t\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\t\tthis.ticks.reverse();\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t\t},\n\t\t\t// Utils\n\t\t\tgetPixelForValue: function(value) {\n\t\t\t\t// This must be called after fit has been run so that\n\t\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\t\tvar me = this;\n\t\t\t\tvar paddingLeft = me.paddingLeft;\n\t\t\t\tvar paddingBottom = me.paddingBottom;\n\t\t\t\tvar start = me.start;\n\t\n\t\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\t\tvar pixel;\n\t\t\t\tvar innerDimension;\n\t\t\t\tvar range = me.end - start;\n\t\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tinnerDimension = me.width - (paddingLeft + me.paddingRight);\n\t\t\t\t\tpixel = me.left + (innerDimension / range * (rightValue - start));\n\t\t\t\t\treturn Math.round(pixel + paddingLeft);\n\t\t\t\t}\n\t\t\t\tinnerDimension = me.height - (me.paddingTop + paddingBottom);\n\t\t\t\tpixel = (me.bottom - paddingBottom) - (innerDimension / range * (rightValue - start));\n\t\t\t\treturn Math.round(pixel);\n\t\t\t},\n\t\t\tgetValueForPixel: function(pixel) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\tvar paddingLeft = me.paddingLeft;\n\t\t\t\tvar paddingBottom = me.paddingBottom;\n\t\t\t\tvar innerDimension = isHorizontal ? me.width - (paddingLeft + me.paddingRight) : me.height - (me.paddingTop + paddingBottom);\n\t\t\t\tvar offset = (isHorizontal ? pixel - me.left - paddingLeft : me.bottom - paddingBottom - pixel) / innerDimension;\n\t\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t\t},\n\t\t\tgetPixelForTick: function(index) {\n\t\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t\t}\n\t\t});\n\t\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\t\n\t};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tvar defaultConfig = {\n\t\t\tposition: 'left',\n\t\n\t\t\t// label settings\n\t\t\tticks: {\n\t\t\t\tcallback: function(value, index, arr) {\n\t\t\t\t\tvar remain = value / (Math.pow(10, Math.floor(helpers.log10(value))));\n\t\n\t\t\t\t\tif (value === 0) {\n\t\t\t\t\t\treturn '0';\n\t\t\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === arr.length - 1) {\n\t\t\t\t\t\treturn value.toExponential();\n\t\t\t\t\t}\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tvar LogarithmicScale = Chart.Scale.extend({\n\t\t\tdetermineDataLimits: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tvar data = chart.data;\n\t\t\t\tvar datasets = data.datasets;\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\tfunction IDMatches(meta) {\n\t\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t\t}\n\t\n\t\t\t\t// Calculate Range\n\t\t\t\tme.min = null;\n\t\t\t\tme.max = null;\n\t\t\t\tme.minNotZero = null;\n\t\n\t\t\t\tif (opts.stacked) {\n\t\t\t\t\tvar valuesPerType = {};\n\t\n\t\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\t\tif (valuesPerType[meta.type] === undefined) {\n\t\t\t\t\t\t\t\tvaluesPerType[meta.type] = [];\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\t\tvar values = valuesPerType[meta.type];\n\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\n\t\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\t\tvalues[index] = 100;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\n\t\t\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\thelpers.each(valuesPerType, function(valuesForType) {\n\t\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t});\n\t\n\t\t\t\t} else {\n\t\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\tme.min = getValueOrDefault(tickOpts.min, me.min);\n\t\t\t\tme.max = getValueOrDefault(tickOpts.max, me.max);\n\t\n\t\t\t\tif (me.min === me.max) {\n\t\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = 1;\n\t\t\t\t\t\tme.max = 10;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tbuildTicks: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\n\t\t\t\t// Reset the ticks array. Later on, we will draw a grid line at these positions\n\t\t\t\t// The array simply contains the numerical value of the spots where ticks will be\n\t\t\t\tvar ticks = me.ticks = [];\n\t\n\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t// the graph\n\t\n\t\t\t\tvar tickVal = getValueOrDefault(tickOpts.min, Math.pow(10, Math.floor(helpers.log10(me.min))));\n\t\n\t\t\t\twhile (tickVal < me.max) {\n\t\t\t\t\tticks.push(tickVal);\n\t\n\t\t\t\t\tvar exp;\n\t\t\t\t\tvar significand;\n\t\n\t\t\t\t\tif (tickVal === 0) {\n\t\t\t\t\t\texp = Math.floor(helpers.log10(me.minNotZero));\n\t\t\t\t\t\tsignificand = Math.round(me.minNotZero / Math.pow(10, exp));\n\t\t\t\t\t} else {\n\t\t\t\t\t\texp = Math.floor(helpers.log10(tickVal));\n\t\t\t\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp)) + 1;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (significand === 10) {\n\t\t\t\t\t\tsignificand = 1;\n\t\t\t\t\t\t++exp;\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t}\n\t\n\t\t\t\tvar lastTick = getValueOrDefault(tickOpts.max, tickVal);\n\t\t\t\tticks.push(lastTick);\n\t\n\t\t\t\tif (!me.isHorizontal()) {\n\t\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\t\tticks.reverse();\n\t\t\t\t}\n\t\n\t\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t\t// range of the scale\n\t\t\t\tme.max = helpers.max(ticks);\n\t\t\t\tme.min = helpers.min(ticks);\n\t\n\t\t\t\tif (tickOpts.reverse) {\n\t\t\t\t\tticks.reverse();\n\t\n\t\t\t\t\tme.start = me.max;\n\t\t\t\t\tme.end = me.min;\n\t\t\t\t} else {\n\t\t\t\t\tme.start = me.min;\n\t\t\t\t\tme.end = me.max;\n\t\t\t\t}\n\t\t\t},\n\t\t\tconvertTicksToLabels: function() {\n\t\t\t\tthis.tickValues = this.ticks.slice();\n\t\n\t\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t\t},\n\t\t\t// Get the correct tooltip label\n\t\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t\t},\n\t\t\tgetPixelForTick: function(index) {\n\t\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t\t},\n\t\t\tgetPixelForValue: function(value) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar innerDimension;\n\t\t\t\tvar pixel;\n\t\n\t\t\t\tvar start = me.start;\n\t\t\t\tvar newVal = +me.getRightValue(value);\n\t\t\t\tvar range;\n\t\t\t\tvar paddingTop = me.paddingTop;\n\t\t\t\tvar paddingBottom = me.paddingBottom;\n\t\t\t\tvar paddingLeft = me.paddingLeft;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar tickOpts = opts.ticks;\n\t\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\t\t\t\t\tif (newVal === 0) {\n\t\t\t\t\t\tpixel = me.left + paddingLeft;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinnerDimension = me.width - (paddingLeft + me.paddingRight);\n\t\t\t\t\t\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t\t\tpixel += paddingLeft;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Bottom - top since pixels increase downard on a screen\n\t\t\t\t\tinnerDimension = me.height - (paddingTop + paddingBottom);\n\t\t\t\t\tif (start === 0 && !tickOpts.reverse) {\n\t\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\t\t\t\t\t\tif (newVal === start) {\n\t\t\t\t\t\t\tpixel = me.bottom - paddingBottom;\n\t\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\t\tpixel = me.bottom - paddingBottom - innerDimension * 0.02;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpixel = me.bottom - paddingBottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (me.end === 0 && tickOpts.reverse) {\n\t\t\t\t\t\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\t\t\t\t\t\tif (newVal === me.end) {\n\t\t\t\t\t\t\tpixel = me.top + paddingTop;\n\t\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\t\tpixel = me.top + paddingTop + innerDimension * 0.02;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpixel = me.top + paddingTop + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start);\n\t\t\t\t\t\tinnerDimension = me.height - (paddingTop + paddingBottom);\n\t\t\t\t\t\tpixel = (me.bottom - paddingBottom) - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn pixel;\n\t\t\t},\n\t\t\tgetValueForPixel: function(pixel) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\n\t\t\t\tvar value, innerDimension;\n\t\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tinnerDimension = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\t\tvalue = me.start * Math.pow(10, (pixel - me.left - me.paddingLeft) * range / innerDimension);\n\t\t\t\t} else {  // todo: if start === 0\n\t\t\t\t\tinnerDimension = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\t\t\tvalue = Math.pow(10, (me.bottom - me.paddingBottom - pixel) * range / innerDimension) / me.start;\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t});\n\t\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\t\n\t};\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\n\t\tvar defaultConfig = {\n\t\t\tdisplay: true,\n\t\n\t\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\t\tanimate: true,\n\t\t\tlineArc: false,\n\t\t\tposition: 'chartArea',\n\t\n\t\t\tangleLines: {\n\t\t\t\tdisplay: true,\n\t\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\t\tlineWidth: 1\n\t\t\t},\n\t\n\t\t\t// label settings\n\t\t\tticks: {\n\t\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\t\tshowLabelBackdrop: true,\n\t\n\t\t\t\t// String - The colour of the label backdrop\n\t\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\t\n\t\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\t\tbackdropPaddingY: 2,\n\t\n\t\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\t\tbackdropPaddingX: 2\n\t\t\t},\n\t\n\t\t\tpointLabels: {\n\t\t\t\t// Number - Point label font size in pixels\n\t\t\t\tfontSize: 10,\n\t\n\t\t\t\t// Function - Used to convert point labels\n\t\t\t\tcallback: function(label) {\n\t\t\t\t\treturn label;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\t\tgetValueCount: function() {\n\t\t\t\treturn this.chart.data.labels.length;\n\t\t\t},\n\t\t\tsetDimensions: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.height = me.maxHeight;\n\t\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\t\tme.yCenter = Math.round(me.height / 2);\n\t\n\t\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t\t},\n\t\t\tdetermineDataLimits: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tme.min = null;\n\t\t\t\tme.max = null;\n\t\n\t\n\t\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\t\tme.handleTickRangeOptions();\n\t\t\t},\n\t\t\tgetTickLimit: function() {\n\t\t\t\tvar tickOpts = this.options.ticks;\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t\t},\n\t\t\tconvertTicksToLabels: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\t\n\t\t\t\t// Point labels\n\t\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t\t},\n\t\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t\t},\n\t\t\tfit: function() {\n\t\t\t\t/*\n\t\t\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t\t\t *\n\t\t\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t\t\t *\n\t\t\t\t * Solution:\n\t\t\t\t *\n\t\t\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t\t\t * at each index we check if the text overlaps.\n\t\t\t\t *\n\t\t\t\t * Where it does, we store that angle and that index.\n\t\t\t\t *\n\t\t\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t\t\t * from the shape radius to move the point inwards by that x.\n\t\t\t\t *\n\t\t\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t\t\t * along with labels.\n\t\t\t\t *\n\t\t\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t\t\t *\n\t\t\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t\t\t * and position it in the most space efficient manner\n\t\t\t\t *\n\t\t\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t\t\t */\n\t\n\t\t\t\tvar pointLabels = this.options.pointLabels;\n\t\t\t\tvar pointLabelFontSize = helpers.getValueOrDefault(pointLabels.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar pointLabeFontStyle = helpers.getValueOrDefault(pointLabels.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar pointLabeFontFamily = helpers.getValueOrDefault(pointLabels.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);\n\t\n\t\t\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\t\t\tvar largestPossibleRadius = helpers.min([(this.height / 2 - pointLabelFontSize - 5), this.width / 2]),\n\t\t\t\t\tpointPosition,\n\t\t\t\t\ti,\n\t\t\t\t\ttextWidth,\n\t\t\t\t\thalfTextWidth,\n\t\t\t\t\tfurthestRight = this.width,\n\t\t\t\t\tfurthestRightIndex,\n\t\t\t\t\tfurthestRightAngle,\n\t\t\t\t\tfurthestLeft = 0,\n\t\t\t\t\tfurthestLeftIndex,\n\t\t\t\t\tfurthestLeftAngle,\n\t\t\t\t\txProtrusionLeft,\n\t\t\t\t\txProtrusionRight,\n\t\t\t\t\tradiusReductionRight,\n\t\t\t\t\tradiusReductionLeft;\n\t\t\t\tthis.ctx.font = pointLabeFont;\n\t\n\t\t\t\tfor (i = 0; i < this.getValueCount(); i++) {\n\t\t\t\t\t// 5px to space the text slightly out - similar to what we do in the draw function.\n\t\t\t\t\tpointPosition = this.getPointPosition(i, largestPossibleRadius);\n\t\t\t\t\ttextWidth = this.ctx.measureText(this.pointLabels[i] ? this.pointLabels[i] : '').width + 5;\n\t\n\t\t\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\t\t\tvar angleRadians = this.getIndexAngle(i) + (Math.PI / 2);\n\t\t\t\t\tvar angle = (angleRadians * 360 / (2 * Math.PI)) % 360;\n\t\n\t\t\t\t\tif (angle === 0 || angle === 180) {\n\t\t\t\t\t\t// At angle 0 and 180, we're at exactly the top/bottom\n\t\t\t\t\t\t// of the radar chart, so text will be aligned centrally, so we'll half it and compare\n\t\t\t\t\t\t// w/left and right text sizes\n\t\t\t\t\t\thalfTextWidth = textWidth / 2;\n\t\t\t\t\t\tif (pointPosition.x + halfTextWidth > furthestRight) {\n\t\t\t\t\t\t\tfurthestRight = pointPosition.x + halfTextWidth;\n\t\t\t\t\t\t\tfurthestRightIndex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pointPosition.x - halfTextWidth < furthestLeft) {\n\t\t\t\t\t\t\tfurthestLeft = pointPosition.x - halfTextWidth;\n\t\t\t\t\t\t\tfurthestLeftIndex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (angle < 180) {\n\t\t\t\t\t\t// Less than half the values means we'll left align the text\n\t\t\t\t\t\tif (pointPosition.x + textWidth > furthestRight) {\n\t\t\t\t\t\t\tfurthestRight = pointPosition.x + textWidth;\n\t\t\t\t\t\t\tfurthestRightIndex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t// More than half the values means we'll right align the text\n\t\t\t\t\t} else if (pointPosition.x - textWidth < furthestLeft) {\n\t\t\t\t\t\tfurthestLeft = pointPosition.x - textWidth;\n\t\t\t\t\t\tfurthestLeftIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\txProtrusionLeft = furthestLeft;\n\t\t\t\txProtrusionRight = Math.ceil(furthestRight - this.width);\n\t\n\t\t\t\tfurthestRightAngle = this.getIndexAngle(furthestRightIndex);\n\t\t\t\tfurthestLeftAngle = this.getIndexAngle(furthestLeftIndex);\n\t\n\t\t\t\tradiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI / 2);\n\t\t\t\tradiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI / 2);\n\t\n\t\t\t\t// Ensure we actually need to reduce the size of the chart\n\t\t\t\tradiusReductionRight = (helpers.isNumber(radiusReductionRight)) ? radiusReductionRight : 0;\n\t\t\t\tradiusReductionLeft = (helpers.isNumber(radiusReductionLeft)) ? radiusReductionLeft : 0;\n\t\n\t\t\t\tthis.drawingArea = Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2);\n\t\t\t\tthis.setCenterPoint(radiusReductionLeft, radiusReductionRight);\n\t\t\t},\n\t\t\tsetCenterPoint: function(leftMovement, rightMovement) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea,\n\t\t\t\t\tmaxLeft = leftMovement + me.drawingArea;\n\t\n\t\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\t\t// Always vertically in the centre as the text height doesn't change\n\t\t\t\tme.yCenter = Math.round((me.height / 2) + me.top);\n\t\t\t},\n\t\n\t\t\tgetIndexAngle: function(index) {\n\t\t\t\tvar angleMultiplier = (Math.PI * 2) / this.getValueCount();\n\t\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t\t0;\n\t\n\t\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\t\n\t\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\t\treturn index * angleMultiplier - (Math.PI / 2) + startAngleRadians;\n\t\t\t},\n\t\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\t\tvar me = this;\n\t\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn 0; // null always in center\n\t\t\t\t}\n\t\n\t\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\t\tif (me.options.reverse) {\n\t\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t\t}\n\t\t\t\treturn (value - me.min) * scalingFactor;\n\t\t\t},\n\t\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar thisAngle = me.getIndexAngle(index);\n\t\t\t\treturn {\n\t\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetPointPositionForValue: function(index, value) {\n\t\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t\t},\n\t\n\t\t\tgetBasePosition: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar min = me.min;\n\t\t\t\tvar max = me.max;\n\t\n\t\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\t\tme.beginAtZero? 0:\n\t\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t\t0);\n\t\t\t},\n\t\n\t\t\tdraw: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar opts = me.options;\n\t\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\tvar angleLineOpts = opts.angleLines;\n\t\t\t\tvar pointLabelOpts = opts.pointLabels;\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\n\t\t\t\tif (opts.display) {\n\t\t\t\t\tvar ctx = me.ctx;\n\t\n\t\t\t\t\t// Tick Font\n\t\t\t\t\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\t\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\t\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\t\n\t\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\t\tif (index > 0 || opts.reverse) {\n\t\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\t\t\t\t\t\t\tvar yHeight = me.yCenter - yCenterOffset;\n\t\n\t\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\t\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\t\t\t\t\t\t\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\t\n\t\t\t\t\t\t\t\tif (opts.lineArc) {\n\t\t\t\t\t\t\t\t\t// Draw circular arcs between the points\n\t\t\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\t\t\tctx.arc(me.xCenter, me.yCenter, yCenterOffset, 0, Math.PI * 2);\n\t\t\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Draw straight lines connecting each index\n\t\t\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < me.getValueCount(); i++) {\n\t\t\t\t\t\t\t\t\t\tvar pointPosition = me.getPointPosition(i, yCenterOffset);\n\t\t\t\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\t\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\t\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\t\n\t\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\t\tme.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\t\tyHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\t\tctx.fillText(label, me.xCenter, yHeight);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\tif (!opts.lineArc) {\n\t\t\t\t\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\t\t\t\t\tctx.strokeStyle = angleLineOpts.color;\n\t\n\t\t\t\t\t\tvar outerDistance = me.getDistanceFromCenterForValue(opts.reverse ? me.min : me.max);\n\t\n\t\t\t\t\t\t// Point Label Font\n\t\t\t\t\t\tvar pointLabelFontSize = getValueOrDefault(pointLabelOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\t\t\tvar pointLabeFontStyle = getValueOrDefault(pointLabelOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\t\t\tvar pointLabeFontFamily = getValueOrDefault(pointLabelOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\t\t\tvar pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);\n\t\n\t\t\t\t\t\tfor (var i = me.getValueCount() - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tif (angleLineOpts.display) {\n\t\t\t\t\t\t\t\tvar outerPosition = me.getPointPosition(i, outerDistance);\n\t\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\t\tctx.moveTo(me.xCenter, me.yCenter);\n\t\t\t\t\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\t\t\t\tvar pointLabelPosition = me.getPointPosition(i, outerDistance + 5);\n\t\n\t\t\t\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\t\t\t\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = pointLabeFont;\n\t\t\t\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\t\n\t\t\t\t\t\t\tvar pointLabels = me.pointLabels;\n\t\n\t\t\t\t\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\t\t\t\t\tvar angleRadians = this.getIndexAngle(i) + (Math.PI / 2);\n\t\t\t\t\t\t\tvar angle = (angleRadians * 360 / (2 * Math.PI)) % 360;\n\t\n\t\t\t\t\t\t\tif (angle === 0 || angle === 180) {\n\t\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\t} else if (angle < 180) {\n\t\t\t\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tctx.textAlign = 'right';\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Set the correct text baseline based on outer positioning\n\t\t\t\t\t\t\tif (angle === 90 || angle === 270) {\n\t\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\t} else if (angle > 270 || angle < 90) {\n\t\t\t\t\t\t\t\tctx.textBaseline = 'bottom';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tctx.textBaseline = 'top';\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tctx.fillText(pointLabels[i] ? pointLabels[i] : '', pointLabelPosition.x, pointLabelPosition.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\t\n\t};\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global window: false */\n\t'use strict';\n\t\n\tvar moment = __webpack_require__(32);\n\tmoment = typeof(moment) === 'function' ? moment : window.moment;\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\tvar time = {\n\t\t\tunits: [{\n\t\t\t\tname: 'millisecond',\n\t\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t\t\t}, {\n\t\t\t\tname: 'second',\n\t\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t\t}, {\n\t\t\t\tname: 'minute',\n\t\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t\t}, {\n\t\t\t\tname: 'hour',\n\t\t\t\tsteps: [1, 2, 3, 6, 12]\n\t\t\t}, {\n\t\t\t\tname: 'day',\n\t\t\t\tsteps: [1, 2, 5]\n\t\t\t}, {\n\t\t\t\tname: 'week',\n\t\t\t\tmaxStep: 4\n\t\t\t}, {\n\t\t\t\tname: 'month',\n\t\t\t\tmaxStep: 3\n\t\t\t}, {\n\t\t\t\tname: 'quarter',\n\t\t\t\tmaxStep: 4\n\t\t\t}, {\n\t\t\t\tname: 'year',\n\t\t\t\tmaxStep: false\n\t\t\t}]\n\t\t};\n\t\n\t\tvar defaultConfig = {\n\t\t\tposition: 'bottom',\n\t\n\t\t\ttime: {\n\t\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\t\tminUnit: 'millisecond',\n\t\n\t\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\t\tdisplayFormats: {\n\t\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\t\tminute: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\t\thour: 'MMM D, hA', // Sept 4, 5PM\n\t\t\t\t\tday: 'll', // Sep 4 2015\n\t\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t\t}\n\t\t\t},\n\t\t\tticks: {\n\t\t\t\tautoSkip: false\n\t\t\t}\n\t\t};\n\t\n\t\tvar TimeScale = Chart.Scale.extend({\n\t\t\tinitialize: function() {\n\t\t\t\tif (!moment) {\n\t\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t\t}\n\t\n\t\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t\t},\n\t\t\tgetLabelMoment: function(datasetIndex, index) {\n\t\t\t\tif (datasetIndex === null || index === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof this.labelMoments[datasetIndex] !== 'undefined') {\n\t\t\t\t\treturn this.labelMoments[datasetIndex][index];\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tgetLabelDiff: function(datasetIndex, index) {\n\t\t\t\tvar me = this;\n\t\t\t\tif (datasetIndex === null || index === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\n\t\t\t\tif (me.labelDiffs === undefined) {\n\t\t\t\t\tme.buildLabelDiffs();\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof me.labelDiffs[datasetIndex] !== 'undefined') {\n\t\t\t\t\treturn me.labelDiffs[datasetIndex][index];\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tgetMomentStartOf: function(tick) {\n\t\t\t\tvar me = this;\n\t\t\t\tif (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {\n\t\t\t\t\treturn tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);\n\t\t\t\t}\n\t\t\t\treturn tick.clone().startOf(me.tickUnit);\n\t\t\t},\n\t\t\tdetermineDataLimits: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tme.labelMoments = [];\n\t\n\t\t\t\t// Only parse these once. If the dataset does not have data as x,y pairs, we will use\n\t\t\t\t// these\n\t\t\t\tvar scaleLabelMoments = [];\n\t\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\n\t\t\t\t\thelpers.each(me.chart.data.labels, function(label) {\n\t\t\t\t\t\tvar labelMoment = me.parseTime(label);\n\t\n\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tscaleLabelMoments.push(labelMoment);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, me);\n\t\n\t\t\t\t\tme.firstTick = moment.min.call(me, scaleLabelMoments);\n\t\t\t\t\tme.lastTick = moment.max.call(me, scaleLabelMoments);\n\t\t\t\t} else {\n\t\t\t\t\tme.firstTick = null;\n\t\t\t\t\tme.lastTick = null;\n\t\t\t\t}\n\t\n\t\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar momentsForDataset = [];\n\t\t\t\t\tvar datasetVisible = me.chart.isDatasetVisible(datasetIndex);\n\t\n\t\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(value) {\n\t\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));\n\t\n\t\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmomentsForDataset.push(labelMoment);\n\t\n\t\t\t\t\t\t\t\tif (datasetVisible) {\n\t\t\t\t\t\t\t\t\t// May have gone outside the scale ranges, make sure we keep the first and last ticks updated\n\t\t\t\t\t\t\t\t\tme.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;\n\t\t\t\t\t\t\t\t\tme.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, me);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We have no labels. Use the ones from the scale\n\t\t\t\t\t\tmomentsForDataset = scaleLabelMoments;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tme.labelMoments.push(momentsForDataset);\n\t\t\t\t}, me);\n\t\n\t\t\t\t// Set these after we've done all the data\n\t\t\t\tif (me.options.time.min) {\n\t\t\t\t\tme.firstTick = me.parseTime(me.options.time.min);\n\t\t\t\t}\n\t\n\t\t\t\tif (me.options.time.max) {\n\t\t\t\t\tme.lastTick = me.parseTime(me.options.time.max);\n\t\t\t\t}\n\t\n\t\t\t\t// We will modify these, so clone for later\n\t\t\t\tme.firstTick = (me.firstTick || moment()).clone();\n\t\t\t\tme.lastTick = (me.lastTick || moment()).clone();\n\t\t\t},\n\t\t\tbuildLabelDiffs: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tme.labelDiffs = [];\n\t\t\t\tvar scaleLabelDiffs = [];\n\t\t\t\t// Parse common labels once\n\t\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\n\t\t\t\t\thelpers.each(me.chart.data.labels, function(label) {\n\t\t\t\t\t\tvar labelMoment = me.parseTime(label);\n\t\n\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tscaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n\t\t\t\t\t\t}\n\t\t\t\t\t}, me);\n\t\t\t\t}\n\t\n\t\t\t\thelpers.each(me.chart.data.datasets, function(dataset) {\n\t\t\t\t\tvar diffsForDataset = [];\n\t\n\t\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(value) {\n\t\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));\n\t\n\t\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdiffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, me);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We have no labels. Use common ones\n\t\t\t\t\t\tdiffsForDataset = scaleLabelDiffs;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tme.labelDiffs.push(diffsForDataset);\n\t\t\t\t}, me);\n\t\t\t},\n\t\t\tbuildTicks: function() {\n\t\t\t\tvar me = this;\n\t\n\t\t\t\tme.ctx.save();\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\t\tvar tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\t\t\t\tme.ctx.font = tickLabelFont;\n\t\n\t\t\t\tme.ticks = [];\n\t\t\t\tme.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step\n\t\t\t\tme.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)\n\t\n\t\t\t\t// Set unit override if applicable\n\t\t\t\tif (me.options.time.unit) {\n\t\t\t\t\tme.tickUnit = me.options.time.unit || 'day';\n\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\n\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);\n\t\t\t\t} else {\n\t\t\t\t\t// Determine the smallest needed unit of the time\n\t\t\t\t\tvar innerWidth = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);\n\t\n\t\t\t\t\t// Crude approximation of what the label length might be\n\t\t\t\t\tvar tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);\n\t\t\t\t\tvar tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;\n\t\t\t\t\tvar cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));\n\t\t\t\t\tvar sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));\n\t\t\t\t\ttickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t\t\t\tvar labelCapacity = innerWidth / (tickLabelWidth);\n\t\n\t\t\t\t\t// Start as small as possible\n\t\t\t\t\tme.tickUnit = me.options.time.minUnit;\n\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\n\t\n\t\t\t\t\tvar unitDefinitionIndex = 0;\n\t\t\t\t\tvar unitDefinition = time.units[unitDefinitionIndex];\n\t\n\t\t\t\t\t// While we aren't ideal and we don't have units left\n\t\t\t\t\twhile (unitDefinitionIndex < time.units.length) {\n\t\t\t\t\t\t// Can we scale this unit. If `false` we can scale infinitely\n\t\t\t\t\t\tme.unitScale = 1;\n\t\n\t\t\t\t\t\tif (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {\n\t\t\t\t\t\t\t// Use one of the prefedined steps\n\t\t\t\t\t\t\tfor (var idx = 0; idx < unitDefinition.steps.length; ++idx) {\n\t\t\t\t\t\t\t\tif (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {\n\t\t\t\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {\n\t\t\t\t\t\t\t// We have a max step. Scale this unit\n\t\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Move to the next unit up\n\t\t\t\t\t\t\t++unitDefinitionIndex;\n\t\t\t\t\t\t\tunitDefinition = time.units[unitDefinitionIndex];\n\t\n\t\t\t\t\t\t\tme.tickUnit = unitDefinition.name;\n\t\t\t\t\t\t\tvar leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);\n\t\t\t\t\t\t\tvar trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);\n\t\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;\n\t\t\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[unitDefinition.name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar roundedStart;\n\t\n\t\t\t\t// Only round the first tick if we have no hard minimum\n\t\t\t\tif (!me.options.time.min) {\n\t\t\t\t\tme.firstTick = me.getMomentStartOf(me.firstTick);\n\t\t\t\t\troundedStart = me.firstTick;\n\t\t\t\t} else {\n\t\t\t\t\troundedStart = me.getMomentStartOf(me.firstTick);\n\t\t\t\t}\n\t\n\t\t\t\t// Only round the last tick if we have no hard maximum\n\t\t\t\tif (!me.options.time.max) {\n\t\t\t\t\tvar roundedEnd = me.getMomentStartOf(me.lastTick);\n\t\t\t\t\tvar delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);\n\t\t\t\t\tif (delta < 0) {\n\t\t\t\t\t\t// Do not use end of because we need me to be in the next time unit\n\t\t\t\t\t\tme.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));\n\t\t\t\t\t} else if (delta >= 0) {\n\t\t\t\t\t\tme.lastTick = roundedEnd;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t}\n\t\n\t\t\t\t// Tick displayFormat override\n\t\t\t\tif (me.options.time.displayFormat) {\n\t\t\t\t\tme.displayFormat = me.options.time.displayFormat;\n\t\t\t\t}\n\t\n\t\t\t\t// first tick. will have been rounded correctly if options.time.min is not specified\n\t\t\t\tme.ticks.push(me.firstTick.clone());\n\t\n\t\t\t\t// For every unit in between the first and last moment, create a moment and add it to the ticks tick\n\t\t\t\tfor (var i = 1; i <= me.scaleSizeInUnits; ++i) {\n\t\t\t\t\tvar newTick = roundedStart.clone().add(i, me.tickUnit);\n\t\n\t\t\t\t\t// Are we greater than the max time\n\t\t\t\t\tif (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (i % me.unitScale === 0) {\n\t\t\t\t\t\tme.ticks.push(newTick);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Always show the right tick\n\t\t\t\tvar diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);\n\t\t\t\tif (diff !== 0 || me.scaleSizeInUnits === 0) {\n\t\t\t\t\t// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart\n\t\t\t\t\t// but the last tick was not rounded.\n\t\t\t\t\tif (me.options.time.max) {\n\t\t\t\t\t\tme.ticks.push(me.lastTick.clone());\n\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.ticks.push(me.lastTick.clone());\n\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tme.ctx.restore();\n\t\n\t\t\t\t// Invalidate label diffs cache\n\t\t\t\tme.labelDiffs = undefined;\n\t\t\t},\n\t\t\t// Get tooltip label\n\t\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\n\t\n\t\t\t\tif (typeof me.chart.data.datasets[datasetIndex].data[0] === 'object') {\n\t\t\t\t\tlabel = me.getRightValue(me.chart.data.datasets[datasetIndex].data[index]);\n\t\t\t\t}\n\t\n\t\t\t\t// Format nicely\n\t\t\t\tif (me.options.time.tooltipFormat) {\n\t\t\t\t\tlabel = me.parseTime(label).format(me.options.time.tooltipFormat);\n\t\t\t\t}\n\t\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\t// Function to format an individual tick mark\n\t\t\ttickFormatFunction: function(tick, index, ticks) {\n\t\t\t\tvar formattedTick = tick.format(this.displayFormat);\n\t\t\t\tvar tickOpts = this.options.ticks;\n\t\t\t\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\t\n\t\t\t\tif (callback) {\n\t\t\t\t\treturn callback(formattedTick, index, ticks);\n\t\t\t\t}\n\t\t\t\treturn formattedTick;\n\t\t\t},\n\t\t\tconvertTicksToLabels: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tme.tickMoments = me.ticks;\n\t\t\t\tme.ticks = me.ticks.map(me.tickFormatFunction, me);\n\t\t\t},\n\t\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar offset = null;\n\t\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\t\toffset = me.getLabelDiff(datasetIndex, index);\n\t\t\t\t}\n\t\n\t\t\t\tif (offset === null) {\n\t\t\t\t\tif (!value || !value.isValid) {\n\t\t\t\t\t\t// not already a moment object\n\t\t\t\t\t\tvalue = me.parseTime(me.getRightValue(value));\n\t\t\t\t\t}\n\t\t\t\t\tif (value && value.isValid && value.isValid()) {\n\t\t\t\t\t\toffset = value.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (offset !== null) {\n\t\t\t\t\tvar decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\n\t\n\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\t\n\t\t\t\t\t\treturn me.left + Math.round(valueOffset);\n\t\t\t\t\t}\n\t\t\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\t\t\tvar heightOffset = (innerHeight * decimal) + me.paddingTop;\n\t\n\t\t\t\t\treturn me.top + Math.round(heightOffset);\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetPixelForTick: function(index) {\n\t\t\t\treturn this.getPixelForValue(this.tickMoments[index], null, null);\n\t\t\t},\n\t\t\tgetValueForPixel: function(pixel) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar innerDimension = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);\n\t\t\t\tvar offset = (pixel - (me.isHorizontal() ? me.left + me.paddingLeft : me.top + me.paddingTop)) / innerDimension;\n\t\t\t\toffset *= me.scaleSizeInUnits;\n\t\t\t\treturn me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');\n\t\t\t},\n\t\t\tparseTime: function(label) {\n\t\t\t\tvar me = this;\n\t\t\t\tif (typeof me.options.time.parser === 'string') {\n\t\t\t\t\treturn moment(label, me.options.time.parser);\n\t\t\t\t}\n\t\t\t\tif (typeof me.options.time.parser === 'function') {\n\t\t\t\t\treturn me.options.time.parser(label);\n\t\t\t\t}\n\t\t\t\t// Date objects\n\t\t\t\tif (typeof label.getMonth === 'function' || typeof label === 'number') {\n\t\t\t\t\treturn moment(label);\n\t\t\t\t}\n\t\t\t\t// Moment support\n\t\t\t\tif (label.isValid && label.isValid()) {\n\t\t\t\t\treturn label;\n\t\t\t\t}\n\t\t\t\t// Custom parsing (return an instance of moment)\n\t\t\t\tif (typeof me.options.time.format !== 'string' && me.options.time.format.call) {\n\t\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');\n\t\t\t\t\treturn me.options.time.format(label);\n\t\t\t\t}\n\t\t\t\t// Moment format parsing\n\t\t\t\treturn moment(label, me.options.time.format);\n\t\t\t}\n\t\t});\n\t\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n\t\n\t};\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_32__;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.bar = {\n\t\t\thover: {\n\t\t\t\tmode: 'label'\n\t\t\t},\n\t\n\t\t\tscales: {\n\t\t\t\txAxes: [{\n\t\t\t\t\ttype: 'category',\n\t\n\t\t\t\t\t// Specific to Bar Controller\n\t\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\t\tbarPercentage: 0.9,\n\t\n\t\t\t\t\t// grid line settings\n\t\t\t\t\tgridLines: {\n\t\t\t\t\t\toffsetGridLines: true\n\t\t\t\t\t}\n\t\t\t\t}],\n\t\t\t\tyAxes: [{\n\t\t\t\t\ttype: 'linear'\n\t\t\t\t}]\n\t\t\t}\n\t\t};\n\t\n\t\tChart.controllers.bar = Chart.DatasetController.extend({\n\t\n\t\t\tdataElementType: Chart.elements.Rectangle,\n\t\n\t\t\tinitialize: function(chart, datasetIndex) {\n\t\t\t\tChart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);\n\t\n\t\t\t\t// Use this to indicate that this is a bar dataset.\n\t\t\t\tthis.getMeta().bar = true;\n\t\t\t},\n\t\n\t\t\t// Get the number of datasets that display bars. We use this to correctly calculate the bar width\n\t\t\tgetBarCount: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar barCount = 0;\n\t\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (meta.bar && me.chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\t++barCount;\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\t\t\t\treturn barCount;\n\t\t\t},\n\t\n\t\t\tupdate: function(reset) {\n\t\t\t\tvar me = this;\n\t\t\t\thelpers.each(me.getMeta().data, function(rectangle, index) {\n\t\t\t\t\tme.updateElement(rectangle, index, reset);\n\t\t\t\t}, me);\n\t\t\t},\n\t\n\t\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar scaleBase = yScale.getBasePixel();\n\t\t\t\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\n\t\t\t\tvar custom = rectangle.custom || {};\n\t\t\t\tvar dataset = me.getDataset();\n\t\n\t\t\t\thelpers.extend(rectangle, {\n\t\t\t\t\t// Utility\n\t\t\t\t\t_xScale: xScale,\n\t\t\t\t\t_yScale: yScale,\n\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t_index: index,\n\t\n\t\t\t\t\t// Desired view properties\n\t\t\t\t\t_model: {\n\t\t\t\t\t\tx: me.calculateBarX(index, me.index),\n\t\t\t\t\t\ty: reset ? scaleBase : me.calculateBarY(index, me.index),\n\t\n\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\tlabel: me.chart.data.labels[index],\n\t\t\t\t\t\tdatasetLabel: dataset.label,\n\t\n\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\n\t\t\t\t\t\twidth: me.calculateBarWidth(index),\n\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\n\t\t\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\trectangle.pivot();\n\t\t\t},\n\t\n\t\t\tcalculateBarBase: function(datasetIndex, index) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar base = 0;\n\t\n\t\t\t\tif (yScale.options.stacked) {\n\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\tvar datasets = chart.data.datasets;\n\t\t\t\t\tvar value = Number(datasets[datasetIndex].data[index]);\n\t\n\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\tvar currentDs = datasets[i];\n\t\t\t\t\t\tvar currentDsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\tif (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\t\tvar currentVal = Number(currentDs.data[index]);\n\t\t\t\t\t\t\tbase += value < 0 ? Math.min(currentVal, 0) : Math.max(currentVal, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn yScale.getPixelForValue(base);\n\t\t\t\t}\n\t\n\t\t\t\treturn yScale.getBasePixel();\n\t\t\t},\n\t\n\t\t\tgetRuler: function(index) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\tvar datasetCount = me.getBarCount();\n\t\n\t\t\t\tvar tickWidth;\n\t\n\t\t\t\tif (xScale.options.type === 'category') {\n\t\t\t\t\ttickWidth = xScale.getPixelForTick(index + 1) - xScale.getPixelForTick(index);\n\t\t\t\t} else {\n\t\t\t\t\t// Average width\n\t\t\t\t\ttickWidth = xScale.width / xScale.ticks.length;\n\t\t\t\t}\n\t\t\t\tvar categoryWidth = tickWidth * xScale.options.categoryPercentage;\n\t\t\t\tvar categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;\n\t\t\t\tvar fullBarWidth = categoryWidth / datasetCount;\n\t\n\t\t\t\tif (xScale.ticks.length !== me.chart.data.labels.length) {\n\t\t\t\t\tvar perc = xScale.ticks.length / me.chart.data.labels.length;\n\t\t\t\t\tfullBarWidth = fullBarWidth * perc;\n\t\t\t\t}\n\t\n\t\t\t\tvar barWidth = fullBarWidth * xScale.options.barPercentage;\n\t\t\t\tvar barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);\n\t\n\t\t\t\treturn {\n\t\t\t\t\tdatasetCount: datasetCount,\n\t\t\t\t\ttickWidth: tickWidth,\n\t\t\t\t\tcategoryWidth: categoryWidth,\n\t\t\t\t\tcategorySpacing: categorySpacing,\n\t\t\t\t\tfullBarWidth: fullBarWidth,\n\t\t\t\t\tbarWidth: barWidth,\n\t\t\t\t\tbarSpacing: barSpacing\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\tcalculateBarWidth: function(index) {\n\t\t\t\tvar xScale = this.getScaleForId(this.getMeta().xAxisID);\n\t\t\t\tif (xScale.options.barThickness) {\n\t\t\t\t\treturn xScale.options.barThickness;\n\t\t\t\t}\n\t\t\t\tvar ruler = this.getRuler(index);\n\t\t\t\treturn xScale.options.stacked ? ruler.categoryWidth : ruler.barWidth;\n\t\t\t},\n\t\n\t\t\t// Get bar index from the given dataset index accounting for the fact that not all bars are visible\n\t\t\tgetBarIndex: function(datasetIndex) {\n\t\t\t\tvar barIndex = 0;\n\t\t\t\tvar meta, j;\n\t\n\t\t\t\tfor (j = 0; j < datasetIndex; ++j) {\n\t\t\t\t\tmeta = this.chart.getDatasetMeta(j);\n\t\t\t\t\tif (meta.bar && this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t\t++barIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn barIndex;\n\t\t\t},\n\t\n\t\t\tcalculateBarX: function(index, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\tvar barIndex = me.getBarIndex(datasetIndex);\n\t\n\t\t\t\tvar ruler = me.getRuler(index);\n\t\t\t\tvar leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\n\t\t\t\tleftTick -= me.chart.isCombo ? (ruler.tickWidth / 2) : 0;\n\t\n\t\t\t\tif (xScale.options.stacked) {\n\t\t\t\t\treturn leftTick + (ruler.categoryWidth / 2) + ruler.categorySpacing;\n\t\t\t\t}\n\t\n\t\t\t\treturn leftTick +\n\t\t\t\t\t(ruler.barWidth / 2) +\n\t\t\t\t\truler.categorySpacing +\n\t\t\t\t\t(ruler.barWidth * barIndex) +\n\t\t\t\t\t(ruler.barSpacing / 2) +\n\t\t\t\t\t(ruler.barSpacing * barIndex);\n\t\t\t},\n\t\n\t\t\tcalculateBarY: function(index, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar value = Number(me.getDataset().data[index]);\n\t\n\t\t\t\tif (yScale.options.stacked) {\n\t\n\t\t\t\t\tvar sumPos = 0,\n\t\t\t\t\t\tsumNeg = 0;\n\t\n\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\tvar ds = me.chart.data.datasets[i];\n\t\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(i);\n\t\t\t\t\t\tif (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i)) {\n\t\t\t\t\t\t\tvar stackedVal = Number(ds.data[index]);\n\t\t\t\t\t\t\tif (stackedVal < 0) {\n\t\t\t\t\t\t\t\tsumNeg += stackedVal || 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsumPos += stackedVal || 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (value < 0) {\n\t\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + value);\n\t\t\t\t\t}\n\t\t\t\t\treturn yScale.getPixelForValue(sumPos + value);\n\t\t\t\t}\n\t\n\t\t\t\treturn yScale.getPixelForValue(value);\n\t\t\t},\n\t\n\t\t\tdraw: function(ease) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar easingDecimal = ease || 1;\n\t\t\t\thelpers.each(me.getMeta().data, function(rectangle, index) {\n\t\t\t\t\tvar d = me.getDataset().data[index];\n\t\t\t\t\tif (d !== null && d !== undefined && !isNaN(d)) {\n\t\t\t\t\t\trectangle.transition(easingDecimal).draw();\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\t\t\t},\n\t\n\t\t\tsetHoverStyle: function(rectangle) {\n\t\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\t\tvar index = rectangle._index;\n\t\n\t\t\t\tvar custom = rectangle.custom || {};\n\t\t\t\tvar model = rectangle._model;\n\t\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t\t},\n\t\n\t\t\tremoveHoverStyle: function(rectangle) {\n\t\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\t\tvar index = rectangle._index;\n\t\t\t\tvar custom = rectangle.custom || {};\n\t\t\t\tvar model = rectangle._model;\n\t\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\t\n\t\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t\t}\n\t\n\t\t});\n\t\n\t\n\t\t// including horizontalBar in the bar file, instead of a file of its own\n\t\t// it extends bar (like pie extends doughnut)\n\t\tChart.defaults.horizontalBar = {\n\t\t\thover: {\n\t\t\t\tmode: 'label'\n\t\t\t},\n\t\n\t\t\tscales: {\n\t\t\t\txAxes: [{\n\t\t\t\t\ttype: 'linear',\n\t\t\t\t\tposition: 'bottom'\n\t\t\t\t}],\n\t\t\t\tyAxes: [{\n\t\t\t\t\tposition: 'left',\n\t\t\t\t\ttype: 'category',\n\t\n\t\t\t\t\t// Specific to Horizontal Bar Controller\n\t\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\t\tbarPercentage: 0.9,\n\t\n\t\t\t\t\t// grid line settings\n\t\t\t\t\tgridLines: {\n\t\t\t\t\t\toffsetGridLines: true\n\t\t\t\t\t}\n\t\t\t\t}]\n\t\t\t},\n\t\t\telements: {\n\t\t\t\trectangle: {\n\t\t\t\t\tborderSkipped: 'left'\n\t\t\t\t}\n\t\t\t},\n\t\t\ttooltips: {\n\t\t\t\tcallbacks: {\n\t\t\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t\t\t// Pick first xLabel for now\n\t\t\t\t\t\tvar title = '';\n\t\n\t\t\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\t\t\tif (tooltipItems[0].yLabel) {\n\t\t\t\t\t\t\t\ttitle = tooltipItems[0].yLabel;\n\t\t\t\t\t\t\t} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\n\t\t\t\t\t\t\t\ttitle = data.labels[tooltipItems[0].index];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn title;\n\t\t\t\t\t},\n\t\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\t\treturn datasetLabel + ': ' + tooltipItem.xLabel;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar scaleBase = xScale.getBasePixel();\n\t\t\t\tvar custom = rectangle.custom || {};\n\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\n\t\n\t\t\t\thelpers.extend(rectangle, {\n\t\t\t\t\t// Utility\n\t\t\t\t\t_xScale: xScale,\n\t\t\t\t\t_yScale: yScale,\n\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t_index: index,\n\t\n\t\t\t\t\t// Desired view properties\n\t\t\t\t\t_model: {\n\t\t\t\t\t\tx: reset ? scaleBase : me.calculateBarX(index, me.index),\n\t\t\t\t\t\ty: me.calculateBarY(index, me.index),\n\t\n\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\tlabel: me.chart.data.labels[index],\n\t\t\t\t\t\tdatasetLabel: dataset.label,\n\t\n\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\n\t\t\t\t\t\theight: me.calculateBarHeight(index),\n\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\n\t\t\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\n\t\t\t\t\t},\n\t\n\t\t\t\t\tdraw: function() {\n\t\t\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\t\t\tvar vm = this._view;\n\t\n\t\t\t\t\t\tvar halfHeight = vm.height / 2,\n\t\t\t\t\t\t\ttopY = vm.y - halfHeight,\n\t\t\t\t\t\t\tbottomY = vm.y + halfHeight,\n\t\t\t\t\t\t\tright = vm.base - (vm.base - vm.x),\n\t\t\t\t\t\t\thalfStroke = vm.borderWidth / 2;\n\t\n\t\t\t\t\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t\t\t\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\t\t\t\t\tif (vm.borderWidth) {\n\t\t\t\t\t\t\ttopY += halfStroke;\n\t\t\t\t\t\t\tbottomY -= halfStroke;\n\t\t\t\t\t\t\tright += halfStroke;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tctx.beginPath();\n\t\n\t\t\t\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\t\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\t\t\t\tctx.lineWidth = vm.borderWidth;\n\t\n\t\t\t\t\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t\t\t\t\t// | 1 2 |\n\t\t\t\t\t\t// | 0 3 |\n\t\t\t\t\t\tvar corners = [\n\t\t\t\t\t\t\t[vm.base, bottomY],\n\t\t\t\t\t\t\t[vm.base, topY],\n\t\t\t\t\t\t\t[right, topY],\n\t\t\t\t\t\t\t[right, bottomY]\n\t\t\t\t\t\t];\n\t\n\t\t\t\t\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\t\t\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\t\t\t\t\tvar startCorner = borders.indexOf(vm.borderSkipped, 0);\n\t\t\t\t\t\tif (startCorner === -1) {\n\t\t\t\t\t\t\tstartCorner = 0;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfunction cornerAt(cornerIndex) {\n\t\t\t\t\t\t\treturn corners[(startCorner + cornerIndex) % 4];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Draw rectangle from 'startCorner'\n\t\t\t\t\t\tctx.moveTo.apply(ctx, cornerAt(0));\n\t\t\t\t\t\tfor (var i = 1; i < 4; i++) {\n\t\t\t\t\t\t\tctx.lineTo.apply(ctx, cornerAt(i));\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\tif (vm.borderWidth) {\n\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\n\t\t\t\t\tinRange: function(mouseX, mouseY) {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\tvar inRange = false;\n\t\n\t\t\t\t\t\tif (vm) {\n\t\t\t\t\t\t\tif (vm.x < vm.base) {\n\t\t\t\t\t\t\t\tinRange = (mouseY >= vm.y - vm.height / 2 && mouseY <= vm.y + vm.height / 2) && (mouseX >= vm.x && mouseX <= vm.base);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinRange = (mouseY >= vm.y - vm.height / 2 && mouseY <= vm.y + vm.height / 2) && (mouseX >= vm.base && mouseX <= vm.x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn inRange;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\trectangle.pivot();\n\t\t\t},\n\t\n\t\t\tcalculateBarBase: function(datasetIndex, index) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\tvar base = 0;\n\t\n\t\t\t\tif (xScale.options.stacked) {\n\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\tvar datasets = chart.data.datasets;\n\t\t\t\t\tvar value = Number(datasets[datasetIndex].data[index]);\n\t\n\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\tvar currentDs = datasets[i];\n\t\t\t\t\t\tvar currentDsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\tif (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\t\tvar currentVal = Number(currentDs.data[index]);\n\t\t\t\t\t\t\tbase += value < 0 ? Math.min(currentVal, 0) : Math.max(currentVal, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn xScale.getPixelForValue(base);\n\t\t\t\t}\n\t\n\t\t\t\treturn xScale.getBasePixel();\n\t\t\t},\n\t\n\t\t\tgetRuler: function(index) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar datasetCount = me.getBarCount();\n\t\n\t\t\t\tvar tickHeight;\n\t\t\t\tif (yScale.options.type === 'category') {\n\t\t\t\t\ttickHeight = yScale.getPixelForTick(index + 1) - yScale.getPixelForTick(index);\n\t\t\t\t} else {\n\t\t\t\t\t// Average width\n\t\t\t\t\ttickHeight = yScale.width / yScale.ticks.length;\n\t\t\t\t}\n\t\t\t\tvar categoryHeight = tickHeight * yScale.options.categoryPercentage;\n\t\t\t\tvar categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;\n\t\t\t\tvar fullBarHeight = categoryHeight / datasetCount;\n\t\n\t\t\t\tif (yScale.ticks.length !== me.chart.data.labels.length) {\n\t\t\t\t\tvar perc = yScale.ticks.length / me.chart.data.labels.length;\n\t\t\t\t\tfullBarHeight = fullBarHeight * perc;\n\t\t\t\t}\n\t\n\t\t\t\tvar barHeight = fullBarHeight * yScale.options.barPercentage;\n\t\t\t\tvar barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);\n\t\n\t\t\t\treturn {\n\t\t\t\t\tdatasetCount: datasetCount,\n\t\t\t\t\ttickHeight: tickHeight,\n\t\t\t\t\tcategoryHeight: categoryHeight,\n\t\t\t\t\tcategorySpacing: categorySpacing,\n\t\t\t\t\tfullBarHeight: fullBarHeight,\n\t\t\t\t\tbarHeight: barHeight,\n\t\t\t\t\tbarSpacing: barSpacing\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\tcalculateBarHeight: function(index) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar yScale = me.getScaleForId(me.getMeta().yAxisID);\n\t\t\t\tif (yScale.options.barThickness) {\n\t\t\t\t\treturn yScale.options.barThickness;\n\t\t\t\t}\n\t\t\t\tvar ruler = me.getRuler(index);\n\t\t\t\treturn yScale.options.stacked ? ruler.categoryHeight : ruler.barHeight;\n\t\t\t},\n\t\n\t\t\tcalculateBarX: function(index, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\tvar value = Number(me.getDataset().data[index]);\n\t\n\t\t\t\tif (xScale.options.stacked) {\n\t\n\t\t\t\t\tvar sumPos = 0,\n\t\t\t\t\t\tsumNeg = 0;\n\t\n\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\tvar ds = me.chart.data.datasets[i];\n\t\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(i);\n\t\t\t\t\t\tif (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i)) {\n\t\t\t\t\t\t\tvar stackedVal = Number(ds.data[index]);\n\t\t\t\t\t\t\tif (stackedVal < 0) {\n\t\t\t\t\t\t\t\tsumNeg += stackedVal || 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsumPos += stackedVal || 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (value < 0) {\n\t\t\t\t\t\treturn xScale.getPixelForValue(sumNeg + value);\n\t\t\t\t\t}\n\t\t\t\t\treturn xScale.getPixelForValue(sumPos + value);\n\t\t\t\t}\n\t\n\t\t\t\treturn xScale.getPixelForValue(value);\n\t\t\t},\n\t\n\t\t\tcalculateBarY: function(index, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar barIndex = me.getBarIndex(datasetIndex);\n\t\n\t\t\t\tvar ruler = me.getRuler(index);\n\t\t\t\tvar topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\n\t\t\t\ttopTick -= me.chart.isCombo ? (ruler.tickHeight / 2) : 0;\n\t\n\t\t\t\tif (yScale.options.stacked) {\n\t\t\t\t\treturn topTick + (ruler.categoryHeight / 2) + ruler.categorySpacing;\n\t\t\t\t}\n\t\n\t\t\t\treturn topTick +\n\t\t\t\t\t(ruler.barHeight / 2) +\n\t\t\t\t\truler.categorySpacing +\n\t\t\t\t\t(ruler.barHeight * barIndex) +\n\t\t\t\t\t(ruler.barSpacing / 2) +\n\t\t\t\t\t(ruler.barSpacing * barIndex);\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.bubble = {\n\t\t\thover: {\n\t\t\t\tmode: 'single'\n\t\t\t},\n\t\n\t\t\tscales: {\n\t\t\t\txAxes: [{\n\t\t\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\t\t\tposition: 'bottom',\n\t\t\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t\t\t}],\n\t\t\t\tyAxes: [{\n\t\t\t\t\ttype: 'linear',\n\t\t\t\t\tposition: 'left',\n\t\t\t\t\tid: 'y-axis-0'\n\t\t\t\t}]\n\t\t\t},\n\t\n\t\t\ttooltips: {\n\t\t\t\tcallbacks: {\n\t\t\t\t\ttitle: function() {\n\t\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t},\n\t\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\t\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\t\t\t\t\t\treturn datasetLabel + ': (' + dataPoint.x + ', ' + dataPoint.y + ', ' + dataPoint.r + ')';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tChart.controllers.bubble = Chart.DatasetController.extend({\n\t\n\t\t\tdataElementType: Chart.elements.Point,\n\t\n\t\t\tupdate: function(reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar points = meta.data;\n\t\n\t\t\t\t// Update Points\n\t\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tupdateElement: function(point, index, reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\tvar data = dataset.data[index];\n\t\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\t\tvar dsIndex = me.index;\n\t\n\t\t\t\thelpers.extend(point, {\n\t\t\t\t\t// Utility\n\t\t\t\t\t_xScale: xScale,\n\t\t\t\t\t_yScale: yScale,\n\t\t\t\t\t_datasetIndex: dsIndex,\n\t\t\t\t\t_index: index,\n\t\n\t\t\t\t\t// Desired view properties\n\t\t\t\t\t_model: {\n\t\t\t\t\t\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\n\t\t\t\t\t\ty: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\n\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\tradius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\n\t\n\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t// Trick to reset the styles of the point\n\t\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\n\t\n\t\t\t\tvar model = point._model;\n\t\t\t\tmodel.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));\n\t\n\t\t\t\tpoint.pivot();\n\t\t\t},\n\t\n\t\t\tgetRadius: function(value) {\n\t\t\t\treturn value.r || this.chart.options.elements.point.radius;\n\t\t\t},\n\t\n\t\t\tsetHoverStyle: function(point) {\n\t\t\t\tvar me = this;\n\t\t\t\tChart.DatasetController.prototype.setHoverStyle.call(me, point);\n\t\n\t\t\t\t// Radius\n\t\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\t\tvar index = point._index;\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar model = point._model;\n\t\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);\n\t\t\t},\n\t\n\t\t\tremoveHoverStyle: function(point) {\n\t\t\t\tvar me = this;\n\t\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\n\t\n\t\t\t\tvar dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar model = point._model;\n\t\n\t\t\t\tmodel.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers,\n\t\t\tdefaults = Chart.defaults;\n\t\n\t\tdefaults.doughnut = {\n\t\t\tanimation: {\n\t\t\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\t\t\tanimateRotate: true,\n\t\t\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\t\t\tanimateScale: false\n\t\t\t},\n\t\t\taspectRatio: 1,\n\t\t\thover: {\n\t\t\t\tmode: 'single'\n\t\t\t},\n\t\t\tlegendCallback: function(chart) {\n\t\t\t\tvar text = [];\n\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\n\t\t\t\tvar data = chart.data;\n\t\t\t\tvar datasets = data.datasets;\n\t\t\t\tvar labels = data.labels;\n\t\n\t\t\t\tif (datasets.length) {\n\t\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttext.push('</li>');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\ttext.push('</ul>');\n\t\t\t\treturn text.join('');\n\t\t\t},\n\t\t\tlegend: {\n\t\t\t\tlabels: {\n\t\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\t\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\t\n\t\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tonClick: function(e, legendItem) {\n\t\t\t\t\tvar index = legendItem.index;\n\t\t\t\t\tvar chart = this.chart;\n\t\t\t\t\tvar i, ilen, meta;\n\t\n\t\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\t// toggle visibility of index if exists\n\t\t\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tchart.update();\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// The percentage of the chart that we cut out of the middle.\n\t\t\tcutoutPercentage: 50,\n\t\n\t\t\t// The rotation of the chart, where the first data arc begins.\n\t\t\trotation: Math.PI * -0.5,\n\t\n\t\t\t// The total circumference of the chart.\n\t\t\tcircumference: Math.PI * 2.0,\n\t\n\t\t\t// Need to override these to give a nice default\n\t\t\ttooltips: {\n\t\t\t\tcallbacks: {\n\t\t\t\t\ttitle: function() {\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t},\n\t\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\t\treturn data.labels[tooltipItem.index] + ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tdefaults.pie = helpers.clone(defaults.doughnut);\n\t\thelpers.extend(defaults.pie, {\n\t\t\tcutoutPercentage: 0\n\t\t});\n\t\n\t\n\t\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\t\n\t\t\tdataElementType: Chart.elements.Arc,\n\t\n\t\t\tlinkScales: helpers.noop,\n\t\n\t\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\t\tgetRingIndex: function(datasetIndex) {\n\t\t\t\tvar ringIndex = 0;\n\t\n\t\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t\t++ringIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn ringIndex;\n\t\t\t},\n\t\n\t\t\tupdate: function(reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar chart = me.chart,\n\t\t\t\t\tchartArea = chart.chartArea,\n\t\t\t\t\topts = chart.options,\n\t\t\t\t\tarcOpts = opts.elements.arc,\n\t\t\t\t\tavailableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\n\t\t\t\t\tavailableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\n\t\t\t\t\tminSize = Math.min(availableWidth, availableHeight),\n\t\t\t\t\toffset = {\n\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\ty: 0\n\t\t\t\t\t},\n\t\t\t\t\tmeta = me.getMeta(),\n\t\t\t\t\tcutoutPercentage = opts.cutoutPercentage,\n\t\t\t\t\tcircumference = opts.circumference;\n\t\n\t\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\t\tvar contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t\t}\n\t\n\t\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 1, 0);\n\t\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\t\n\t\t\t\tmeta.total = me.calculateTotal();\n\t\n\t\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n\t\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\t\n\t\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tupdateElement: function(arc, index, reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar chart = me.chart,\n\t\t\t\t\tchartArea = chart.chartArea,\n\t\t\t\t\topts = chart.options,\n\t\t\t\t\tanimationOpts = opts.animation,\n\t\t\t\t\tcenterX = (chartArea.left + chartArea.right) / 2,\n\t\t\t\t\tcenterY = (chartArea.top + chartArea.bottom) / 2,\n\t\t\t\t\tstartAngle = opts.rotation, // non reset case handled later\n\t\t\t\t\tendAngle = opts.rotation, // non reset case handled later\n\t\t\t\t\tdataset = me.getDataset(),\n\t\t\t\t\tcircumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\n\t\t\t\t\tinnerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\n\t\t\t\t\touterRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\n\t\t\t\t\tvalueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\n\t\t\t\thelpers.extend(arc, {\n\t\t\t\t\t// Utility\n\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t_index: index,\n\t\n\t\t\t\t\t// Desired view properties\n\t\t\t\t\t_model: {\n\t\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tvar model = arc._model;\n\t\t\t\t// Resets the visual styles\n\t\t\t\tthis.removeHoverStyle(arc);\n\t\n\t\t\t\t// Set correct angles if not resetting\n\t\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t\t}\n\t\n\t\t\t\tarc.pivot();\n\t\t\t},\n\t\n\t\t\tremoveHoverStyle: function(arc) {\n\t\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t\t},\n\t\n\t\t\tcalculateTotal: function() {\n\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\tvar meta = this.getMeta();\n\t\t\t\tvar total = 0;\n\t\t\t\tvar value;\n\t\n\t\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\t\tvalue = dataset.data[index];\n\t\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t/* if (total === 0) {\n\t\t\t\t\ttotal = NaN;\n\t\t\t\t}*/\n\t\n\t\t\t\treturn total;\n\t\t\t},\n\t\n\t\t\tcalculateCircumference: function(value) {\n\t\t\t\tvar total = this.getMeta().total;\n\t\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\t\treturn (Math.PI * 2.0) * (value / total);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t},\n\t\n\t\t\t// gets the max border or hover width to properly scale pie charts\n\t\t\tgetMaxBorderWidth: function(elements) {\n\t\t\t\tvar max = 0,\n\t\t\t\t\tindex = this.index,\n\t\t\t\t\tlength = elements.length,\n\t\t\t\t\tborderWidth,\n\t\t\t\t\thoverWidth;\n\t\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tborderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\n\t\t\t\t\thoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\t\n\t\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t\t}\n\t\t\t\treturn max;\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.line = {\n\t\t\tshowLines: true,\n\t\t\tspanGaps: false,\n\t\n\t\t\thover: {\n\t\t\t\tmode: 'label'\n\t\t\t},\n\t\n\t\t\tscales: {\n\t\t\t\txAxes: [{\n\t\t\t\t\ttype: 'category',\n\t\t\t\t\tid: 'x-axis-0'\n\t\t\t\t}],\n\t\t\t\tyAxes: [{\n\t\t\t\t\ttype: 'linear',\n\t\t\t\t\tid: 'y-axis-0'\n\t\t\t\t}]\n\t\t\t}\n\t\t};\n\t\n\t\tfunction lineEnabled(dataset, options) {\n\t\t\treturn helpers.getValueOrDefault(dataset.showLine, options.showLines);\n\t\t}\n\t\n\t\tChart.controllers.line = Chart.DatasetController.extend({\n\t\n\t\t\tdatasetElementType: Chart.elements.Line,\n\t\n\t\t\tdataElementType: Chart.elements.Point,\n\t\n\t\t\taddElementAndReset: function(index) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar options = me.chart.options;\n\t\t\t\tvar meta = me.getMeta();\n\t\n\t\t\t\tChart.DatasetController.prototype.addElementAndReset.call(me, index);\n\t\n\t\t\t\t// Make sure bezier control points are updated\n\t\t\t\tif (lineEnabled(me.getDataset(), options) && meta.dataset._model.tension !== 0) {\n\t\t\t\t\tme.updateBezierControlPoints();\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tupdate: function(reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar line = meta.dataset;\n\t\t\t\tvar points = meta.data || [];\n\t\t\t\tvar options = me.chart.options;\n\t\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar i, ilen, custom;\n\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\tvar showLine = lineEnabled(dataset, options);\n\t\n\t\t\t\t// Update Line\n\t\t\t\tif (showLine) {\n\t\t\t\t\tcustom = line.custom || {};\n\t\n\t\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Utility\n\t\t\t\t\tline._scale = scale;\n\t\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t\t// Data\n\t\t\t\t\tline._children = points;\n\t\t\t\t\t// Model\n\t\t\t\t\tline._model = {\n\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t\t// This option gives linse the ability to span gaps\n\t\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t\t\t// Scale\n\t\t\t\t\t\tscaleTop: scale.top,\n\t\t\t\t\t\tscaleBottom: scale.bottom,\n\t\t\t\t\t\tscaleZero: scale.getBasePixel()\n\t\t\t\t\t};\n\t\n\t\t\t\t\tline.pivot();\n\t\t\t\t}\n\t\n\t\t\t\t// Update Points\n\t\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t\t}\n\t\n\t\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\t\tme.updateBezierControlPoints();\n\t\t\t\t}\n\t\n\t\t\t\t// Now pivot the point for animation\n\t\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\t\tpoints[i].pivot();\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\tvar custom = point.custom || {};\n\t\n\t\t\t\tif (custom.backgroundColor) {\n\t\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\t\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t\t}\n\t\n\t\t\t\treturn backgroundColor;\n\t\t\t},\n\t\n\t\t\tgetPointBorderColor: function(point, index) {\n\t\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\tvar custom = point.custom || {};\n\t\n\t\t\t\tif (custom.borderColor) {\n\t\t\t\t\tborderColor = custom.borderColor;\n\t\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\t\tborderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t\t} else if (dataset.borderColor) {\n\t\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t\t}\n\t\n\t\t\t\treturn borderColor;\n\t\t\t},\n\t\n\t\t\tgetPointBorderWidth: function(point, index) {\n\t\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\tvar custom = point.custom || {};\n\t\n\t\t\t\tif (custom.borderWidth) {\n\t\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t\t} else if (dataset.pointBorderWidth) {\n\t\t\t\t\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t\t} else if (dataset.borderWidth) {\n\t\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t\t}\n\t\n\t\t\t\treturn borderWidth;\n\t\t\t},\n\t\n\t\t\tupdateElement: function(point, index, reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\tvar datasetIndex = me.index;\n\t\t\t\tvar value = dataset.data[index];\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\t\tvar x, y;\n\t\t\t\tvar labels = me.chart.data.labels || [];\n\t\t\t\tvar includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;\n\t\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t\t}\n\t\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t\t}\n\t\n\t\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);\n\t\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\t\n\t\t\t\t// Utility\n\t\t\t\tpoint._xScale = xScale;\n\t\t\t\tpoint._yScale = yScale;\n\t\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\t\tpoint._index = index;\n\t\n\t\t\t\t// Desired view properties\n\t\t\t\tpoint._model = {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t\t// Appearance\n\t\t\t\t\tradius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\t\tpointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\tvar sumPos = 0;\n\t\t\t\tvar sumNeg = 0;\n\t\t\t\tvar i, ds, dsMeta;\n\t\n\t\t\t\tif (yScale.options.stacked) {\n\t\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t\t}\n\t\n\t\t\t\treturn yScale.getPixelForValue(value);\n\t\t\t},\n\t\n\t\t\tupdateBezierControlPoints: function() {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar area = me.chart.chartArea;\n\t\t\t\tvar points = (meta.data || []);\n\t\t\t\tvar i, ilen, point, model, controlPoints;\n\t\n\t\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t\t}\n\t\n\t\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\t\tpoint = points[i];\n\t\t\t\t\t\tmodel = point._model;\n\t\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t\t);\n\t\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tdraw: function(ease) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar points = meta.data || [];\n\t\t\t\tvar easingDecimal = ease || 1;\n\t\t\t\tvar i, ilen;\n\t\n\t\t\t\t// Transition Point Locations\n\t\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\t\tpoints[i].transition(easingDecimal);\n\t\t\t\t}\n\t\n\t\t\t\t// Transition and Draw the line\n\t\t\t\tif (lineEnabled(me.getDataset(), me.chart.options)) {\n\t\t\t\t\tmeta.dataset.transition(easingDecimal).draw();\n\t\t\t\t}\n\t\n\t\t\t\t// Draw the points\n\t\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\t\tpoints[i].draw();\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tsetHoverStyle: function(point) {\n\t\t\t\t// Point\n\t\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\t\tvar index = point._index;\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar model = point._model;\n\t\n\t\t\t\tmodel.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t\t},\n\t\n\t\t\tremoveHoverStyle: function(point) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\t\tvar index = point._index;\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar model = point._model;\n\t\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t\t}\n\t\n\t\t\t\tmodel.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.polarArea = {\n\t\n\t\t\tscale: {\n\t\t\t\ttype: 'radialLinear',\n\t\t\t\tlineArc: true, // so that lines are circular\n\t\t\t\tticks: {\n\t\t\t\t\tbeginAtZero: true\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// Boolean - Whether to animate the rotation of the chart\n\t\t\tanimation: {\n\t\t\t\tanimateRotate: true,\n\t\t\t\tanimateScale: true\n\t\t\t},\n\t\n\t\t\tstartAngle: -0.5 * Math.PI,\n\t\t\taspectRatio: 1,\n\t\t\tlegendCallback: function(chart) {\n\t\t\t\tvar text = [];\n\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\n\t\t\t\tvar data = chart.data;\n\t\t\t\tvar datasets = data.datasets;\n\t\t\t\tvar labels = data.labels;\n\t\n\t\t\t\tif (datasets.length) {\n\t\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\">');\n\t\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttext.push('</span></li>');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\ttext.push('</ul>');\n\t\t\t\treturn text.join('');\n\t\t\t},\n\t\t\tlegend: {\n\t\t\t\tlabels: {\n\t\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\t\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\t\n\t\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tonClick: function(e, legendItem) {\n\t\t\t\t\tvar index = legendItem.index;\n\t\t\t\t\tvar chart = this.chart;\n\t\t\t\t\tvar i, ilen, meta;\n\t\n\t\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tchart.update();\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t// Need to override these to give a nice default\n\t\t\ttooltips: {\n\t\t\t\tcallbacks: {\n\t\t\t\t\ttitle: function() {\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t},\n\t\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\t\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\t\n\t\t\tdataElementType: Chart.elements.Arc,\n\t\n\t\t\tlinkScales: helpers.noop,\n\t\n\t\t\tupdate: function(reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tvar chartArea = chart.chartArea;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar opts = chart.options;\n\t\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\n\t\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\t\n\t\t\t\tmeta.count = me.countVisibleElements();\n\t\n\t\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tupdateElement: function(arc, index, reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\tvar opts = chart.options;\n\t\t\t\tvar animationOpts = opts.animation;\n\t\t\t\tvar scale = chart.scale;\n\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\tvar labels = chart.data.labels;\n\t\n\t\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\t\tvar centerX = scale.xCenter;\n\t\t\t\tvar centerY = scale.yCenter;\n\t\n\t\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\t\tvar visibleCount = 0;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t\t++visibleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\t\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\n\t\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\t\n\t\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\n\t\t\t\thelpers.extend(arc, {\n\t\t\t\t\t// Utility\n\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t_index: index,\n\t\t\t\t\t_scale: scale,\n\t\n\t\t\t\t\t// Desired view properties\n\t\t\t\t\t_model: {\n\t\t\t\t\t\tx: centerX,\n\t\t\t\t\t\ty: centerY,\n\t\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\t\tlabel: getValueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t// Apply border and fill style\n\t\t\t\tme.removeHoverStyle(arc);\n\t\n\t\t\t\tarc.pivot();\n\t\t\t},\n\t\n\t\t\tremoveHoverStyle: function(arc) {\n\t\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t\t},\n\t\n\t\t\tcountVisibleElements: function() {\n\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\tvar meta = this.getMeta();\n\t\t\t\tvar count = 0;\n\t\n\t\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\treturn count;\n\t\t\t},\n\t\n\t\t\tcalculateCircumference: function(value) {\n\t\t\t\tvar count = this.getMeta().count;\n\t\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\t\treturn (2 * Math.PI) / count;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar helpers = Chart.helpers;\n\t\n\t\tChart.defaults.radar = {\n\t\t\tscale: {\n\t\t\t\ttype: 'radialLinear'\n\t\t\t},\n\t\t\telements: {\n\t\t\t\tline: {\n\t\t\t\t\ttension: 0 // no bezier in radar\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tChart.controllers.radar = Chart.DatasetController.extend({\n\t\n\t\t\tdatasetElementType: Chart.elements.Line,\n\t\n\t\t\tdataElementType: Chart.elements.Point,\n\t\n\t\t\tlinkScales: helpers.noop,\n\t\n\t\t\taddElementAndReset: function(index) {\n\t\t\t\tChart.DatasetController.prototype.addElementAndReset.call(this, index);\n\t\n\t\t\t\t// Make sure bezier control points are updated\n\t\t\t\tthis.updateBezierControlPoints();\n\t\t\t},\n\t\n\t\t\tupdate: function(reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar meta = me.getMeta();\n\t\t\t\tvar line = meta.dataset;\n\t\t\t\tvar points = meta.data;\n\t\t\t\tvar custom = line.custom || {};\n\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\t\tvar scale = me.chart.scale;\n\t\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\t\n\t\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t\t// Utility\n\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t// Data\n\t\t\t\t\t_children: points,\n\t\t\t\t\t_loop: true,\n\t\t\t\t\t// Model\n\t\t\t\t\t_model: {\n\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\n\t\t\t\t\t\t// Scale\n\t\t\t\t\t\tscaleTop: scale.top,\n\t\t\t\t\t\tscaleBottom: scale.bottom,\n\t\t\t\t\t\tscaleZero: scale.getBasePosition()\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tmeta.dataset.pivot();\n\t\n\t\t\t\t// Update Points\n\t\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t\t}, me);\n\t\n\t\n\t\t\t\t// Update bezier control points\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t},\n\t\t\tupdateElement: function(point, index, reset) {\n\t\t\t\tvar me = this;\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\tvar scale = me.chart.scale;\n\t\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\t\n\t\t\t\thelpers.extend(point, {\n\t\t\t\t\t// Utility\n\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t_index: index,\n\t\t\t\t\t_scale: scale,\n\t\n\t\t\t\t\t// Desired view properties\n\t\t\t\t\t_model: {\n\t\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\t\n\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.tension, me.chart.options.elements.line.tension),\n\t\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\t\n\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n\t\t\t},\n\t\t\tupdateBezierControlPoints: function() {\n\t\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\t\tvar meta = this.getMeta();\n\t\n\t\t\t\thelpers.each(meta.data, function(point, index) {\n\t\t\t\t\tvar model = point._model;\n\t\t\t\t\tvar controlPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,\n\t\t\t\t\t\tmodel.tension\n\t\t\t\t\t);\n\t\n\t\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\t\n\t\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\t\n\t\t\t\t\t// Now pivot the point for animation\n\t\t\t\t\tpoint.pivot();\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tdraw: function(ease) {\n\t\t\t\tvar meta = this.getMeta();\n\t\t\t\tvar easingDecimal = ease || 1;\n\t\n\t\t\t\t// Transition Point Locations\n\t\t\t\thelpers.each(meta.data, function(point) {\n\t\t\t\t\tpoint.transition(easingDecimal);\n\t\t\t\t});\n\t\n\t\t\t\t// Transition and Draw the line\n\t\t\t\tmeta.dataset.transition(easingDecimal).draw();\n\t\n\t\t\t\t// Draw the points\n\t\t\t\thelpers.each(meta.data, function(point) {\n\t\t\t\t\tpoint.draw();\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tsetHoverStyle: function(point) {\n\t\t\t\t// Point\n\t\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar index = point._index;\n\t\t\t\tvar model = point._model;\n\t\n\t\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t\t},\n\t\n\t\t\tremoveHoverStyle: function(point) {\n\t\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\t\tvar custom = point.custom || {};\n\t\t\t\tvar index = point._index;\n\t\t\t\tvar model = point._model;\n\t\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\t\n\t\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);\n\t\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t\t}\n\t\t});\n\t};\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tChart.Bar = function(context, config) {\n\t\t\tconfig.type = 'bar';\n\t\n\t\t\treturn new Chart(context, config);\n\t\t};\n\t\n\t};\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tChart.Bubble = function(context, config) {\n\t\t\tconfig.type = 'bubble';\n\t\t\treturn new Chart(context, config);\n\t\t};\n\t\n\t};\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tChart.Doughnut = function(context, config) {\n\t\t\tconfig.type = 'doughnut';\n\t\n\t\t\treturn new Chart(context, config);\n\t\t};\n\t\n\t};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tChart.Line = function(context, config) {\n\t\t\tconfig.type = 'line';\n\t\n\t\t\treturn new Chart(context, config);\n\t\t};\n\t\n\t};\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tChart.PolarArea = function(context, config) {\n\t\t\tconfig.type = 'polarArea';\n\t\n\t\t\treturn new Chart(context, config);\n\t\t};\n\t\n\t};\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tChart.Radar = function(context, config) {\n\t\t\tconfig.options = Chart.helpers.configMerge({aspectRatio: 1}, config.options);\n\t\t\tconfig.type = 'radar';\n\t\n\t\t\treturn new Chart(context, config);\n\t\t};\n\t\n\t};\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function(Chart) {\n\t\n\t\tvar defaultConfig = {\n\t\t\thover: {\n\t\t\t\tmode: 'single'\n\t\t\t},\n\t\n\t\t\tscales: {\n\t\t\t\txAxes: [{\n\t\t\t\t\ttype: 'linear', // scatter should not use a category axis\n\t\t\t\t\tposition: 'bottom',\n\t\t\t\t\tid: 'x-axis-1' // need an ID so datasets can reference the scale\n\t\t\t\t}],\n\t\t\t\tyAxes: [{\n\t\t\t\t\ttype: 'linear',\n\t\t\t\t\tposition: 'left',\n\t\t\t\t\tid: 'y-axis-1'\n\t\t\t\t}]\n\t\t\t},\n\t\n\t\t\ttooltips: {\n\t\t\t\tcallbacks: {\n\t\t\t\t\ttitle: function() {\n\t\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t},\n\t\t\t\t\tlabel: function(tooltipItem) {\n\t\t\t\t\t\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t// Register the default config for this type\n\t\tChart.defaults.scatter = defaultConfig;\n\t\n\t\t// Scatter charts use line controllers\n\t\tChart.controllers.scatter = Chart.controllers.line;\n\t\n\t\tChart.Scatter = function(context, config) {\n\t\t\tconfig.type = 'scatter';\n\t\t\treturn new Chart(context, config);\n\t\t};\n\t\n\t};\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Validator = module.exports.Validator = __webpack_require__(47);\n\t\n\tmodule.exports.ValidatorResult = __webpack_require__(55).ValidatorResult;\n\tmodule.exports.ValidationError = __webpack_require__(55).ValidationError;\n\tmodule.exports.SchemaError = __webpack_require__(55).SchemaError;\n\t\n\tmodule.exports.validate = function (instance, schema, options) {\n\t  var v = new Validator();\n\t  return v.validate(instance, schema, options);\n\t};\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar urilib = __webpack_require__(48);\n\t\n\tvar attribute = __webpack_require__(54);\n\tvar helpers = __webpack_require__(55);\n\tvar ValidatorResult = helpers.ValidatorResult;\n\tvar SchemaError = helpers.SchemaError;\n\tvar SchemaContext = helpers.SchemaContext;\n\t\n\t/**\n\t * Creates a new Validator object\n\t * @name Validator\n\t * @constructor\n\t */\n\tvar Validator = function Validator () {\n\t  // Allow a validator instance to override global custom formats or to have their\n\t  // own custom formats.\n\t  this.customFormats = Object.create(Validator.prototype.customFormats);\n\t  this.schemas = {};\n\t  this.unresolvedRefs = [];\n\t\n\t  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n\t  this.types = Object.create(types);\n\t  this.attributes = Object.create(attribute.validators);\n\t};\n\t\n\t// Allow formats to be registered globally.\n\tValidator.prototype.customFormats = {};\n\t\n\t// Hint at the presence of a property\n\tValidator.prototype.schemas = null;\n\tValidator.prototype.types = null;\n\tValidator.prototype.attributes = null;\n\tValidator.prototype.unresolvedRefs = null;\n\t\n\t/**\n\t * Adds a schema with a certain urn to the Validator instance.\n\t * @param schema\n\t * @param urn\n\t * @return {Object}\n\t */\n\tValidator.prototype.addSchema = function addSchema (schema, uri) {\n\t  if (!schema) {\n\t    return null;\n\t  }\n\t  var ourUri = uri || schema.id;\n\t  this.addSubSchema(ourUri, schema);\n\t  if (ourUri) {\n\t    this.schemas[ourUri] = schema;\n\t  }\n\t  return this.schemas[ourUri];\n\t};\n\t\n\tValidator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {\n\t  if(!schema || typeof schema!='object') return;\n\t  // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n\t  if(schema.$ref){\n\t    var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n\t    // Only mark unknown schemas as unresolved\n\t    if (this.schemas[resolvedUri] === undefined) {\n\t      this.schemas[resolvedUri] = null;\n\t      this.unresolvedRefs.push(resolvedUri);\n\t    }\n\t    return;\n\t  }\n\t  var ourUri = schema.id && urilib.resolve(baseuri, schema.id);\n\t  var ourBase = ourUri || baseuri;\n\t  if (ourUri) {\n\t    if(this.schemas[ourUri]){\n\t      if(!helpers.deepCompareStrict(this.schemas[ourUri], schema)){\n\t        throw new Error('Schema <'+schema+'> already exists with different definition');\n\t      }\n\t      return this.schemas[ourUri];\n\t    }\n\t    this.schemas[ourUri] = schema;\n\t    var documentUri = ourUri.replace(/^([^#]*)#$/, '$1');\n\t    this.schemas[documentUri] = schema;\n\t  }\n\t  this.addSubSchemaArray(ourBase, ((schema.items instanceof Array)?schema.items:[schema.items]));\n\t  this.addSubSchemaArray(ourBase, ((schema.extends instanceof Array)?schema.extends:[schema.extends]));\n\t  this.addSubSchema(ourBase, schema.additionalItems);\n\t  this.addSubSchemaObject(ourBase, schema.properties);\n\t  this.addSubSchema(ourBase, schema.additionalProperties);\n\t  this.addSubSchemaObject(ourBase, schema.definitions);\n\t  this.addSubSchemaObject(ourBase, schema.patternProperties);\n\t  this.addSubSchemaObject(ourBase, schema.dependencies);\n\t  this.addSubSchemaArray(ourBase, schema.disallow);\n\t  this.addSubSchemaArray(ourBase, schema.allOf);\n\t  this.addSubSchemaArray(ourBase, schema.anyOf);\n\t  this.addSubSchemaArray(ourBase, schema.oneOf);\n\t  this.addSubSchema(ourBase, schema.not);\n\t  return this.schemas[ourUri];\n\t};\n\t\n\tValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n\t  if(!(schemas instanceof Array)) return;\n\t  for(var i=0; i<schemas.length; i++){\n\t    this.addSubSchema(baseuri, schemas[i]);\n\t  }\n\t};\n\t\n\tValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n\t  if(!schemas || typeof schemas!='object') return;\n\t  for(var p in schemas){\n\t    this.addSubSchema(baseuri, schemas[p]);\n\t  }\n\t};\n\t\n\t\n\t\n\t/**\n\t * Sets all the schemas of the Validator instance.\n\t * @param schemas\n\t */\n\tValidator.prototype.setSchemas = function setSchemas (schemas) {\n\t  this.schemas = schemas;\n\t};\n\t\n\t/**\n\t * Returns the schema of a certain urn\n\t * @param urn\n\t */\n\tValidator.prototype.getSchema = function getSchema (urn) {\n\t  return this.schemas[urn];\n\t};\n\t\n\t/**\n\t * Validates instance against the provided schema\n\t * @param instance\n\t * @param schema\n\t * @param [options]\n\t * @param [ctx]\n\t * @return {Array}\n\t */\n\tValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t  var propertyName = options.propertyName || 'instance';\n\t  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n\t  var base = urilib.resolve(options.base||'/', schema.id||'');\n\t  if(!ctx){\n\t    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n\t    if (!ctx.schemas[base]) {\n\t      ctx.schemas[base] = schema;\n\t    }\n\t  }\n\t  if (schema) {\n\t    var result = this.validateSchema(instance, schema, options, ctx);\n\t    if (!result) {\n\t      throw new Error('Result undefined');\n\t    }\n\t    return result;\n\t  }\n\t  throw new SchemaError('no schema specified', schema);\n\t};\n\t\n\t/**\n\t * Validates an instance against the schema (the actual work horse)\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @private\n\t * @return {ValidatorResult}\n\t */\n\tValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n\t  var self = this;\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!schema) {\n\t    throw new Error(\"schema is undefined\");\n\t  }\n\t\n\t  /**\n\t  * @param Object schema\n\t  * @return mixed schema uri or false\n\t  */\n\t  function shouldResolve(schema) {\n\t    var ref = (typeof schema === 'string') ? schema : schema.$ref;\n\t    if (typeof ref=='string') return ref;\n\t    return false;\n\t  }\n\t  /**\n\t  * @param Object schema\n\t  * @param SchemaContext ctx\n\t  * @returns Object schema or resolved schema\n\t  */\n\t  function resolve(schema, ctx) {\n\t    var ref;\n\t    if(ref = shouldResolve(schema)) {\n\t      return self.resolve(schema, ref, ctx).subschema;\n\t    }\n\t    return schema;\n\t  }\n\t\n\t  if (schema['extends']) {\n\t    if (schema['extends'] instanceof Array) {\n\t      schema['extends'].forEach(function (s) {\n\t        schema = helpers.deepMerge(schema, resolve(s, ctx));\n\t      });\n\t    } else {\n\t      schema = helpers.deepMerge(schema, resolve(schema['extends'], ctx));\n\t    }\n\t  }\n\t\n\t  var switchSchema;\n\t  if (switchSchema = shouldResolve(schema)) {\n\t    var resolved = this.resolve(schema, switchSchema, ctx);\n\t    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n\t    return this.validateSchema(instance, resolved.subschema, options, subctx);\n\t  }\n\t\n\t  var skipAttributes = options && options.skipAttributes || [];\n\t  // Validate each schema attribute against the instance\n\t  for (var key in schema) {\n\t    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n\t      var validatorErr = null;\n\t      var validator = self.attributes[key];\n\t      if (validator) {\n\t        validatorErr = validator.call(self, instance, schema, options, ctx);\n\t      } else if (options.allowUnknownAttributes === false) {\n\t        // This represents an error with the schema itself, not an invalid instance\n\t        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n\t      }\n\t      if (validatorErr) {\n\t        result.importErrors(validatorErr);\n\t      }\n\t    }\n\t  }\n\t\n\t  if (typeof options.rewrite == 'function') {\n\t    var value = options.rewrite.call(this, instance, schema, options, ctx);\n\t    result.instance = value;\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t* @private\n\t* @param Object schema\n\t* @param Object switchSchema\n\t* @param SchemaContext ctx\n\t* @return Object resolved schemas {subschema:String, switchSchema: String}\n\t* @thorws SchemaError\n\t*/\n\tValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n\t  switchSchema = ctx.resolve(switchSchema);\n\t  // First see if the schema exists under the provided URI\n\t  if (ctx.schemas[switchSchema]) {\n\t    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n\t  }\n\t  // Else try walking the property pointer\n\t  var parsed = urilib.parse(switchSchema);\n\t  var fragment = parsed && parsed.hash;\n\t  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n\t  if (!document || !ctx.schemas[document]) {\n\t    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n\t  }\n\t  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n\t  if(subschema===undefined){\n\t    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n\t  }\n\t  return {subschema: subschema, switchSchema: switchSchema};\n\t};\n\t\n\t/**\n\t * Tests whether the instance if of a certain type.\n\t * @private\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @param type\n\t * @return {boolean}\n\t */\n\tValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n\t  if (typeof this.types[type] == 'function') {\n\t    return this.types[type].call(this, instance);\n\t  }\n\t  if (type && typeof type == 'object') {\n\t    var res = this.validateSchema(instance, type, options, ctx);\n\t    return res === undefined || !(res && res.errors.length);\n\t  }\n\t  // Undefined or properties not on the list are acceptable, same as not being defined\n\t  return true;\n\t};\n\t\n\tvar types = Validator.prototype.types = {};\n\ttypes.string = function testString (instance) {\n\t  return typeof instance == 'string';\n\t};\n\ttypes.number = function testNumber (instance) {\n\t  // isFinite returns false for NaN, Infinity, and -Infinity\n\t  return typeof instance == 'number' && isFinite(instance);\n\t};\n\ttypes.integer = function testInteger (instance) {\n\t  return (typeof instance == 'number') && instance % 1 === 0;\n\t};\n\ttypes.boolean = function testBoolean (instance) {\n\t  return typeof instance == 'boolean';\n\t};\n\ttypes.array = function testArray (instance) {\n\t  return instance instanceof Array;\n\t};\n\ttypes['null'] = function testNull (instance) {\n\t  return instance === null;\n\t};\n\ttypes.date = function testDate (instance) {\n\t  return instance instanceof Date;\n\t};\n\ttypes.any = function testAny (instance) {\n\t  return true;\n\t};\n\ttypes.object = function testObject (instance) {\n\t  // TODO: fix this - see #15\n\t  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n\t};\n\t\n\tmodule.exports = Validator;\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tvar punycode = __webpack_require__(49);\n\t\n\texports.parse = urlParse;\n\texports.resolve = urlResolve;\n\texports.resolveObject = urlResolveObject;\n\texports.format = urlFormat;\n\t\n\texports.Url = Url;\n\t\n\tfunction Url() {\n\t  this.protocol = null;\n\t  this.slashes = null;\n\t  this.auth = null;\n\t  this.host = null;\n\t  this.port = null;\n\t  this.hostname = null;\n\t  this.hash = null;\n\t  this.search = null;\n\t  this.query = null;\n\t  this.pathname = null;\n\t  this.path = null;\n\t  this.href = null;\n\t}\n\t\n\t// Reference: RFC 3986, RFC 1808, RFC 2396\n\t\n\t// define these here so at least they only have to be\n\t// compiled once on the first module load.\n\tvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n\t    portPattern = /:[0-9]*$/,\n\t\n\t    // RFC 2396: characters reserved for delimiting URLs.\n\t    // We actually just auto-escape these.\n\t    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\t\n\t    // RFC 2396: characters not allowed for various reasons.\n\t    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\t\n\t    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n\t    autoEscape = ['\\''].concat(unwise),\n\t    // Characters that are never ever allowed in a hostname.\n\t    // Note that any invalid chars are also handled, but these\n\t    // are the ones that are *expected* to be seen, so we fast-path\n\t    // them.\n\t    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n\t    hostEndingChars = ['/', '?', '#'],\n\t    hostnameMaxLen = 255,\n\t    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n\t    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n\t    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n\t    unsafeProtocol = {\n\t      'javascript': true,\n\t      'javascript:': true\n\t    },\n\t    // protocols that never have a hostname.\n\t    hostlessProtocol = {\n\t      'javascript': true,\n\t      'javascript:': true\n\t    },\n\t    // protocols that always contain a // bit.\n\t    slashedProtocol = {\n\t      'http': true,\n\t      'https': true,\n\t      'ftp': true,\n\t      'gopher': true,\n\t      'file': true,\n\t      'http:': true,\n\t      'https:': true,\n\t      'ftp:': true,\n\t      'gopher:': true,\n\t      'file:': true\n\t    },\n\t    querystring = __webpack_require__(51);\n\t\n\tfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n\t  if (url && isObject(url) && url instanceof Url) return url;\n\t\n\t  var u = new Url;\n\t  u.parse(url, parseQueryString, slashesDenoteHost);\n\t  return u;\n\t}\n\t\n\tUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n\t  if (!isString(url)) {\n\t    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n\t  }\n\t\n\t  var rest = url;\n\t\n\t  // trim before proceeding.\n\t  // This is to support parse stuff like \"  http://foo.com  \\n\"\n\t  rest = rest.trim();\n\t\n\t  var proto = protocolPattern.exec(rest);\n\t  if (proto) {\n\t    proto = proto[0];\n\t    var lowerProto = proto.toLowerCase();\n\t    this.protocol = lowerProto;\n\t    rest = rest.substr(proto.length);\n\t  }\n\t\n\t  // figure out if it's got a host\n\t  // user@server is *always* interpreted as a hostname, and url\n\t  // resolution will treat //foo/bar as host=foo,path=bar because that's\n\t  // how the browser resolves relative URLs.\n\t  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n\t    var slashes = rest.substr(0, 2) === '//';\n\t    if (slashes && !(proto && hostlessProtocol[proto])) {\n\t      rest = rest.substr(2);\n\t      this.slashes = true;\n\t    }\n\t  }\n\t\n\t  if (!hostlessProtocol[proto] &&\n\t      (slashes || (proto && !slashedProtocol[proto]))) {\n\t\n\t    // there's a hostname.\n\t    // the first instance of /, ?, ;, or # ends the host.\n\t    //\n\t    // If there is an @ in the hostname, then non-host chars *are* allowed\n\t    // to the left of the last @ sign, unless some host-ending character\n\t    // comes *before* the @-sign.\n\t    // URLs are obnoxious.\n\t    //\n\t    // ex:\n\t    // http://a@b@c/ => user:a@b host:c\n\t    // http://a@b?@c => user:a host:c path:/?@c\n\t\n\t    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n\t    // Review our test case against browsers more comprehensively.\n\t\n\t    // find the first instance of any hostEndingChars\n\t    var hostEnd = -1;\n\t    for (var i = 0; i < hostEndingChars.length; i++) {\n\t      var hec = rest.indexOf(hostEndingChars[i]);\n\t      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n\t        hostEnd = hec;\n\t    }\n\t\n\t    // at this point, either we have an explicit point where the\n\t    // auth portion cannot go past, or the last @ char is the decider.\n\t    var auth, atSign;\n\t    if (hostEnd === -1) {\n\t      // atSign can be anywhere.\n\t      atSign = rest.lastIndexOf('@');\n\t    } else {\n\t      // atSign must be in auth portion.\n\t      // http://a@b/c@d => host:b auth:a path:/c@d\n\t      atSign = rest.lastIndexOf('@', hostEnd);\n\t    }\n\t\n\t    // Now we have a portion which is definitely the auth.\n\t    // Pull that off.\n\t    if (atSign !== -1) {\n\t      auth = rest.slice(0, atSign);\n\t      rest = rest.slice(atSign + 1);\n\t      this.auth = decodeURIComponent(auth);\n\t    }\n\t\n\t    // the host is the remaining to the left of the first non-host char\n\t    hostEnd = -1;\n\t    for (var i = 0; i < nonHostChars.length; i++) {\n\t      var hec = rest.indexOf(nonHostChars[i]);\n\t      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n\t        hostEnd = hec;\n\t    }\n\t    // if we still have not hit it, then the entire thing is a host.\n\t    if (hostEnd === -1)\n\t      hostEnd = rest.length;\n\t\n\t    this.host = rest.slice(0, hostEnd);\n\t    rest = rest.slice(hostEnd);\n\t\n\t    // pull out port.\n\t    this.parseHost();\n\t\n\t    // we've indicated that there is a hostname,\n\t    // so even if it's empty, it has to be present.\n\t    this.hostname = this.hostname || '';\n\t\n\t    // if hostname begins with [ and ends with ]\n\t    // assume that it's an IPv6 address.\n\t    var ipv6Hostname = this.hostname[0] === '[' &&\n\t        this.hostname[this.hostname.length - 1] === ']';\n\t\n\t    // validate a little.\n\t    if (!ipv6Hostname) {\n\t      var hostparts = this.hostname.split(/\\./);\n\t      for (var i = 0, l = hostparts.length; i < l; i++) {\n\t        var part = hostparts[i];\n\t        if (!part) continue;\n\t        if (!part.match(hostnamePartPattern)) {\n\t          var newpart = '';\n\t          for (var j = 0, k = part.length; j < k; j++) {\n\t            if (part.charCodeAt(j) > 127) {\n\t              // we replace non-ASCII char with a temporary placeholder\n\t              // we need this to make sure size of hostname is not\n\t              // broken by replacing non-ASCII by nothing\n\t              newpart += 'x';\n\t            } else {\n\t              newpart += part[j];\n\t            }\n\t          }\n\t          // we test again with ASCII char only\n\t          if (!newpart.match(hostnamePartPattern)) {\n\t            var validParts = hostparts.slice(0, i);\n\t            var notHost = hostparts.slice(i + 1);\n\t            var bit = part.match(hostnamePartStart);\n\t            if (bit) {\n\t              validParts.push(bit[1]);\n\t              notHost.unshift(bit[2]);\n\t            }\n\t            if (notHost.length) {\n\t              rest = '/' + notHost.join('.') + rest;\n\t            }\n\t            this.hostname = validParts.join('.');\n\t            break;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (this.hostname.length > hostnameMaxLen) {\n\t      this.hostname = '';\n\t    } else {\n\t      // hostnames are always lower case.\n\t      this.hostname = this.hostname.toLowerCase();\n\t    }\n\t\n\t    if (!ipv6Hostname) {\n\t      // IDNA Support: Returns a puny coded representation of \"domain\".\n\t      // It only converts the part of the domain name that\n\t      // has non ASCII characters. I.e. it dosent matter if\n\t      // you call it with a domain that already is in ASCII.\n\t      var domainArray = this.hostname.split('.');\n\t      var newOut = [];\n\t      for (var i = 0; i < domainArray.length; ++i) {\n\t        var s = domainArray[i];\n\t        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n\t            'xn--' + punycode.encode(s) : s);\n\t      }\n\t      this.hostname = newOut.join('.');\n\t    }\n\t\n\t    var p = this.port ? ':' + this.port : '';\n\t    var h = this.hostname || '';\n\t    this.host = h + p;\n\t    this.href += this.host;\n\t\n\t    // strip [ and ] from the hostname\n\t    // the host field still retains them, though\n\t    if (ipv6Hostname) {\n\t      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\t      if (rest[0] !== '/') {\n\t        rest = '/' + rest;\n\t      }\n\t    }\n\t  }\n\t\n\t  // now rest is set to the post-host stuff.\n\t  // chop off any delim chars.\n\t  if (!unsafeProtocol[lowerProto]) {\n\t\n\t    // First, make 100% sure that any \"autoEscape\" chars get\n\t    // escaped, even if encodeURIComponent doesn't think they\n\t    // need to be.\n\t    for (var i = 0, l = autoEscape.length; i < l; i++) {\n\t      var ae = autoEscape[i];\n\t      var esc = encodeURIComponent(ae);\n\t      if (esc === ae) {\n\t        esc = escape(ae);\n\t      }\n\t      rest = rest.split(ae).join(esc);\n\t    }\n\t  }\n\t\n\t\n\t  // chop off from the tail first.\n\t  var hash = rest.indexOf('#');\n\t  if (hash !== -1) {\n\t    // got a fragment string.\n\t    this.hash = rest.substr(hash);\n\t    rest = rest.slice(0, hash);\n\t  }\n\t  var qm = rest.indexOf('?');\n\t  if (qm !== -1) {\n\t    this.search = rest.substr(qm);\n\t    this.query = rest.substr(qm + 1);\n\t    if (parseQueryString) {\n\t      this.query = querystring.parse(this.query);\n\t    }\n\t    rest = rest.slice(0, qm);\n\t  } else if (parseQueryString) {\n\t    // no query string, but parseQueryString still requested\n\t    this.search = '';\n\t    this.query = {};\n\t  }\n\t  if (rest) this.pathname = rest;\n\t  if (slashedProtocol[lowerProto] &&\n\t      this.hostname && !this.pathname) {\n\t    this.pathname = '/';\n\t  }\n\t\n\t  //to support http.request\n\t  if (this.pathname || this.search) {\n\t    var p = this.pathname || '';\n\t    var s = this.search || '';\n\t    this.path = p + s;\n\t  }\n\t\n\t  // finally, reconstruct the href based on what has been validated.\n\t  this.href = this.format();\n\t  return this;\n\t};\n\t\n\t// format a parsed object into a url string\n\tfunction urlFormat(obj) {\n\t  // ensure it's an object, and not a string url.\n\t  // If it's an obj, this is a no-op.\n\t  // this way, you can call url_format() on strings\n\t  // to clean up potentially wonky urls.\n\t  if (isString(obj)) obj = urlParse(obj);\n\t  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n\t  return obj.format();\n\t}\n\t\n\tUrl.prototype.format = function() {\n\t  var auth = this.auth || '';\n\t  if (auth) {\n\t    auth = encodeURIComponent(auth);\n\t    auth = auth.replace(/%3A/i, ':');\n\t    auth += '@';\n\t  }\n\t\n\t  var protocol = this.protocol || '',\n\t      pathname = this.pathname || '',\n\t      hash = this.hash || '',\n\t      host = false,\n\t      query = '';\n\t\n\t  if (this.host) {\n\t    host = auth + this.host;\n\t  } else if (this.hostname) {\n\t    host = auth + (this.hostname.indexOf(':') === -1 ?\n\t        this.hostname :\n\t        '[' + this.hostname + ']');\n\t    if (this.port) {\n\t      host += ':' + this.port;\n\t    }\n\t  }\n\t\n\t  if (this.query &&\n\t      isObject(this.query) &&\n\t      Object.keys(this.query).length) {\n\t    query = querystring.stringify(this.query);\n\t  }\n\t\n\t  var search = this.search || (query && ('?' + query)) || '';\n\t\n\t  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\t\n\t  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n\t  // unless they had them to begin with.\n\t  if (this.slashes ||\n\t      (!protocol || slashedProtocol[protocol]) && host !== false) {\n\t    host = '//' + (host || '');\n\t    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n\t  } else if (!host) {\n\t    host = '';\n\t  }\n\t\n\t  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n\t  if (search && search.charAt(0) !== '?') search = '?' + search;\n\t\n\t  pathname = pathname.replace(/[?#]/g, function(match) {\n\t    return encodeURIComponent(match);\n\t  });\n\t  search = search.replace('#', '%23');\n\t\n\t  return protocol + host + pathname + search + hash;\n\t};\n\t\n\tfunction urlResolve(source, relative) {\n\t  return urlParse(source, false, true).resolve(relative);\n\t}\n\t\n\tUrl.prototype.resolve = function(relative) {\n\t  return this.resolveObject(urlParse(relative, false, true)).format();\n\t};\n\t\n\tfunction urlResolveObject(source, relative) {\n\t  if (!source) return relative;\n\t  return urlParse(source, false, true).resolveObject(relative);\n\t}\n\t\n\tUrl.prototype.resolveObject = function(relative) {\n\t  if (isString(relative)) {\n\t    var rel = new Url();\n\t    rel.parse(relative, false, true);\n\t    relative = rel;\n\t  }\n\t\n\t  var result = new Url();\n\t  Object.keys(this).forEach(function(k) {\n\t    result[k] = this[k];\n\t  }, this);\n\t\n\t  // hash is always overridden, no matter what.\n\t  // even href=\"\" will remove it.\n\t  result.hash = relative.hash;\n\t\n\t  // if the relative url is empty, then there's nothing left to do here.\n\t  if (relative.href === '') {\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  // hrefs like //foo/bar always cut to the protocol.\n\t  if (relative.slashes && !relative.protocol) {\n\t    // take everything except the protocol from relative\n\t    Object.keys(relative).forEach(function(k) {\n\t      if (k !== 'protocol')\n\t        result[k] = relative[k];\n\t    });\n\t\n\t    //urlParse appends trailing / to urls like http://www.example.com\n\t    if (slashedProtocol[result.protocol] &&\n\t        result.hostname && !result.pathname) {\n\t      result.path = result.pathname = '/';\n\t    }\n\t\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  if (relative.protocol && relative.protocol !== result.protocol) {\n\t    // if it's a known url protocol, then changing\n\t    // the protocol does weird things\n\t    // first, if it's not file:, then we MUST have a host,\n\t    // and if there was a path\n\t    // to begin with, then we MUST have a path.\n\t    // if it is file:, then the host is dropped,\n\t    // because that's known to be hostless.\n\t    // anything else is assumed to be absolute.\n\t    if (!slashedProtocol[relative.protocol]) {\n\t      Object.keys(relative).forEach(function(k) {\n\t        result[k] = relative[k];\n\t      });\n\t      result.href = result.format();\n\t      return result;\n\t    }\n\t\n\t    result.protocol = relative.protocol;\n\t    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n\t      var relPath = (relative.pathname || '').split('/');\n\t      while (relPath.length && !(relative.host = relPath.shift()));\n\t      if (!relative.host) relative.host = '';\n\t      if (!relative.hostname) relative.hostname = '';\n\t      if (relPath[0] !== '') relPath.unshift('');\n\t      if (relPath.length < 2) relPath.unshift('');\n\t      result.pathname = relPath.join('/');\n\t    } else {\n\t      result.pathname = relative.pathname;\n\t    }\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    result.host = relative.host || '';\n\t    result.auth = relative.auth;\n\t    result.hostname = relative.hostname || relative.host;\n\t    result.port = relative.port;\n\t    // to support http.request\n\t    if (result.pathname || result.search) {\n\t      var p = result.pathname || '';\n\t      var s = result.search || '';\n\t      result.path = p + s;\n\t    }\n\t    result.slashes = result.slashes || relative.slashes;\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n\t      isRelAbs = (\n\t          relative.host ||\n\t          relative.pathname && relative.pathname.charAt(0) === '/'\n\t      ),\n\t      mustEndAbs = (isRelAbs || isSourceAbs ||\n\t                    (result.host && relative.pathname)),\n\t      removeAllDots = mustEndAbs,\n\t      srcPath = result.pathname && result.pathname.split('/') || [],\n\t      relPath = relative.pathname && relative.pathname.split('/') || [],\n\t      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\t\n\t  // if the url is a non-slashed url, then relative\n\t  // links like ../.. should be able\n\t  // to crawl up to the hostname, as well.  This is strange.\n\t  // result.protocol has already been set by now.\n\t  // Later on, put the first path part into the host field.\n\t  if (psychotic) {\n\t    result.hostname = '';\n\t    result.port = null;\n\t    if (result.host) {\n\t      if (srcPath[0] === '') srcPath[0] = result.host;\n\t      else srcPath.unshift(result.host);\n\t    }\n\t    result.host = '';\n\t    if (relative.protocol) {\n\t      relative.hostname = null;\n\t      relative.port = null;\n\t      if (relative.host) {\n\t        if (relPath[0] === '') relPath[0] = relative.host;\n\t        else relPath.unshift(relative.host);\n\t      }\n\t      relative.host = null;\n\t    }\n\t    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n\t  }\n\t\n\t  if (isRelAbs) {\n\t    // it's absolute.\n\t    result.host = (relative.host || relative.host === '') ?\n\t                  relative.host : result.host;\n\t    result.hostname = (relative.hostname || relative.hostname === '') ?\n\t                      relative.hostname : result.hostname;\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    srcPath = relPath;\n\t    // fall through to the dot-handling below.\n\t  } else if (relPath.length) {\n\t    // it's relative\n\t    // throw away the existing file, and take the new path instead.\n\t    if (!srcPath) srcPath = [];\n\t    srcPath.pop();\n\t    srcPath = srcPath.concat(relPath);\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t  } else if (!isNullOrUndefined(relative.search)) {\n\t    // just pull out the search.\n\t    // like href='?foo'.\n\t    // Put this after the other two cases because it simplifies the booleans\n\t    if (psychotic) {\n\t      result.hostname = result.host = srcPath.shift();\n\t      //occationaly the auth can get stuck only in host\n\t      //this especialy happens in cases like\n\t      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\t      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n\t                       result.host.split('@') : false;\n\t      if (authInHost) {\n\t        result.auth = authInHost.shift();\n\t        result.host = result.hostname = authInHost.shift();\n\t      }\n\t    }\n\t    result.search = relative.search;\n\t    result.query = relative.query;\n\t    //to support http.request\n\t    if (!isNull(result.pathname) || !isNull(result.search)) {\n\t      result.path = (result.pathname ? result.pathname : '') +\n\t                    (result.search ? result.search : '');\n\t    }\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  if (!srcPath.length) {\n\t    // no path at all.  easy.\n\t    // we've already handled the other stuff above.\n\t    result.pathname = null;\n\t    //to support http.request\n\t    if (result.search) {\n\t      result.path = '/' + result.search;\n\t    } else {\n\t      result.path = null;\n\t    }\n\t    result.href = result.format();\n\t    return result;\n\t  }\n\t\n\t  // if a url ENDs in . or .., then it must get a trailing slash.\n\t  // however, if it ends in anything else non-slashy,\n\t  // then it must NOT get a trailing slash.\n\t  var last = srcPath.slice(-1)[0];\n\t  var hasTrailingSlash = (\n\t      (result.host || relative.host) && (last === '.' || last === '..') ||\n\t      last === '');\n\t\n\t  // strip single dots, resolve double dots to parent dir\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = srcPath.length; i >= 0; i--) {\n\t    last = srcPath[i];\n\t    if (last == '.') {\n\t      srcPath.splice(i, 1);\n\t    } else if (last === '..') {\n\t      srcPath.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      srcPath.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (!mustEndAbs && !removeAllDots) {\n\t    for (; up--; up) {\n\t      srcPath.unshift('..');\n\t    }\n\t  }\n\t\n\t  if (mustEndAbs && srcPath[0] !== '' &&\n\t      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n\t    srcPath.unshift('');\n\t  }\n\t\n\t  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n\t    srcPath.push('');\n\t  }\n\t\n\t  var isAbsolute = srcPath[0] === '' ||\n\t      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\t\n\t  // put the host back\n\t  if (psychotic) {\n\t    result.hostname = result.host = isAbsolute ? '' :\n\t                                    srcPath.length ? srcPath.shift() : '';\n\t    //occationaly the auth can get stuck only in host\n\t    //this especialy happens in cases like\n\t    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\t    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n\t                     result.host.split('@') : false;\n\t    if (authInHost) {\n\t      result.auth = authInHost.shift();\n\t      result.host = result.hostname = authInHost.shift();\n\t    }\n\t  }\n\t\n\t  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\t\n\t  if (mustEndAbs && !isAbsolute) {\n\t    srcPath.unshift('');\n\t  }\n\t\n\t  if (!srcPath.length) {\n\t    result.pathname = null;\n\t    result.path = null;\n\t  } else {\n\t    result.pathname = srcPath.join('/');\n\t  }\n\t\n\t  //to support request.http\n\t  if (!isNull(result.pathname) || !isNull(result.search)) {\n\t    result.path = (result.pathname ? result.pathname : '') +\n\t                  (result.search ? result.search : '');\n\t  }\n\t  result.auth = relative.auth || result.auth;\n\t  result.slashes = result.slashes || relative.slashes;\n\t  result.href = result.format();\n\t  return result;\n\t};\n\t\n\tUrl.prototype.parseHost = function() {\n\t  var host = this.host;\n\t  var port = portPattern.exec(host);\n\t  if (port) {\n\t    port = port[0];\n\t    if (port !== ':') {\n\t      this.port = port.substr(1);\n\t    }\n\t    host = host.substr(0, host.length - port.length);\n\t  }\n\t  if (host) this.hostname = host;\n\t};\n\t\n\tfunction isString(arg) {\n\t  return typeof arg === \"string\";\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\tfunction isNullOrUndefined(arg) {\n\t  return  arg == null;\n\t}\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */\n\t;(function(root) {\n\t\n\t\t/** Detect free variables */\n\t\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t\t!exports.nodeType && exports;\n\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\t!module.nodeType && module;\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (\n\t\t\tfreeGlobal.global === freeGlobal ||\n\t\t\tfreeGlobal.window === freeGlobal ||\n\t\t\tfreeGlobal.self === freeGlobal\n\t\t) {\n\t\t\troot = freeGlobal;\n\t\t}\n\t\n\t\t/**\n\t\t * The `punycode` object.\n\t\t * @name punycode\n\t\t * @type Object\n\t\t */\n\t\tvar punycode,\n\t\n\t\t/** Highest positive signed 32-bit float value */\n\t\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\t\n\t\t/** Bootstring parameters */\n\t\tbase = 36,\n\t\ttMin = 1,\n\t\ttMax = 26,\n\t\tskew = 38,\n\t\tdamp = 700,\n\t\tinitialBias = 72,\n\t\tinitialN = 128, // 0x80\n\t\tdelimiter = '-', // '\\x2D'\n\t\n\t\t/** Regular expressions */\n\t\tregexPunycode = /^xn--/,\n\t\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\t\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\t\n\t\t/** Error messages */\n\t\terrors = {\n\t\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t\t'invalid-input': 'Invalid input'\n\t\t},\n\t\n\t\t/** Convenience shortcuts */\n\t\tbaseMinusTMin = base - tMin,\n\t\tfloor = Math.floor,\n\t\tstringFromCharCode = String.fromCharCode,\n\t\n\t\t/** Temporary variable */\n\t\tkey;\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\t/**\n\t\t * A generic error utility function.\n\t\t * @private\n\t\t * @param {String} type The error type.\n\t\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t\t */\n\t\tfunction error(type) {\n\t\t\tthrow RangeError(errors[type]);\n\t\t}\n\t\n\t\t/**\n\t\t * A generic `Array#map` utility function.\n\t\t * @private\n\t\t * @param {Array} array The array to iterate over.\n\t\t * @param {Function} callback The function that gets called for every array\n\t\t * item.\n\t\t * @returns {Array} A new array of values returned by the callback function.\n\t\t */\n\t\tfunction map(array, fn) {\n\t\t\tvar length = array.length;\n\t\t\tvar result = [];\n\t\t\twhile (length--) {\n\t\t\t\tresult[length] = fn(array[length]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\n\t\t/**\n\t\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t\t * addresses.\n\t\t * @private\n\t\t * @param {String} domain The domain name or email address.\n\t\t * @param {Function} callback The function that gets called for every\n\t\t * character.\n\t\t * @returns {Array} A new string of characters returned by the callback\n\t\t * function.\n\t\t */\n\t\tfunction mapDomain(string, fn) {\n\t\t\tvar parts = string.split('@');\n\t\t\tvar result = '';\n\t\t\tif (parts.length > 1) {\n\t\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\t\tresult = parts[0] + '@';\n\t\t\t\tstring = parts[1];\n\t\t\t}\n\t\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\t\tvar labels = string.split('.');\n\t\t\tvar encoded = map(labels, fn).join('.');\n\t\t\treturn result + encoded;\n\t\t}\n\t\n\t\t/**\n\t\t * Creates an array containing the numeric code points of each Unicode\n\t\t * character in the string. While JavaScript uses UCS-2 internally,\n\t\t * this function will convert a pair of surrogate halves (each of which\n\t\t * UCS-2 exposes as separate characters) into a single code point,\n\t\t * matching UTF-16.\n\t\t * @see `punycode.ucs2.encode`\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode.ucs2\n\t\t * @name decode\n\t\t * @param {String} string The Unicode input string (UCS-2).\n\t\t * @returns {Array} The new array of code points.\n\t\t */\n\t\tfunction ucs2decode(string) {\n\t\t\tvar output = [],\n\t\t\t    counter = 0,\n\t\t\t    length = string.length,\n\t\t\t    value,\n\t\t\t    extra;\n\t\t\twhile (counter < length) {\n\t\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\t\toutput.push(value);\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\t/**\n\t\t * Creates a string based on an array of numeric code points.\n\t\t * @see `punycode.ucs2.decode`\n\t\t * @memberOf punycode.ucs2\n\t\t * @name encode\n\t\t * @param {Array} codePoints The array of numeric code points.\n\t\t * @returns {String} The new Unicode string (UCS-2).\n\t\t */\n\t\tfunction ucs2encode(array) {\n\t\t\treturn map(array, function(value) {\n\t\t\t\tvar output = '';\n\t\t\t\tif (value > 0xFFFF) {\n\t\t\t\t\tvalue -= 0x10000;\n\t\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t\t}\n\t\t\t\toutput += stringFromCharCode(value);\n\t\t\t\treturn output;\n\t\t\t}).join('');\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a basic code point into a digit/integer.\n\t\t * @see `digitToBasic()`\n\t\t * @private\n\t\t * @param {Number} codePoint The basic numeric code point value.\n\t\t * @returns {Number} The numeric value of a basic code point (for use in\n\t\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t\t * the code point does not represent a value.\n\t\t */\n\t\tfunction basicToDigit(codePoint) {\n\t\t\tif (codePoint - 48 < 10) {\n\t\t\t\treturn codePoint - 22;\n\t\t\t}\n\t\t\tif (codePoint - 65 < 26) {\n\t\t\t\treturn codePoint - 65;\n\t\t\t}\n\t\t\tif (codePoint - 97 < 26) {\n\t\t\t\treturn codePoint - 97;\n\t\t\t}\n\t\t\treturn base;\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a digit/integer into a basic code point.\n\t\t * @see `basicToDigit()`\n\t\t * @private\n\t\t * @param {Number} digit The numeric value of a basic code point.\n\t\t * @returns {Number} The basic code point whose value (when used for\n\t\t * representing integers) is `digit`, which needs to be in the range\n\t\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t\t * used; else, the lowercase form is used. The behavior is undefined\n\t\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t\t */\n\t\tfunction digitToBasic(digit, flag) {\n\t\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t\t// 26..35 map to ASCII 0..9\n\t\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t\t}\n\t\n\t\t/**\n\t\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t\t * @private\n\t\t */\n\t\tfunction adapt(delta, numPoints, firstTime) {\n\t\t\tvar k = 0;\n\t\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\t\tdelta += floor(delta / numPoints);\n\t\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t\t}\n\t\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t\t * symbols.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t\t * @returns {String} The resulting string of Unicode symbols.\n\t\t */\n\t\tfunction decode(input) {\n\t\t\t// Don't use UCS-2\n\t\t\tvar output = [],\n\t\t\t    inputLength = input.length,\n\t\t\t    out,\n\t\t\t    i = 0,\n\t\t\t    n = initialN,\n\t\t\t    bias = initialBias,\n\t\t\t    basic,\n\t\t\t    j,\n\t\t\t    index,\n\t\t\t    oldi,\n\t\t\t    w,\n\t\t\t    k,\n\t\t\t    digit,\n\t\t\t    t,\n\t\t\t    /** Cached calculation results */\n\t\t\t    baseMinusT;\n\t\n\t\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t\t// the first basic code points to the output.\n\t\n\t\t\tbasic = input.lastIndexOf(delimiter);\n\t\t\tif (basic < 0) {\n\t\t\t\tbasic = 0;\n\t\t\t}\n\t\n\t\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t\t// if it's not a basic code point\n\t\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\t\terror('not-basic');\n\t\t\t\t}\n\t\t\t\toutput.push(input.charCodeAt(j));\n\t\t\t}\n\t\n\t\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t\t// points were copied; start at the beginning otherwise.\n\t\n\t\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\t\n\t\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t\t// value at the end to obtain `delta`.\n\t\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\t\n\t\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\t\terror('invalid-input');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\t\n\t\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\ti += digit * w;\n\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\n\t\t\t\t\tif (digit < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tw *= baseMinusT;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tout = output.length + 1;\n\t\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\t\n\t\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\t\n\t\t\t\tn += floor(i / out);\n\t\t\t\ti %= out;\n\t\n\t\t\t\t// Insert `n` at position `i` of the output\n\t\t\t\toutput.splice(i++, 0, n);\n\t\n\t\t\t}\n\t\n\t\t\treturn ucs2encode(output);\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t\t * Punycode string of ASCII-only symbols.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The string of Unicode symbols.\n\t\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t\t */\n\t\tfunction encode(input) {\n\t\t\tvar n,\n\t\t\t    delta,\n\t\t\t    handledCPCount,\n\t\t\t    basicLength,\n\t\t\t    bias,\n\t\t\t    j,\n\t\t\t    m,\n\t\t\t    q,\n\t\t\t    k,\n\t\t\t    t,\n\t\t\t    currentValue,\n\t\t\t    output = [],\n\t\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t\t    inputLength,\n\t\t\t    /** Cached calculation results */\n\t\t\t    handledCPCountPlusOne,\n\t\t\t    baseMinusT,\n\t\t\t    qMinusT;\n\t\n\t\t\t// Convert the input in UCS-2 to Unicode\n\t\t\tinput = ucs2decode(input);\n\t\n\t\t\t// Cache the length\n\t\t\tinputLength = input.length;\n\t\n\t\t\t// Initialize the state\n\t\t\tn = initialN;\n\t\t\tdelta = 0;\n\t\t\tbias = initialBias;\n\t\n\t\t\t// Handle the basic code points\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue < 0x80) {\n\t\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\thandledCPCount = basicLength = output.length;\n\t\n\t\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t\t// `basicLength` is the number of basic code points.\n\t\n\t\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\t\tif (basicLength) {\n\t\t\t\toutput.push(delimiter);\n\t\t\t}\n\t\n\t\t\t// Main encoding loop:\n\t\t\twhile (handledCPCount < inputLength) {\n\t\n\t\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t\t// larger one:\n\t\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\t\tcurrentValue = input[j];\n\t\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\t\tm = currentValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t\t// but guard against overflow\n\t\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\t\n\t\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\t\tn = m;\n\t\n\t\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\t\tcurrentValue = input[j];\n\t\n\t\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\t\terror('overflow');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\t\tdelta = 0;\n\t\t\t\t\t\t++handledCPCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t++delta;\n\t\t\t\t++n;\n\t\n\t\t\t}\n\t\t\treturn output.join('');\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a Punycode string representing a domain name or an email address\n\t\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t\t * it doesn't matter if you call it on a string that has already been\n\t\t * converted to Unicode.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The Punycoded domain name or email address to\n\t\t * convert to Unicode.\n\t\t * @returns {String} The Unicode representation of the given Punycode\n\t\t * string.\n\t\t */\n\t\tfunction toUnicode(input) {\n\t\t\treturn mapDomain(input, function(string) {\n\t\t\t\treturn regexPunycode.test(string)\n\t\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t\t: string;\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t\t * Converts a Unicode string representing a domain name or an email address to\n\t\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t\t * ASCII.\n\t\t * @memberOf punycode\n\t\t * @param {String} input The domain name or email address to convert, as a\n\t\t * Unicode string.\n\t\t * @returns {String} The Punycode representation of the given domain name or\n\t\t * email address.\n\t\t */\n\t\tfunction toASCII(input) {\n\t\t\treturn mapDomain(input, function(string) {\n\t\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t\t: string;\n\t\t\t});\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\t/** Define the public API */\n\t\tpunycode = {\n\t\t\t/**\n\t\t\t * A string representing the current Punycode.js version number.\n\t\t\t * @memberOf punycode\n\t\t\t * @type String\n\t\t\t */\n\t\t\t'version': '1.3.2',\n\t\t\t/**\n\t\t\t * An object of methods to convert from JavaScript's internal character\n\t\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t\t * @memberOf punycode\n\t\t\t * @type Object\n\t\t\t */\n\t\t\t'ucs2': {\n\t\t\t\t'decode': ucs2decode,\n\t\t\t\t'encode': ucs2encode\n\t\t\t},\n\t\t\t'decode': decode,\n\t\t\t'encode': encode,\n\t\t\t'toASCII': toASCII,\n\t\t\t'toUnicode': toUnicode\n\t\t};\n\t\n\t\t/** Expose `punycode` */\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (\n\t\t\ttrue\n\t\t) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn punycode;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t} else if (freeExports && freeModule) {\n\t\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = punycode;\n\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\tfor (key in punycode) {\n\t\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // in Rhino or a web browser\n\t\t\troot.punycode = punycode;\n\t\t}\n\t\n\t}(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50)(module), (function() { return this; }())))\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.decode = exports.parse = __webpack_require__(52);\n\texports.encode = exports.stringify = __webpack_require__(53);\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t'use strict';\n\t\n\t// If obj.hasOwnProperty has been overridden, then calling\n\t// obj.hasOwnProperty(prop) will break.\n\t// See: https://github.com/joyent/node/issues/1707\n\tfunction hasOwnProperty(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\t\n\tmodule.exports = function(qs, sep, eq, options) {\n\t  sep = sep || '&';\n\t  eq = eq || '=';\n\t  var obj = {};\n\t\n\t  if (typeof qs !== 'string' || qs.length === 0) {\n\t    return obj;\n\t  }\n\t\n\t  var regexp = /\\+/g;\n\t  qs = qs.split(sep);\n\t\n\t  var maxKeys = 1000;\n\t  if (options && typeof options.maxKeys === 'number') {\n\t    maxKeys = options.maxKeys;\n\t  }\n\t\n\t  var len = qs.length;\n\t  // maxKeys <= 0 means that we should not limit keys count\n\t  if (maxKeys > 0 && len > maxKeys) {\n\t    len = maxKeys;\n\t  }\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    var x = qs[i].replace(regexp, '%20'),\n\t        idx = x.indexOf(eq),\n\t        kstr, vstr, k, v;\n\t\n\t    if (idx >= 0) {\n\t      kstr = x.substr(0, idx);\n\t      vstr = x.substr(idx + 1);\n\t    } else {\n\t      kstr = x;\n\t      vstr = '';\n\t    }\n\t\n\t    k = decodeURIComponent(kstr);\n\t    v = decodeURIComponent(vstr);\n\t\n\t    if (!hasOwnProperty(obj, k)) {\n\t      obj[k] = v;\n\t    } else if (Array.isArray(obj[k])) {\n\t      obj[k].push(v);\n\t    } else {\n\t      obj[k] = [obj[k], v];\n\t    }\n\t  }\n\t\n\t  return obj;\n\t};\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t'use strict';\n\t\n\tvar stringifyPrimitive = function(v) {\n\t  switch (typeof v) {\n\t    case 'string':\n\t      return v;\n\t\n\t    case 'boolean':\n\t      return v ? 'true' : 'false';\n\t\n\t    case 'number':\n\t      return isFinite(v) ? v : '';\n\t\n\t    default:\n\t      return '';\n\t  }\n\t};\n\t\n\tmodule.exports = function(obj, sep, eq, name) {\n\t  sep = sep || '&';\n\t  eq = eq || '=';\n\t  if (obj === null) {\n\t    obj = undefined;\n\t  }\n\t\n\t  if (typeof obj === 'object') {\n\t    return Object.keys(obj).map(function(k) {\n\t      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\t      if (Array.isArray(obj[k])) {\n\t        return obj[k].map(function(v) {\n\t          return ks + encodeURIComponent(stringifyPrimitive(v));\n\t        }).join(sep);\n\t      } else {\n\t        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n\t      }\n\t    }).join(sep);\n\t\n\t  }\n\t\n\t  if (!name) return '';\n\t  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n\t         encodeURIComponent(stringifyPrimitive(obj));\n\t};\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar helpers = __webpack_require__(55);\n\t\n\t/** @type ValidatorResult */\n\tvar ValidatorResult = helpers.ValidatorResult;\n\t/** @type SchemaError */\n\tvar SchemaError = helpers.SchemaError;\n\t\n\tvar attribute = {};\n\t\n\tattribute.ignoreProperties = {\n\t  // informative properties\n\t  'id': true,\n\t  'default': true,\n\t  'description': true,\n\t  'title': true,\n\t  // arguments to other properties\n\t  'exclusiveMinimum': true,\n\t  'exclusiveMaximum': true,\n\t  'additionalItems': true,\n\t  // special-handled properties\n\t  '$schema': true,\n\t  '$ref': true,\n\t  'extends': true\n\t};\n\t\n\t/**\n\t * @name validators\n\t */\n\tvar validators = attribute.validators = {};\n\t\n\t/**\n\t * Validates whether the instance if of a certain type\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {ValidatorResult|null}\n\t */\n\tvalidators.type = function validateType (instance, schema, options, ctx) {\n\t  // Ignore undefined instances\n\t  if (instance === undefined) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var types = (schema.type instanceof Array) ? schema.type : [schema.type];\n\t  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n\t    var list = types.map(function (v) {\n\t      return v.id && ('<' + v.id + '>') || (v+'');\n\t    });\n\t    result.addError({\n\t      name: 'type',\n\t      argument: list,\n\t      message: \"is not of a type(s) \" + list,\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\tfunction testSchema(instance, options, ctx, schema){\n\t  return this.validateSchema(instance, schema, options, ctx).valid;\n\t}\n\t\n\t/**\n\t * Validates whether the instance matches some of the given schemas\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {ValidatorResult|null}\n\t */\n\tvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n\t  // Ignore undefined instances\n\t  if (instance === undefined) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!(schema.anyOf instanceof Array)){\n\t    throw new SchemaError(\"anyOf must be an array\");\n\t  }\n\t  if (!schema.anyOf.some(testSchema.bind(this, instance, options, ctx))) {\n\t    var list = schema.anyOf.map(function (v, i) {\n\t      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n\t    });\n\t    result.addError({\n\t      name: 'anyOf',\n\t      argument: list,\n\t      message: \"is not any of \" + list.join(','),\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance matches every given schema\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {String|null}\n\t */\n\tvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n\t  // Ignore undefined instances\n\t  if (instance === undefined) {\n\t    return null;\n\t  }\n\t  if (!(schema.allOf instanceof Array)){\n\t    throw new SchemaError(\"allOf must be an array\");\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var self = this;\n\t  schema.allOf.forEach(function(v, i){\n\t    var valid = self.validateSchema(instance, v, options, ctx);\n\t    if(!valid.valid){\n\t      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n\t      result.addError({\n\t        name: 'allOf',\n\t        argument: { id: msg, length: valid.errors.length, valid: valid },\n\t        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n\t      });\n\t      result.importErrors(valid);\n\t    }\n\t  });\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance matches exactly one of the given schemas\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {String|null}\n\t */\n\tvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n\t  // Ignore undefined instances\n\t  if (instance === undefined) {\n\t    return null;\n\t  }\n\t  if (!(schema.oneOf instanceof Array)){\n\t    throw new SchemaError(\"oneOf must be an array\");\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var count = schema.oneOf.filter(testSchema.bind(this, instance, options, ctx)).length;\n\t  var list = schema.oneOf.map(function (v, i) {\n\t    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n\t  });\n\t  if (count!==1) {\n\t    result.addError({\n\t      name: 'oneOf',\n\t      argument: list,\n\t      message: \"is not exactly one from \" + list.join(','),\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates properties\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {String|null|ValidatorResult}\n\t */\n\tvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n\t  if(instance === undefined || !(instance instanceof Object)) return;\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var properties = schema.properties || {};\n\t  for (var property in properties) {\n\t    var prop = (instance || undefined) && instance[property];\n\t    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n\t    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n\t    result.importErrors(res);\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Test a specific property within in instance against the additionalProperties schema attribute\n\t * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n\t * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n\t * @private\n\t * @return {boolean}\n\t */\n\tfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n\t  if (schema.properties && schema.properties[property] !== undefined) {\n\t    return;\n\t  }\n\t  if (schema.additionalProperties === false) {\n\t    result.addError({\n\t      name: 'additionalProperties',\n\t      argument: property,\n\t      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\",\n\t    });\n\t  } else {\n\t    var additionalProperties = schema.additionalProperties || {};\n\t    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n\t    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n\t    result.importErrors(res);\n\t  }\n\t}\n\t\n\t/**\n\t * Validates patternProperties\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {String|null|ValidatorResult}\n\t */\n\tvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n\t  if(instance === undefined) return;\n\t  if(!this.types.object(instance)) return;\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var patternProperties = schema.patternProperties || {};\n\t\n\t  for (var property in instance) {\n\t    var test = true;\n\t    for (var pattern in patternProperties) {\n\t      var expr = new RegExp(pattern);\n\t      if (!expr.test(property)) {\n\t        continue;\n\t      }\n\t      test = false;\n\t      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n\t      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n\t      result.importErrors(res);\n\t    }\n\t    if (test) {\n\t      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates additionalProperties\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {String|null|ValidatorResult}\n\t */\n\tvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n\t  if(instance === undefined) return;\n\t  if(!this.types.object(instance)) return;\n\t  // if patternProperties is defined then we'll test when that one is called instead\n\t  if (schema.patternProperties) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  for (var property in instance) {\n\t    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n\t  if (!instance || typeof instance !== 'object') {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var keys = Object.keys(instance);\n\t  if (!(keys.length >= schema.minProperties)) {\n\t    result.addError({\n\t      name: 'minProperties',\n\t      argument: schema.minProperties,\n\t      message: \"does not meet minimum property length of \" + schema.minProperties,\n\t    })\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n\t  if (!instance || typeof instance !== 'object') {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var keys = Object.keys(instance);\n\t  if (!(keys.length <= schema.maxProperties)) {\n\t    result.addError({\n\t      name: 'maxProperties',\n\t      argument: schema.maxProperties,\n\t      message: \"does not meet maximum property length of \" + schema.maxProperties,\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates items when instance is an array\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {String|null|ValidatorResult}\n\t */\n\tvalidators.items = function validateItems (instance, schema, options, ctx) {\n\t  if (!(instance instanceof Array)) {\n\t    return null;\n\t  }\n\t  var self = this;\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (instance === undefined || !schema.items) {\n\t    return result;\n\t  }\n\t  instance.every(function (value, i) {\n\t    var items = (schema.items instanceof Array) ? (schema.items[i] || schema.additionalItems) : schema.items;\n\t    if (items === undefined) {\n\t      return true;\n\t    }\n\t    if (items === false) {\n\t      result.addError({\n\t        name: 'items',\n\t        message: \"additionalItems not permitted\",\n\t      });\n\t      return false;\n\t    }\n\t    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n\t    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n\t    result.importErrors(res);\n\t    return true;\n\t  });\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n\t  if (typeof instance !== 'number') {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var valid = true;\n\t  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n\t    valid = instance > schema.minimum;\n\t  } else {\n\t    valid = instance >= schema.minimum;\n\t  }\n\t  if (!valid) {\n\t    result.addError({\n\t      name: 'minimum',\n\t      argument: schema.minimum,\n\t      message: \"must have a minimum value of \" + schema.minimum,\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n\t  if (typeof instance !== 'number') {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var valid;\n\t  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n\t    valid = instance < schema.maximum;\n\t  } else {\n\t    valid = instance <= schema.maximum;\n\t  }\n\t  if (!valid) {\n\t    result.addError({\n\t      name: 'maximum',\n\t      argument: schema.maximum,\n\t      message: \"must have a maximum value of \" + schema.maximum,\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates divisibleBy when the type of the instance value is a number.\n\t * Of course, this is susceptible to floating point error since it compares the floating points\n\t * and not the JSON byte sequences to arbitrary precision.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n\t  if (typeof instance !== 'number') {\n\t    return null;\n\t  }\n\t\n\t  if (schema.divisibleBy == 0) {\n\t    throw new SchemaError(\"divisibleBy cannot be zero\");\n\t  }\n\t\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (instance / schema.divisibleBy % 1) {\n\t    result.addError({\n\t      name: 'divisibleBy',\n\t      argument: schema.divisibleBy,\n\t      message: \"is not divisible by (multiple of) \" + JSON.stringify(schema.divisibleBy),\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates divisibleBy when the type of the instance value is a number.\n\t * Of course, this is susceptible to floating point error since it compares the floating points\n\t * and not the JSON byte sequences to arbitrary precision.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n\t  if (typeof instance !== 'number') {\n\t    return null;\n\t  }\n\t\n\t  if (schema.multipleOf == 0) {\n\t    throw new SchemaError(\"multipleOf cannot be zero\");\n\t  }\n\t\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (instance / schema.multipleOf % 1) {\n\t    result.addError({\n\t      name: 'multipleOf',\n\t      argument:  schema.multipleOf,\n\t      message: \"is not a multiple of (divisible by) \" + JSON.stringify(schema.multipleOf),\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance value is present.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.required = function validateRequired (instance, schema, options, ctx) {\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (instance === undefined && schema.required === true) {\n\t    result.addError({\n\t      name: 'required',\n\t      message: \"is required\"\n\t    });\n\t  } else if (instance && typeof instance==='object' && Array.isArray(schema.required)) {\n\t    schema.required.forEach(function(n){\n\t      if(instance[n]===undefined){\n\t        result.addError({\n\t          name: 'required',\n\t          argument: n,\n\t          message: \"requires property \" + JSON.stringify(n),\n\t        });\n\t      }\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance value matches the regular expression, when the instance value is a string.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n\t  if (typeof instance !== 'string') {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!instance.match(schema.pattern)) {\n\t    result.addError({\n\t      name: 'pattern',\n\t      argument: schema.pattern,\n\t      message: \"does not match pattern \" + JSON.stringify(schema.pattern),\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance value is of a certain defined format or a custom\n\t * format.\n\t * The following formats are supported for string types:\n\t *   - date-time\n\t *   - date\n\t *   - time\n\t *   - ip-address\n\t *   - ipv6\n\t *   - uri\n\t *   - color\n\t *   - host-name\n\t *   - alpha\n\t *   - alpha-numeric\n\t *   - utc-millisec\n\t * @param instance\n\t * @param schema\n\t * @param [options]\n\t * @param [ctx]\n\t * @return {String|null}\n\t */\n\tvalidators.format = function validateFormat (instance, schema, options, ctx) {\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n\t    result.addError({\n\t      name: 'format',\n\t      argument: schema.format,\n\t      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n\t  if (!(typeof instance === 'string')) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!(instance.length >= schema.minLength)) {\n\t    result.addError({\n\t      name: 'minLength',\n\t      argument: schema.minLength,\n\t      message: \"does not meet minimum length of \" + schema.minLength,\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n\t  if (!(typeof instance === 'string')) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!(instance.length <= schema.maxLength)) {\n\t    result.addError({\n\t      name: 'maxLength',\n\t      argument: schema.maxLength,\n\t      message: \"does not meet maximum length of \" + schema.maxLength,\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n\t  if (!(instance instanceof Array)) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!(instance.length >= schema.minItems)) {\n\t    result.addError({\n\t      name: 'minItems',\n\t      argument: schema.minItems,\n\t      message: \"does not meet minimum length of \" + schema.minItems,\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n\t * @param instance\n\t * @param schema\n\t * @return {String|null}\n\t */\n\tvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n\t  if (!(instance instanceof Array)) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!(instance.length <= schema.maxItems)) {\n\t    result.addError({\n\t      name: 'maxItems',\n\t      argument: schema.maxItems,\n\t      message: \"does not meet maximum length of \" + schema.maxItems,\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates that every item in an instance array is unique, when instance is an array\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {String|null|ValidatorResult}\n\t */\n\tvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!(instance instanceof Array)) {\n\t    return result;\n\t  }\n\t  function testArrays (v, i, a) {\n\t    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n\t      return false;\n\t    }\n\t    return true;\n\t  }\n\t  if (!instance.every(testArrays)) {\n\t    result.addError({\n\t      name: 'uniqueItems',\n\t      message: \"contains duplicate item\",\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Deep compares arrays for duplicates\n\t * @param v\n\t * @param i\n\t * @param a\n\t * @private\n\t * @return {boolean}\n\t */\n\tfunction testArrays (v, i, a) {\n\t  var j, len = a.length;\n\t  for (j = i + 1, len; j < len; j++) {\n\t    if (helpers.deepCompareStrict(v, a[j])) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Validates whether there are no duplicates, when the instance is an Array.\n\t * @param instance\n\t * @return {String|null}\n\t */\n\tvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n\t  if (!(instance instanceof Array)) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!instance.every(testArrays)) {\n\t    result.addError({\n\t      name: 'uniqueItems',\n\t      message: \"contains duplicate item\",\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validate for the presence of dependency properties, if the instance is an object.\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {null|ValidatorResult}\n\t */\n\tvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n\t  if (!instance || typeof instance != 'object') {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  for (var property in schema.dependencies) {\n\t    if (instance[property] === undefined) {\n\t      continue;\n\t    }\n\t    var dep = schema.dependencies[property];\n\t    var childContext = ctx.makeChild(dep, property);\n\t    if (typeof dep == 'string') {\n\t      dep = [dep];\n\t    }\n\t    if (dep instanceof Array) {\n\t      dep.forEach(function (prop) {\n\t        if (instance[prop] === undefined) {\n\t          result.addError({\n\t            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n\t            // Can we make these the same? Or should we create different error types?\n\t            name: 'dependencies',\n\t            argument: childContext.propertyPath,\n\t            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n\t          });\n\t        }\n\t      });\n\t    } else {\n\t      var res = this.validateSchema(instance, dep, options, childContext);\n\t      if(result.instance !== res.instance) result.instance = res.instance;\n\t      if (res && res.errors.length) {\n\t        result.addError({\n\t          name: 'dependencies',\n\t          argument: childContext.propertyPath,\n\t          message: \"does not meet dependency required by \" + childContext.propertyPath,\n\t        });\n\t        result.importErrors(res);\n\t      }\n\t    }\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance value is one of the enumerated values.\n\t *\n\t * @param instance\n\t * @param schema\n\t * @return {ValidatorResult|null}\n\t */\n\tvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n\t  if (!(schema['enum'] instanceof Array)) {\n\t    throw new SchemaError(\"enum expects an array\", schema);\n\t  }\n\t  if (instance === undefined) {\n\t    return null;\n\t  }\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n\t    result.addError({\n\t      name: 'enum',\n\t      argument: schema['enum'],\n\t      message: \"is not one of enum values: \" + schema['enum'].join(','),\n\t    });\n\t  }\n\t  return result;\n\t};\n\t\n\t/**\n\t * Validates whether the instance if of a prohibited type.\n\t * @param instance\n\t * @param schema\n\t * @param options\n\t * @param ctx\n\t * @return {null|ValidatorResult}\n\t */\n\tvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n\t  var self = this;\n\t  if(instance===undefined) return null;\n\t  var result = new ValidatorResult(instance, schema, options, ctx);\n\t  var notTypes = schema.not || schema.disallow;\n\t  if(!notTypes) return null;\n\t  if(!(notTypes instanceof Array)) notTypes=[notTypes];\n\t  notTypes.forEach(function (type) {\n\t    if (self.testType(instance, schema, options, ctx, type)) {\n\t      var schemaId = type && type.id && ('<' + type.id + '>') || type;\n\t      result.addError({\n\t        name: 'not',\n\t        argument: schemaId,\n\t        message: \"is of prohibited type \" + schemaId,\n\t      });\n\t    }\n\t  });\n\t  return result;\n\t};\n\t\n\tmodule.exports = attribute;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar uri = __webpack_require__(48);\n\t\n\tvar ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {\n\t  if (propertyPath) {\n\t    this.property = propertyPath;\n\t  }\n\t  if (message) {\n\t    this.message = message;\n\t  }\n\t  if (schema) {\n\t    if (schema.id) {\n\t      this.schema = schema.id;\n\t    } else {\n\t      this.schema = schema;\n\t    }\n\t  }\n\t  if (instance) {\n\t    this.instance = instance;\n\t  }\n\t  this.name = name;\n\t  this.argument = argument;\n\t  this.stack = this.toString();\n\t};\n\t\n\tValidationError.prototype.toString = function toString() {\n\t  return this.property + ' ' + this.message;\n\t};\n\t\n\tvar ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {\n\t  this.instance = instance;\n\t  this.schema = schema;\n\t  this.propertyPath = ctx.propertyPath;\n\t  this.errors = [];\n\t  this.throwError = options && options.throwError;\n\t  this.disableFormat = options && options.disableFormat === true;\n\t};\n\t\n\tValidatorResult.prototype.addError = function addError(detail) {\n\t  var err;\n\t  if (typeof detail == 'string') {\n\t    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);\n\t  } else {\n\t    if (!detail) throw new Error('Missing error detail');\n\t    if (!detail.message) throw new Error('Missing error message');\n\t    if (!detail.name) throw new Error('Missing validator type');\n\t    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);\n\t  }\n\t\n\t  if (this.throwError) {\n\t    throw err;\n\t  }\n\t  this.errors.push(err);\n\t  return err;\n\t};\n\t\n\tValidatorResult.prototype.importErrors = function importErrors(res) {\n\t  if (typeof res == 'string' || (res && res.validatorType)) {\n\t    this.addError(res);\n\t  } else if (res && res.errors) {\n\t    var errs = this.errors;\n\t    res.errors.forEach(function (v) {\n\t      errs.push(v);\n\t    });\n\t  }\n\t};\n\t\n\tValidatorResult.prototype.toString = function toString(res) {\n\t  return this.errors.map(function(v,i){ return i+': '+v.toString()+'\\n'; }).join('');\n\t};\n\t\n\tObject.defineProperty(ValidatorResult.prototype, \"valid\", { get: function() {\n\t  return !this.errors.length;\n\t} });\n\t\n\t/**\n\t * Describes a problem with a Schema which prevents validation of an instance\n\t * @name SchemaError\n\t * @constructor\n\t */\n\tvar SchemaError = exports.SchemaError = function SchemaError (msg, schema) {\n\t  this.message = msg;\n\t  this.schema = schema;\n\t  Error.call(this, msg);\n\t  Error.captureStackTrace(this, SchemaError);\n\t};\n\tSchemaError.prototype = Object.create(Error.prototype,\n\t  { constructor: {value: SchemaError, enumerable: false}\n\t  , name: {value: 'SchemaError', enumerable: false}\n\t  });\n\t\n\tvar SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {\n\t  this.schema = schema;\n\t  this.options = options;\n\t  this.propertyPath = propertyPath;\n\t  this.base = base;\n\t  this.schemas = schemas;\n\t};\n\t\n\tSchemaContext.prototype.resolve = function resolve (target) {\n\t  return uri.resolve(this.base, target);\n\t};\n\t\n\tSchemaContext.prototype.makeChild = function makeChild(schema, propertyName){\n\t  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);\n\t  var base = uri.resolve(this.base, schema.id||'');\n\t  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));\n\t  if(schema.id && !ctx.schemas[base]){\n\t    ctx.schemas[base] = schema;\n\t  }\n\t  return ctx;\n\t}\n\t\n\tvar FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {\n\t  'date-time': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\\.\\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,\n\t  'date': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,\n\t  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,\n\t\n\t  'email': /^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/,\n\t  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,\n\t  'ipv6': /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n\t  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/,\n\t\n\t  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/,\n\t\n\t  // hostname regex from: http://stackoverflow.com/a/1420225/5628\n\t  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n\t  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n\t\n\t  'alpha': /^[a-zA-Z]+$/,\n\t  'alphanumeric': /^[a-zA-Z0-9]+$/,\n\t  'utc-millisec': function (input) {\n\t    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);\n\t  },\n\t  'regex': function (input) {\n\t    var result = true;\n\t    try {\n\t      new RegExp(input);\n\t    } catch (e) {\n\t      result = false;\n\t    }\n\t    return result;\n\t  },\n\t  'style': /\\s*(.+?):\\s*([^;]+);?/g,\n\t  'phone': /^\\+(?:[0-9] ?){6,14}[0-9]$/\n\t};\n\t\n\tFORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;\n\tFORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;\n\tFORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];\n\t\n\texports.isFormat = function isFormat (input, format, validator) {\n\t  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {\n\t    if (FORMAT_REGEXPS[format] instanceof RegExp) {\n\t      return FORMAT_REGEXPS[format].test(input);\n\t    }\n\t    if (typeof FORMAT_REGEXPS[format] === 'function') {\n\t      return FORMAT_REGEXPS[format](input);\n\t    }\n\t  } else if (validator && validator.customFormats &&\n\t      typeof validator.customFormats[format] === 'function') {\n\t    return validator.customFormats[format](input);\n\t  }\n\t  return true;\n\t};\n\t\n\tvar makeSuffix = exports.makeSuffix = function makeSuffix (key) {\n\t  key = key.toString();\n\t  // This function could be capable of outputting valid a ECMAScript string, but the\n\t  // resulting code for testing which form to use would be tens of thousands of characters long\n\t  // That means this will use the name form for some illegal forms\n\t  if (!key.match(/[.\\s\\[\\]]/) && !key.match(/^[\\d]/)) {\n\t    return '.' + key;\n\t  }\n\t  if (key.match(/^\\d+$/)) {\n\t    return '[' + key + ']';\n\t  }\n\t  return '[' + JSON.stringify(key) + ']';\n\t};\n\t\n\texports.deepCompareStrict = function deepCompareStrict (a, b) {\n\t  if (typeof a !== typeof b) {\n\t    return false;\n\t  }\n\t  if (a instanceof Array) {\n\t    if (!(b instanceof Array)) {\n\t      return false;\n\t    }\n\t    if (a.length !== b.length) {\n\t      return false;\n\t    }\n\t    return a.every(function (v, i) {\n\t      return deepCompareStrict(a[i], b[i]);\n\t    });\n\t  }\n\t  if (typeof a === 'object') {\n\t    if (!a || !b) {\n\t      return a === b;\n\t    }\n\t    var aKeys = Object.keys(a);\n\t    var bKeys = Object.keys(b);\n\t    if (aKeys.length !== bKeys.length) {\n\t      return false;\n\t    }\n\t    return aKeys.every(function (v) {\n\t      return deepCompareStrict(a[v], b[v]);\n\t    });\n\t  }\n\t  return a === b;\n\t};\n\t\n\tmodule.exports.deepMerge = function deepMerge (target, src) {\n\t  var array = Array.isArray(src);\n\t  var dst = array && [] || {};\n\t\n\t  if (array) {\n\t    target = target || [];\n\t    dst = dst.concat(target);\n\t    src.forEach(function (e, i) {\n\t      if (typeof e === 'object') {\n\t        dst[i] = deepMerge(target[i], e)\n\t      } else {\n\t        if (target.indexOf(e) === -1) {\n\t          dst.push(e)\n\t        }\n\t      }\n\t    });\n\t  } else {\n\t    if (target && typeof target === 'object') {\n\t      Object.keys(target).forEach(function (key) {\n\t        dst[key] = target[key];\n\t      });\n\t    }\n\t    Object.keys(src).forEach(function (key) {\n\t      if (typeof src[key] !== 'object' || !src[key]) {\n\t        dst[key] = src[key];\n\t      }\n\t      else {\n\t        if (!target[key]) {\n\t          dst[key] = src[key];\n\t        } else {\n\t          dst[key] = deepMerge(target[key], src[key])\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  return dst;\n\t};\n\t\n\t/**\n\t * Validates instance against the provided schema\n\t * Implements URI+JSON Pointer encoding, e.g. \"%7e\"=\"~0\"=>\"~\", \"~1\"=\"%2f\"=>\"/\"\n\t * @param o\n\t * @param s The path to walk o along\n\t * @return any\n\t */\n\texports.objectGetPath = function objectGetPath(o, s) {\n\t  var parts = s.split('/').slice(1);\n\t  var k;\n\t  while (typeof (k=parts.shift()) == 'string') {\n\t    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));\n\t    if (!(n in o)) return;\n\t    o = o[n];\n\t  }\n\t  return o;\n\t};\n\t\n\t/**\n\t * Accept an Array of property names and return a JSON Pointer URI fragment\n\t * @param Array a\n\t * @return {String}\n\t */\n\texports.encodePath = function encodePointer(a){\n\t\t// ~ must be encoded explicitly because hacks\n\t\t// the slash is encoded by encodeURIComponent\n\t\treturn a.map(function(v){ return '/'+encodeURIComponent(v).replace(/~/g,'%7E'); }).join('');\n\t};\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"$schema\": \"http://json-schema.org/draft-04/schema#\",\n\t\t\"title\": \"Case Log Details Schema\",\n\t\t\"type\": \"array\",\n\t\t\"items\": {\n\t\t\t\"title\": \"Section\",\n\t\t\t\"description\": \"Section of form, displayed as a panel\",\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"title\": {\n\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t},\n\t\t\t\t\"subsections\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\"$ref\": \"#/definitions/subsection\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": \"subsections\"\n\t\t},\n\t\t\"definitions\": {\n\t\t\t\"subsection\": {\n\t\t\t\t\"title\": \"Subsection\",\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"title\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"report\": {\n\t\t\t\t\t\t\"$ref\": \"#/definitions/stringBool\"\n\t\t\t\t\t},\n\t\t\t\t\t\"inputs\": {\n\t\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\t\"$ref\": \"#/definitions/input\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\n\t\t\t\t\t\"name\",\n\t\t\t\t\t\"inputs\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"input\": {\n\t\t\t\t\"title\": \"Input\",\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"oneOf\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"$ref\": \"#/definitions/checkbox\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"$ref\": \"#/definitions/text\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"checkbox\": {\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\t\"checkbox\"\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"label\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"$ref\": \"#/definitions/properties\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\n\t\t\t\t\t\"type\",\n\t\t\t\t\t\"label\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"text\": {\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\t\"text\"\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"label\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"placeholder\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"$ref\": \"#/definitions/properties\"\n\t\t\t\t\t},\n\t\t\t\t\t\"report\": {\n\t\t\t\t\t\t\"type\": \"boolean\",\n\t\t\t\t\t\t\"default\": false\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\n\t\t\t\t\t\"type\",\n\t\t\t\t\t\"label\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"properties\": {\n\t\t\t\t\"type\": \"array\",\n\t\t\t\t\"items\": {\n\t\t\t\t\t\"$ref\": \"#/definitions/property\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"property\": {\n\t\t\t\t\"enum\": [\n\t\t\t\t\t\"required\",\n\t\t\t\t\t\"readonly\",\n\t\t\t\t\t\"selected\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"stringBool\": {\n\t\t\t\t\"enum\": [\n\t\t\t\t\t\"true\",\n\t\t\t\t\t\"false\"\n\t\t\t\t],\n\t\t\t\t\"default\": \"false\"\n\t\t\t}\n\t\t}\n\t};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.unlimitTableEvals = unlimitTableEvals;\n\texports.unlimitRestTableEvals = unlimitRestTableEvals;\n\texports.createDateCell = createDateCell;\n\texports.createDateTimeCell = createDateTimeCell;\n\texports.renderDateCell = renderDateCell;\n\texports.renderDateTimeCell = renderDateTimeCell;\n\texports.renderAccountStatus = renderAccountStatus;\n\texports.renderEvaluationStatus = renderEvaluationStatus;\n\texports.renderTrainingLevel = renderTrainingLevel;\n\texports.renderSecondaryTrainingLevel = renderSecondaryTrainingLevel;\n\texports.renderSubjectEvalUrl = renderSubjectEvalUrl;\n\texports.renderEvaluatorEvalUrl = renderEvaluatorEvalUrl;\n\texports.createEditAndDeleteButtons = createEditAndDeleteButtons;\n\texports.getDataAttributes = getDataAttributes;\n\t\n\tvar _constants = __webpack_require__(58);\n\t\n\tvar _utils = __webpack_require__(59);\n\t\n\tvar _moment = __webpack_require__(32);\n\t\n\tvar _moment2 = _interopRequireDefault(_moment);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction unlimitTableEvals() {\n\t\tvar dt = this.DataTable({\n\t\t\tretrieve: true\n\t\t});\n\t\tvar url = dt.ajax.url();\n\t\tdt.ajax.url(url.substring(0, url.lastIndexOf(\"/\"))).load().draw();\n\t}\n\t\n\tfunction unlimitRestTableEvals() {\n\t\tvar dt = this.DataTable({\n\t\t\tretrieve: true\n\t\t});\n\t\tvar url = dt.ajax.url();\n\t\tdt.ajax.url(url.substring(0, url.lastIndexOf(\"?\"))).load().draw();\n\t}\n\t\n\tfunction createDateCell(td, date) {\n\t\tif (date && $(td).text() !== (0, _moment2.default)(date).format(\"ll\")) $(td).attr(\"data-date-value\", (0, _moment2.default)(date).valueOf()).addClass(\"table-date-cell\");\n\t}\n\t\n\tfunction createDateTimeCell(td, date) {\n\t\tif (date && $(td).text() !== (0, _moment2.default)(date).format(\"ll LT\")) $(td).attr(\"data-date-value\", (0, _moment2.default)(date).valueOf()).addClass(\"table-date-time-cell\");\n\t}\n\t\n\tfunction renderDateCell(date, type) {\n\t\tif (type === \"sort\" || type === \"type\") return date ? (0, _moment2.default)(date).valueOf() : \"\";\n\t\n\t\treturn date ? (0, _moment2.default)(date).format(\"MMMM Y\") : \"\";\n\t}\n\t\n\tfunction renderDateTimeCell(date, type) {\n\t\tif (type === \"sort\" || type === \"type\") return date ? (0, _moment2.default)(date).valueOf() : \"\";\n\t\n\t\treturn date ? (0, _moment2.default)(date).calendar() : \"\";\n\t}\n\t\n\tfunction renderAccountStatus(status) {\n\t\tvar labelContext = void 0;\n\t\tswitch (status) {\n\t\t\tcase \"active\":\n\t\t\t\tlabelContext = \"label-success\";\n\t\t\t\tbreak;\n\t\t\tcase \"inactive\":\n\t\t\t\tlabelContext = \"label-danger\";\n\t\t\t\tbreak;\n\t\t\tcase \"pending\":\n\t\t\t\tlabelContext = \"label-warning\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlabelContext = \"label-default\";\n\t\t\t\tbreak;\n\t\t}\n\t\treturn '<span class=\"label ' + labelContext + '\">' + (0, _utils.ucfirst)(status) + '</span>';\n\t}\n\t\n\tfunction renderEvaluationStatus(status) {\n\t\tvar labelContext = void 0;\n\t\tswitch (status) {\n\t\t\tcase \"complete\":\n\t\t\t\tlabelContext = \"label-success\";\n\t\t\t\tbreak;\n\t\t\tcase \"disabled\":\n\t\t\tcase \"canceled by admin\":\n\t\t\tcase \"canceled by faculty\":\n\t\t\tcase \"canceled by resident\":\n\t\t\tcase \"canceled by fellow\":\n\t\t\tcase \"canceled by staff\":\n\t\t\t\tlabelContext = \"label-danger\";\n\t\t\t\tbreak;\n\t\t\tcase \"pending\":\n\t\t\t\tlabelContext = \"label-warning\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlabelContext = \"label-default\";\n\t\t\t\tbreak;\n\t\t}\n\t\treturn '<span class=\"label ' + labelContext + '\">' + (0, _utils.ucfirst)(status) + '</span>';\n\t}\n\t\n\tfunction renderTrainingLevel(trainingLevel) {\n\t\tif (trainingLevel) {\n\t\t\tif (trainingLevel.indexOf(\"ca-\") > -1) return trainingLevel.toUpperCase();else return (0, _utils.ucfirst)(trainingLevel);\n\t\t}\n\t\n\t\treturn \"\";\n\t}\n\t\n\tfunction renderSecondaryTrainingLevel(secondaryTrainingLevel) {\n\t\tif (secondaryTrainingLevel) {\n\t\t\tvar allCaps = [\"raaps\"];\n\t\t\tif (allCaps.indexOf(secondaryTrainingLevel) > -1) return secondaryTrainingLevel.toUpperCase();else return (0, _utils.ucfirst)(secondaryTrainingLevel);\n\t\t}\n\t\n\t\treturn \"\";\n\t}\n\t\n\tfunction renderSubjectEvalUrl(url, type, evaluation) {\n\t\tif (['sort', 'type'].indexOf(type) !== -1) {\n\t\t\tif (evaluation.seen_by_subject_at) return evaluation.id;else return evaluation.id * _constants.UNSEEN_EVALUATION_PRIORITY;\n\t\t}\n\t\n\t\tif (evaluation.seen_by_subject_at) return url;else return _constants.NEW_ITEM_TAG + ' ' + url;\n\t}\n\t\n\tfunction renderEvaluatorEvalUrl(url, type, evaluation) {\n\t\tif (['sort', 'type'].indexOf(type) !== -1) {\n\t\t\tif (evaluation.seen_by_evaluator_at) return evaluation.id;else return evaluation.id * _constants.UNSEEN_EVALUATION_PRIORITY;\n\t\t}\n\t\n\t\tif (evaluation.seen_by_evaluator_at) return url;else return _constants.NEW_ITEM_TAG + ' ' + url;\n\t}\n\t\n\tfunction createEditAndDeleteButtons(thing, name) {\n\t\tvar dataAttributes = getDataAttributes(thing);\n\t\n\t\tvar editButton = '<button type=\"button\" class=\"btn btn-xs btn-info edit-' + name + '-button\" ' + dataAttributes + '><span class=\"glyphicon glyphicon-edit\"></span> Edit</button>';\n\t\n\t\tvar deleteButton = '<button type=\"button\" class=\"btn btn-xs btn-danger delete-' + name + '-button\" ' + dataAttributes + '><span class=\"glyphicon glyphicon-remove\"></span> Delete</button>';\n\t\n\t\treturn [editButton, deleteButton];\n\t}\n\t\n\tfunction getDataAttributes(thing) {\n\t\tvar excludes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\n\t\tvar dataAttributes = \"\";\n\t\tObject.getOwnPropertyNames(thing).forEach(function (propName) {\n\t\t\tif (!(excludes.indexOf(propName) !== -1) && thing[propName] != null) dataAttributes += 'data-' + propName + '=\"' + thing[propName] + '\" ';\n\t\t});\n\t\treturn dataAttributes;\n\t}\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\tvar NEW_ITEM_TAG = exports.NEW_ITEM_TAG = '<span class=\"label label-primary\">NEW</span>';\n\t\n\tvar UNSEEN_EVALUATION_PRIORITY = exports.UNSEEN_EVALUATION_PRIORITY = 1000000;\n\t\n\tvar STANDARD_OPTIONS = exports.STANDARD_OPTIONS = {\n\t\tRESIDENT: [{ value: 0, text: \"Not at CBY\" }, { value: 1, text: \"\" }, { value: 2, text: \"CBY\" }, { value: 3, text: \"\" }, { value: 4, text: \"CA-1\" }, { value: 5, text: \"\" }, { value: 6, text: \"CA-2\" }, { value: 7, text: \"\" }, { value: 8, text: \"CA-3\" }, { value: 9, text: \"\" }, { value: 10, text: \"Attending\" }],\n\t\tFELLOW: [{ value: 0, text: \"Not at fellowship level\" }, { value: 1, text: \"\" }, { value: 2, text: \"Fellow - 1\" }, { value: 3, text: \"\" }, { value: 4, text: \"Fellow - 2\" }, { value: 5, text: \"\" }, { value: 6, text: \"Fellow - 3\" }, { value: 7, text: \"\" }, { value: 8, text: \"Fellow - 4\" }, { value: 9, text: \"\" }, { value: 10, text: \"Fellow - 5\" }],\n\t\tFACULTY: [{ value: \"strongly-disagree\", text: \"Strongly Disagree\" }, { value: \"disagree\", text: \"Disagree\" }, { value: \"undecided\", text: \"Undecided\" }, { value: \"agree\", text: \"Agree\" }, { value: \"strongly-agree\", text: \"Strongly Agree\" }, { value: \"n-a\", text: \"N/A\" }]\n\t};\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.appendAlert = appendAlert;\n\texports.ucfirst = ucfirst;\n\tfunction appendAlert(alertText) {\n\t\tvar parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#alert-container';\n\t\tvar alertType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'danger';\n\t\tvar dismissable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\t\n\t\tvar alert = document.createElement(\"div\");\n\t\talert.className = \"alert alert-\" + alertType;\n\t\talert.role = \"alert\";\n\t\n\t\tif (dismissable) {\n\t\t\talert.className += \" alert-dismissable\";\n\t\t\tvar close = document.createElement(\"button\");\n\t\t\tclose.type = \"button\";\n\t\t\tclose.className = \"close\";\n\t\t\tclose.setAttribute(\"data-dismiss\", \"alert\");\n\t\t\tclose.setAttribute(\"aria-label\", \"Close\");\n\t\n\t\t\tvar innerClose = document.createElement(\"span\");\n\t\t\tinnerClose.setAttribute(\"aria-hidden\", \"true\");\n\t\t\tinnerClose.innerHTML = \"&times;\";\n\t\t\tclose.appendChild(innerClose);\n\t\n\t\t\talert.appendChild(close);\n\t\t}\n\t\n\t\talert.insertAdjacentHTML(\"beforeend\", alertText);\n\t\n\t\t$(parent).append(alert);\n\t}\n\t\n\tfunction ucfirst(str) {\n\t\treturn str.charAt(0).toUpperCase() + str.substring(1);\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=bundle.js.map"]}